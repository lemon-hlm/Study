# 3 Segment Selector Register（段寄存器）

段寄存器有时被表述为**段选择子寄存器**，包括两大部分：**visible（可视部分**）与**invisible（不可视部分**）。

![config](./images/10.png)

如图所示，灰色部分是不可视部分，**只有Selector域是可视部分**。不可视部分隐藏在寄存器内部只有处理器可用，有时也被称为Cache部分。

>invisible部分由segment descriptor加载而来，作为一个段的cache作用。

在不改变段的情况下，对内存段进行访问，处理器从段寄存器内部的cache（不可视部分）读取段的信息，避免重复加载segment descriptor。

在**64位模式**下，段寄存器的**base地址**部分被扩展为**64位**，**limit域固定为32位**，Attribute和Selector是**16位宽**。在compatibility模式下依然使用base的低32位值。

**64位模式是128位, 32位模式是96位, 但是只有16位selector可见！！！**.

实质上，在**x64体系（Intel64和AMD64**）的机器上，寄存器的宽度本来就是64位，在实模式下低16位可用，在32位保护模式和compatibility模式下，低32位可用。

- Base域：提供**段的基址**。
- Limit域：提供**段限**，这个32位的段限是从Segment descriptor计算而来，Semgent descriptor里提供的limit域是20位宽的，加载到段寄存器后值被计算出32位。
- Attribute域：分别由**Segment descriptor**的Type、S、DPL、P、G、D/B、L，以及AVL域组合而来。
- Selector域：使用**selector加载新的段**时，selector会被加载到段寄存器的selector域。

在使用这些段寄存器之前，应该先加载，下面是一个典型的**段描述符加载到段寄存器的示意图**。

![config](./images/11.png)

当段寄存器发生加载时，根据**Selector**得到**segment descriptor**，**Selector**将加载到**段寄存器的Selector域**，同时**segment descriptor**也将加载到**段寄存器的不可视部分（Cache**）。

segment descriptor加载到段寄存器中几乎是一对一加载，除了limit域：在**segment descriptor**的**limit域是20位**，而**段寄存器**中的**limit是32位宽**的。descriptor内20位的limit计算为32位后加载到段寄存器的limit域。

使用下列指令可以对Data segment寄存器进行**显式的加载**。

- mov指令：mov sreg，reg16。
- pop指令：pop es，pop ds，pop ss，pop fs，以及pop gs。
- lds，les，lss，lfs，以及lgs。

下列情形对**CS寄存器**或**SS寄存器**进行**隐式的加载**。

- 提供一个far pointer给jmp/call指令，进行远跳转/调用，根据提供的selector进行加载。

- 使用retf和iret指令进行返回时，根据stack中的image对CS寄存器进行加载，以及对SS寄存器（权限改变时）进行加载。

- 使用int指令进行中断调用，或者发生中断/异常时，对CS和SS寄存器（权限改变时）进行加载。
- 使用**TSS/Task\-gate**进行**任务切换**时，根据TSS段内的段寄存器image进行加载。
- 使用sysenter/sysexit，syscall/sysret指令时，处理器对CS和SS进行selector加载和一些强制性的设置。

在**64位模式**下，lds、les指令无效；pop ds、pop es，以及pop ss指令无效；**使用TSS机制进行任务切换将不再支持(！！！**)。