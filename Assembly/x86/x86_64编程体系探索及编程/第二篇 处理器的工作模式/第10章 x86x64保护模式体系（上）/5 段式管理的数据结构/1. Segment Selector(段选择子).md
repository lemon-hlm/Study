- 1 Segment Selector(段选择子)的结构
- 2 Segment Selector的加载
- 3 Null Selector在64位模式下
    - 3.1 加载Null selector到SS段寄存器
- 4 隐式地加载Null selector

# 1 Segment Selector(段选择子)的结构

Segment Selector结构是**16位(恒16位！！！**)，它是一个段的标识符，结构如下。

![config](./images/5.png)

- RPL（Requested Privilege Level）：请求**访问者**所使用的权限级别，**从0到3级**。
- TI（Table Indicator）：描述符表索引位。当**TI=0**时，从**GDT**查找；当**TI=1**时，从**LDT**查找。
- Index（Descriptor Index）：这是Descriptor在GDT/LDT中的序号，根据TI的值在相应的描述表中查找descriptor。

注意，**段选择子不是段寄存器，不能混为一谈， 段选择子是一个数值，只有16位，段寄存器是寄存器，128位或96位, 其可见部分等于段选择子(！！！**), 段寄存器详见下面节.

当有下面的selector时，

```assembly
selector=0008H           ； RPL=0，TI=0，Index=1
```

表示将在GDT的第1项得到Descriptor，访问者使用的权限是0级。

>当Index为0，并且TI为0时，它在GDT内的第0项，是一个无效的selector，被称为Null selector（TI=1时，有效）。

当selector的值为**0000H到0003H**时，这个selector是**Null selector**，它指向**GDT的第0项**，第0项的Descriptor是unused（不被使用的）。Null selector的作用**类似于C指针中的NULL值**，用于**防止代码对unused segment register（未使用的段寄存器）进行访问**。

**13位的Index**取值范围是0～1FFFH（0～8191），表示selector可以寻址**8192个descriptor**（而0号的Null selector是无效）。

# 2 Segment Selector的加载

当代码被允许访问时，**selector值**会被加载到**segment selector register内**，像下面两类典型的访问，就会发生selector的加载。

```assembly
mov ax，0008H                ； selector=08H
mov ds，ax                    ； 加载 selector 到 DS寄存器
```

当descriptor的权限允许以及类型相符时，处理器会加载selector到DS寄存器的selector域里，同时对应的segment descriptor也会被加载到DS寄存器的Cache部分。（段寄存器结构稍后会探讨。）

```assembly
jmp 0008h：00001000h        ； 执行一个far jmp指令
call 0008h：00001000h       ； 执行一个far call指令
```

像上面的指令提供一个far pointer进行jmp/call操作，同样在通过处理器的检查后，处理器会加载selector到CS寄存器的selector域里，同时相应的Code segment descriptor也会被加载到CS寄存器。

注意：Null selector不允许加载到CS及SS寄存器，会产生#GP异常。允许被加载到ES、DS、FS，以及GS寄存器中，但是这些寄存器使用Null selector进行访问时会产生#GP异常。

当加载一个Null selector到上述允许的段寄存器时，处理器并不真正读取GDT的第0项segment descriptor到段寄存器中，而是以一个无效的unused descriptor来初始化段寄存器（段寄存器内除了S标志为1外，其他都为0）。

```assembly
mov ax，03H                  ； selector=03H
mov ds，ax                   ； Null-selector 加载
```

DS的结果是：DS.selector=03H，base/limit/attribute=0H（除了S标志为1外）。

# 3 Null Selector在64位模式下

在64位模式下，处理器对Null selector的使用并不检查。允许加载Null selector到除CS寄存器外的任何一个段寄存器（SS段寄存器有条件限制），以及使用这些Null selector进行访问。

## 3.1 加载Null selector到SS段寄存器

64位模式下，在**非3级权限**里，允许为**SS段寄存器加载一个Null selector**，即在0级、1级和2级权限下。假设当前运行在2级权限下，则下面的代码是正确的。

```assembly
mov ax，02H                  ； RPL=2
mov ss，ax                    ； Null-selector 加载，OK！
```

可是如果当前运行在3级权限下，则下面的代码是错误的。

```assembly
mov ax，03H                  ； RPL=3
mov ss，ax                   ； Null selector引发 #GP异常
```

Null selector的隐晦点在当使用retf指令（远调用返回）或iret指令（中断例程返回）时，如果发生权限的改变，引发stack切换的情景下变得更明显。

```assembly
push 3                   ； SS=Null selector
push USER_RSP
push USER_CS | 3      ； 切换到 3 级权限代码
push USER_ENTRY
retf                     ； #GP异常，不允许为SS加载3级权限的Null selector
```

在64位模式下，切换到3级的用户代码时，提供Null selector是错误的。明白了不能在3级权限下加载Null selector到SS寄存器后一切都变得豁然开朗了，归根到底还是因为忽视了Null selector的RPL的重要性。

# 4 隐式地加载Null selector

有时候处理器会隐式地为SS寄存器或其他Data Segment寄存器加载一个Null selector，这时候加载Null selector是有用的。

① 在执行RETF（远过程返回）或IRET（中断返回）指令时：当发生权限的改变（从高权限切换到低权限）时，如果ES、DS，FS，以及GS段寄存器内的DPL值低于CPL（DPL \< CPL），那么处理器将会为这些段寄存器隐式地加载Null selector。

② 在long mode下（包括64位模式和compatibility模式），使用call gate进行调用，发生权限改变（从低权限切换到高权限）时，处理器将会加载一个Null selector到SS寄存器，SS.selector.RPL会被设为新CPL值。

③ 在long mode下（包括64位模式和compatibility模式），使用INT进行中断调用（或者发生中断/异常），发生权限改变（从低权限切换到高权限）时，处理器也会加载Null selector到SS寄存器，SS.selector.RPL被设为新的CPL值。

在第一种情形里，由于从高权限切换到低权限代码，将Data segment寄存器（ES、DS、FS和GS）隐式加载为Null selector是为了防止在低权限代码里对高权限数据段进行访问。

![config](./images/6.png)

在64位模式下无须重新加载，数据段寄存器可以使用Null selector进行访问，而在legacy和compatibility模式下在使用这些段寄存器之前应该为它们重新加载。

在第二和第三种情形下，是承接了上面所述的64位模式下加载Null selector到SS寄存器的条件。从低权限切换到高权限（也就是：非3级权限下）的64位代码下，处理器会为SS寄存器自动加载一个Null selector，目的是在这个64位的代码里调用其他更高权限的64位例程（库routine等）时，在返回时可以判断调用者是64位的高权限代码。

下面是一个示意图。

![config](./images/7.png)

在上图中，这种嵌套的64位代码权限改变调用中，图中的0级kernel service代码返回到稍低一级的桩代码的过程里，处理器检查到压入的SS是Null selector，那么这个Null selector作为一个标志（调用者是64位的非3级权限代码），就为kernel service的设计提供了一个灵活的处理手法（根据这个标志可以选择进行/或不进行一些相应的处理）。

在这个64位代码进行stack切换的返回过程中，处理器允许Null selector被加载到SS寄存器中，不会产生#GP异常。这个条件是，目标代码的DPL不是3级（返回到非3级权限的代码）。

在legacy/compatibility模式下，以及在64位模式返回到3级代码的情形下，不允许从stack中pop出null selector。