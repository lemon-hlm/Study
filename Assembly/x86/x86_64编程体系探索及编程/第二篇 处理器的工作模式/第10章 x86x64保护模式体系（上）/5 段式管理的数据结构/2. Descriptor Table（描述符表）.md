- 2 Descriptor Table（描述符表）
    - 2.1 描述符表寄存器
    - 2.2 GDTR
    - 2.3 GDTR的加载
    - 2.4 GDT的limit

# 2 Descriptor Table（描述符表）

**Segment Selector**用于在**Descriptor Table（描述符表**）里查找**descriptor（描述符**），在x86中有**三类描述符表**：**GDT（Global Descriptor Table**），**LDT（Local Descriptor Table**）和**IDT（Interrupt Descriptor Table**）。

## 2.1 描述符表寄存器

这些descriptor table由**descriptor table register（描述符表寄存器**）进行定位，因此，**三种描述符表**就对应着**三种描述符表寄存器**：**GDTR**，**LDTR**和**IDTR**。

## 2.2 GDTR

![config](./images/8.png)

GDTR的limit域是**16位值**，最大的limit是FFFFH，base可以在处理器linear address空间的任何位置。

![config](./images/9.png)

如图所示，GDTR.base提供GDT的基地址，GDTR.limit提供GDT表限。在longmode（包括64位模式和compatibility模式）下，GDTR.base是64位的GDT base值；在compatibility模式下，处理器也将读取64位的base值。

## 2.3 GDTR的加载

在selector能访问GDT之前，必须要对GDTR进行设置（加载寄存器），系统软件使用lgdt指令加载GDTR。

```assembly
lgdt [GDT_POINTER]                      ； 加载GDTR
```

或者

```assembly
mov eax，GDT_POINTER
lgdt [eax]
GDT_Pointer：       dw  3FFh                    ； GDT limit
dd  200000h                ； GDT base
```

lgdt指令在0级权限里执行，必须为它提供一个内存操作数，这个内存地址里低16位是GDT的limit值，高32位是base值（在64位代码里使用64位的值），这些值将被装入GDTR的limit和base域里。

## 2.4 GDT的limit

使用selector对GDT进行访问时，处理器会**检查selector是否超出GDT的limit**。若GDT的limit值为3FFh，那么GDT内的有效范围是0～3FFh（偏移量）。

当GDT的limit值为0C6h时，下列情形就超出了limit范围。

① 当使用0xc0作为selector访问GDT时。

```assembly
mov ax，0xc0              ； selector为C0h
mov ds，ax             ； #GP 异常（超限）
```

这个selector的Index是0x18，所访问的空间应该是C0h到C7h（8个字节的空间），然而limit的值是C6h，这超出了GDT的limit，将引发#GP异常。

② 当使用0xc8作为selector访问GDT时，超出了GDT的limit。

在GDT中segment descriptor是8个字节的，在①情形中，GDT的limit值不能容纳完整的descriptor宽度，使得selector访问的descriptor最后一个字节超出了GDT的limit。