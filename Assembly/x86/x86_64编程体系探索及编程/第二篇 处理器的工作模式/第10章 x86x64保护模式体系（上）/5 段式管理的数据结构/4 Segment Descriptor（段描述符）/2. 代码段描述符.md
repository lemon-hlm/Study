- 4.2 代码段描述符
    - 4.2.1 Accessed访问标志
    - 4.2.2 Readable可读类型
    - 4.2.3 conforming与non-conforming代码段
    - 4.2.4 DPL属性
    - 4.2.5 S属性
    - 4.2.6 P属性
    - 4.2.7 D/B属性
    - 4.2.8 long mode下的D/B属性
    - 4.2.9 L属性
    - 4.2.10 G属性

## 4.2 代码段描述符

Code segment（代码段）描述符结构（**64位宽**）如下。

![config](./images/12.png)

对于**Code段**来说，它的类型取值范围是**8～F**，对于4位的Type域来说，还可以进行一细化为

![config](./images/13.png)

**Code/Data标志**指示段描述符属于**Code段还是Data段**，1属于Code段（指示该段可执行并且不可写）。

**C标志位**是比较重要的，C=1时为**conforming类型**，C=0时为non\-conforming类型，0x8～0xB是non\-conforming类型，0xC～0xF是conforming类型。

**32位的段base值**被分为2个部分：base的低24位放在segment descriptor的bit 39位到bit 16位上。base的高8位放在segment descriptor的bit 63到bit 56位上。（注意区分：在Intel和AMD的手册上以2个32位结构进行描述，在这里以一个64位结构进行描述。）

**20位的段limit值**也被分为2个部分：limit的低16位放在segment descriptor的bit 15到bit 0位上，高4位放在segment descriptor的bit 51到bit 48位上。20位的limit值经过计算为32位后被加载到段寄存器上。

### 4.2.1 Accessed访问标志

在type域里的A标志（accessed）指示段是否被访问过，A=1表示已经被访问过（被加载到段寄存器中），A=0表示未访问。

当段描述符被加载到段寄存器时，只有当A标志位为0时，处理器才会对在GDT/LDT中的segment descriptor中的A标志进行置位，这种行为可以让系统管理软件（典型的是内存管理软件）知道哪个段已经被访问过。

可是一旦置位，处理器从不会对A标志位进行清位。系统软件在对descriptor进行重新设置的时候，可以对A标志位进行清位。在处理器再次加载descriptor的时候对A标志位重新置位，在这种情况下，A标志往往配合P标志位使用。系统软件在对A标志和P标志位进行修改的时候应当使用LOCK指令前缀锁bus cycle。

当处理器加载descriptor到段寄存器时，处理器会对descriptor执行自动加lock的行为，处理器在访问这个descriptor期间，其他处理器不能修改这个descriptor。

这个加载descriptor期间，应当包括从对descriptor检查到最后的使用descriptor更新段寄存器内的Cache部分。

### 4.2.2 Readable可读类型

一个代码段不可能被写访问，但可以被读访问，当代码段的类型标志R设为1时，表示该代码段可以被读，那么就可以像下面这样使用CS段进行读访问。

```assembly
mov eax，cs：[ebx]              ； 通过CS寄存器读代码段空间
```

或者可以将code segment descriptor加载到数据段寄存器进行读访问。

```assembly
mov ax，CODE_SEL                 ； CODE_SEL是一个代码段描述符
mov es，ax                         ； 将代码段描述符加载到ES
mov eax，es：[ebx]
```

前提是有足够的权限加载（non-conforming类型）描述符，CPL<=DPL并且RPL<=DPL。或者是对于conforming类型的代码段描述符加载总是成功的。

### 4.2.3 conforming与non\-conforming代码段

conforming类型的代码强迫使用低权限或相等权限（CPL>=DPL）来运行，nonconforming类型的代码限制用户使用低权限来运行（进入高权限代码需要通过gate符调用）。

conforming段的另一个重要特性是：进入conforming段运行不改变当前运行的CPL值（无论是通过直接调用还是gate调用）。

![config](./images/14.png)

如上图所示，在同一段3级权限的用户代码里，分别调用conforming段和nonconforming段的代码，采用直接调用的方式。

```assembly
call selector：offset              ； 提供far pointer直接调用
```

从3级直接调用0级权限的conforming段代码获得通过，处理器检查CPL>=DPL（低权限或相等权限），而调用0级的non\-conforming段代码将失败，处理器检查到CPL != DPL（权限不相等）。

conforming段的代码将阻止使用高权限执行，假如调用者的权限是0级，而conforming段的权限为1级，那么这个调用将失败。因此当conforming段使用0级DPL时，就可以在任何权限里执行。进入conforming段不会引起权限和stack的切换。

non\-conforming段的代码将阻止使用低权限执行，而强迫通过使用gate来执行高权限的代码。

>**需要保护**的代码和数据应该**使用non\-conforming段**，而对于**不重要、无须保护**的代码可以使用conforming段。

在某些场合下，使用conforming段会比使用non-conforming段灵活：例如要使一个库routine能在任意权限下运行，前提是这个库routine并不涉及重要的数据和使用系统资源。

基于这种要求，我们来对比一下conforming段与non-conforming段。

① 使用conforming段，并将DPL设为0级权限，在3级权限下可以直接调用（CPL>DPL），在0级权限下，依然可以使用直接调用（CPL==DPL）。

② 使用non-conforming段，并将DPL设为3级权限，在3级权限下可以直接调用（CPL==DPL），而在其他级别无法直接调用，例如在0级不能直接调用3级权限的代码（CPL！=DPL），那么在0级权限使用gate符进行调用呢？同样做不到（条件是：CPL>=DPL of Code segment）。如果将non-conforming段的DPL设为0级权限，在3级权限下可以使用gate符进行调用，在0级权限下也可以使用gate符进行调用。

相比之下，non-conforming段的执行权限需要被定义为0级，通过gate符进行调用，显得不如conforming段灵活，并且conforming段定义在3级权限，不会改变调用者的CPL值。对于不重要的库routine来说，使用conforming段会更适合些。

下面是一个典型的使用方法。

代码清单10-1（lib\conforming_lib32.asm）：

```assembly
；----------------------------------------------
； conforming_lib32_service_enter（）：conforming代码库的 stub函数
； input：
；       esi：clib32 库函数服务例程号
； 描述：
；       conforming_lib32_service_enter（）的作用是切换到 conforming段里，
；       然后调用 conforming lib32 库里的服务例程，它相当于一个 gate 的作用。
； -----------------------------------------------
__clib32_service_enter：
__conforming_lib32_service_enter：
      jmp do_conforming_lib32_service
conforming_lib32_service_pointer       dd __clib32_service dw conforming_sel
do_conforming_lib32_service：
      call DWORD far [conforming_lib32_service_pointer]   ； 使用 conforming 段进行调用
      ret
；--------------------------------------------
； conforming_lib32_service（）
； input：
；       eax：clib32 库函数服务编号
；--------------------------------------------
__clib32_service：
__conforming_lib32_service：
      mov eax，[__clib32_service_table + eax * 4]
      call eax
      retf
；----------------------------------------------------------
； get_cpl（）：得到 CPL 值
； output：
；       eax：CPL 值
；----------------------------------------------------------
__get_cpl：
      mov ax，cs
      and eax，0x03
      ret
； conforming lib32 库服务例程表
__clib32_service_table：
      dd __get_cpl                            ； 0 号
      dd __get_dpl                            ； 1 号
      dd __get_gdt_limit                     ； 2 号
      dd __get_ldt_limit                     ； 3 号
      dd __check_null_selector              ； 4 号
      dd __load_ss_reg                        ； 5 号
```

这段代码在lib\conforming\_lib32.asm库里，是专门为conforming段代码所设立的一个32位的库，\_\_get\_cpl（）函数用来获取**当前运行的CPL值**。那么，在软件里可以使用下列方式来调用。

```assembly
mov eax，0       ； clib32 库的例程编号
call __clib32_service_enter   ； 调用 clib32 库的进入函数
```

在\_\_clib32\_service\_table里，\_\_get\_cpl（）函数的编号是0，因此，给eax寄存器传递例程号由接口函数\_\_clib32\_service\_enter（）来进行调用。

它设立的目的是能**在任何权限执行**，这样就可以很方便地**获取到CPL值**。

由于conforming的特殊性——不改变CPL值，于是\_\_get\_cpl（）函数就被放在conforming里执行。如果以non\-conforming段来运行，就显得很麻烦了。

① 发生权限的改变时CPL会改变。因此还要根据情况做出相应的判断。

② 必须放在0级的DPL权限里，使得0级权限下能够执行，在3级里使用gate进行调用。

而放在conforming段里就很容易做到了，这个\_\_get\_cpl（）函数的调用路径是

\_\_conforming\_lib32\_service\_enter（）--> \_\_clib32\_service（） --> \_\_get\_cpl（）

上面是在conforming\_lib32.asm库里的执行顺序。在我们的程序里只需给出conforming段目标例程get\_cpl（）的例程号（在inc\clib.inc文件里定义了一些常量值），然后调用入口函数就可以了。入口函数\_\_conforming\_lib32\_service\_enter（）负责切换到conforming段执行。

在conforming\_lib32.asm库里的这些烦琐的调用路径是为了实现一个库的接口，当conforming\_lib32.asm库里添加更多的函数时，可以利用这个路径进入。

代码清单10-2（topic10\ex10-1\protected.asm）：

```assembly
mov esi，msg2                        ； 打印信息
call puts
mov eax，CLIB32_GET_CPL   ； 常量定义在 inc\clib.inc 头文件里
call clib32_service_enter         ； 调用 conforming 例程
mov esi，eax
call print_byte_value              ； 打印值
```

最后，在我们的程序里，分别在0级和3级用户代码里调用，结果如下。

![config](./images/15.png)

这个结果分别打印了当前的CPL值，说明处理器从0级切换到了3级权限里。结果虽然很简单，但意义重大。

### 4.2.4 DPL属性

在segment descriptor里DPL属性定义一个段所需要的最低访问权限。如果DPL设为2级权限，那么0、1和2级权限可以访问，3级权限将被拒绝。

在处理器权限检查中，DPL是一个重点的被检查对象，使用CPL与DPL进行权限对比。许多情况下还需要使用RPL与DPL进行额外的辅助对比。

### 4.2.5 S属性

S标志位指示descriptor属于System还是Code/Data（非System），Code/Data段的S位为1值，当S=0时，descriptor属于System（例如，LDT/TSS描述符，Gate描述符）。

### 4.2.6 P属性

P标志位指示一个segment或gate是否存在内存中，P=1表示segment或gate已经放在内存中，P=0表示该segment或gate不存在内存中（所需的内存没准备好）。

当P=0时加载segment descriptor到segment寄存器，会产生#NP（Segment Not-Present）异常，#NP异常是一个fault类型的异常，表示在#NP handler里必须要修复这个错误。

在#NP handler里有责任去改正Segment Not-Present错误，当内存准备好时，在#NP handler里需要将在GDT的描述符的P置为1（返回加载者表示已经准备好了），在启用paging内存管理的系统里，接收#NP异常后，应尝试将物理内存提交到segment的virtual address上，成功后将P标志置为1值。

OS内存管理模块维护segment和page（当启用paging机制时）的present状态，当page是not-present时产生的是#PF（Page\-Fault）异常。

在某些情况下，系统软件需要主动去清P标志位，当系统软件需要对descriptor进行更新时。在更新descriptor前将P标志位清0，指示为不可用的。在更新完毕后，对P标志进行置位，指示为可用的。在这种情况下P标志往往与A标志配合使用。

### 4.2.7 D/B属性

D/B在不同的segment里有不同的意义，对于Code segment来说，它指示Default operand size（默认的操作数大小），这个标志位被称为D标志位，D=1指示Code Segment的默认操作数是32位，D=0时是16位。

### 4.2.8 long mode下的D/B属性

在long mode下，Code segment的D标志与L标志（L标志在legacy模式下是保留位）组合使用，如下所示。

![config](./images/16.png)

如上所述：L=0时处理器处于compatibility模式，再根据D标志选择相应的default operand size（默认操作数）。当L=1时处理器处于64位模式，但是还需要D标志位配合（D需为0）。

值得注意的是，x64体系规定L=1且D=1是无效的组合。

在实模式下，由于CS.D为0，因此实模式下默认的操作数是16位的。

无论默认操作数是16位还是32位，操作数的大小是可以改变的，通过使用operand size override（操作数大小的改写）操作。

```assembly
bits 16
mov eax，1                 ； 16位默认操作数下，使用32位的寄存器
```

如上所示。在汇编语言代码层上，在16位的默认操作数下使用32位的寄存器，那么编译器会为这条指令生成一个额外的operand size override prefix字节，它是66H，从而可以使用32位宽的操作数。

当L=1且D=0时，使用该Code segment时将进入64位模式，但默认操作数还是32位的（部分指令是64位的），那么要使用64位的操作数，需要使用REX.W进行扩展。

```assembly
bits 64
mov rax，1                 ； 32位默认操作数下，使用64位的寄存器
```

同样的情形下，编译器会为这条指令生成的机器码中加入REX prefix（前缀），REX字节为48H（REX.W=1），这样操作数被扩展为64位宽。

![config](./images/17.png)

上图揭示了D标志重要性的另一面：当D=0时，由于默认操作数是16位的，影响到call指令在调用时压入了16位的返回地址（当前的ESP指针是32位），即使在SP为16位的前提下，如果D=1，call指令将压入32位的返回地址而不受SP指针的影响。

### 4.2.9 L属性

L标志位仅用于long mode的Code segment descriptor。L=1表示进入64位模式，L=0表示进入compatibility模式。L标志需配合D标志使用，详见上面的D/B属性描述。

### 4.2.10 G属性

G标志位指示**segment limit的粒度**。当G=1时，段限的粒度为**4KB**，当G=0时段限的粒度为1 byte。G标志配合limit域使用，20位的limit值配合G标志的计算后产生32位的limit值。

- G=0时：32位的段限就是limit域的值。
- G=1时：32位的段限=limit×4K+FFFH。

假如segment descriptor的20位limit域是FFFFF，那么最终32位的段限是

```assembly
FFFFFh × 1000h + FFFh=FFFFFFFFh
```

段的limit值的计算方式是统一的，但段内有效区域实际上较为复杂，分为Expandup和Expand\-down两种类型。这在10.5.4.5节有详细的描述。