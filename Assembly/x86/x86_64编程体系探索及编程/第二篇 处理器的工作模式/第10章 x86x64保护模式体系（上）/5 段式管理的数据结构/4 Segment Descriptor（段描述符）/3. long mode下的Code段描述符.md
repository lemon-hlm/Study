## 4.3 long mode下的Code段描述符

在long mode（包括**64位模式**和**compatibility模式**）下，Code Segment Descriptor的**L标志**是一个**切换开关**，它将指示段描述符在64位模式和compatibility模式角度下进行切换解析，如下所示。

![config](./images/18.png)

当L=1时切换到64位模式，这时候Code segment descriptor使用64位模式的定义（对描述符采用64位模式解析），当L=0时切换到compatibility模式，这时候Code segment descriptor使用legacy定义，**compatibility模式下和legacy下定义是完全一致**的。

在64位模式下大部分域都是无效的，仅有少数几个属性标志有效，如下所示。

![config](./images/19.png)

**灰色部分是无效域**，将被忽略，白色的属性标志——C标志，DPL标志，P标志，L标志，以及D标志是有效的。**固定部分是必须设置为1的标志（S=1，以及Code/Data=1**）。

在**64位模式**下，由于**段的base**和**段的limit**都**无效**被忽略，它**强制所有段的base为0(！！！)，limit为FFFFFFFFH(64位满！！！)，只有FS和GS寄存器可以使用非0值的段base**。

下面是一个典型的long mode下代码段描述符的定义。

```assembly
；；； 定义一个64位代码段，DPL=0，P=1，S=1，Code/Data=1，L=1，D=0
kernel_code64_desc    dq 0x0020980000000000     ； Attribute=2098H
```

除了属性域外，其他的域都为0值，可见在**64位模式下大大简化了segment descriptor的定义**。当L=1且D=0时，目标代码是64位模式的。L=1且D=1时是无效的组合。L=0时，根据D标志位判断目标代码是32位还是16位的默认操作数。

这是否就是x64体系中在64位OS里向下平滑地兼容执行legacy应用程序的原理呢？

没错！在x64体系中，可以使用全新的64位操作系统，当OS开启long mode并激活long mode，这时候处理器进入long mode。OS的kernel及其executive组件运行在64位模式，而应用程序可以是32位或64位，**运行32位的应用程序**处理器将**转入到compatibility模式**运行，运行64位应用程序则切换回64位模式。

处理器就是根据目标程序加载的Code segment descriptor中的L标志进行切换。因此可以使用一个32位程序的Code segment descriptor而无须任何修改或重新编译。在long mode下，程序代码可以在compatibility与64位模式下任意切换（前提是执行环境设置正确）。