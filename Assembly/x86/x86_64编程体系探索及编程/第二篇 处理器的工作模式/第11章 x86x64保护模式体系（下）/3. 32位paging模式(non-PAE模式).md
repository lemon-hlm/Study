[TOC]

# 1 基本原理

在**32位paging模式**里，**virtual address是32位宽**。映射的**物理地址**在**支持PSE\-36机制**下是**36位或40位**（取决于**MAXPHYADDR值**），否则**为32位**。

![config](./images/9.png)

上图显示了在**32位paging模式**下的**4K和4M页面**的page frame获取路径。**CR3提供PDT的基地址**。

**灰色线路**是4M页面的路径：在PDT里的entry结构（PDE）的**PS标志为1**时，PDE指向4M的物理page frame。线性地址中的[21：0]域是22位的4M页面的offset值。

**黑色线路**是4K页面的路径：当PDE.PS=0时，PDE指向Page table结构，再由PTE指向最终的4K物理page frame，线性地址中的[11：0]域是12位的4K页面的offset值。

## 1.1 两种页表结构

从上图我们看到在32位paging模式里使用了两种页表。

① Page Directory Table（页目录表）：和其中的PDE结构作为一类，线性地址的[31：22]域是PDT的索引值，在PDT内查找对应的PDE结构。

② Page Table（页表）：和其中的PTE结构作为一类，线性地址的[21：12]域是PT的索引值，在PT内查找对应的PTE结构。

## 1.2 page offset值

对于4K页面来说线性地址的[11：0]域是page内的offset值，对于4M页面来说线性地址的[21：0]域是page内的offset值。

## 1.3 页表的大小

在32位paging模式下，PDT的索引值和PT的索引值是10位，可以查找到1024个表项，而每个表项（PDE和PTE）的大小是4字节宽，因此每个PDT和PT的size都是4KB。

在完整的一级paging里总共需要多少个页转换表结构和多少内存量？

这个要视映射的范围来定，假如要映射完整的4G虚拟地址，以4K页面映射的话将需要：

① 需要1个PDT，占用4K内存。

② PDT里有1024个PDE表项，那么需要1024个PT，占用4K×1024=4M内存。

总共需1025个页转换表结构，占用4M+4K的内存量。如果全部page以4M页面映射，将大大减少内存需求量，只需要1个PDT，占用4K的内存量。

# 2 CR3结构

在32位paging模式下的CR3结构如下。

![config](./images/10.png)

在32位paging模式下，CR3使用低32位（在Intel64或AMD64机器上64位），CR3的Bit 31到Bit 12位提供20位的Page Directory Table的物理基地址。那么以36位的物理基地址为例，它是这样形成的。
① base of PDT[35：32]=0值（高8位Bit 35到Bit 32为0值）。
② base of PDT[31：12]=CR3[31：12]（由CR3的Page Driectory base域提供）。
③ base of PDT[11：00]=0值（低12位补0）。
因此CR3提供的PDT物理基地址是4K边界对齐的。
32位paging下最高为40位物理地址（依赖于PSE-36与MAXPHYADDR值）。
PWT
这是page级的Write-Through标志位，当PWT=1时使用Write-Through的Cache类型，当PWT=0时使用Write-Back的Cache类型。它受到CR0.CD控制位的影响，当CR0.CD=1时（Cache被Disable掉）PWT标志会被忽略。
PCD
这是page级的Cache Disable标志位。当PCD=1时，物理页面是不能被Cache的，清0时允许。当CR0.CD=1时，PCD标志位被忽略。
PWT和PCD标志使用在CR3中，整个页转换表结构都受到影响。
11.3.2 32位paging模式下的PDE结构
如下图所示，它是4K页面和4M页面共同使用的结构。
[插图]
当PDE.PS=1时，它将作为4M页面的PDE结构，当PDE.PS=0时，它作为4K页面的PDE结构，这两种解析存在区别。
11.3.2.1 4K页面的PDE结构
在PDE.PS为0时，使用4K页面的PDE结构，如下图所示。
[插图]
在这个结构里，PDE[31：12]是Page table结构的物理基地址，在这个32位paging模式的4K页面里，能映射的物理地址最高是32位，下一级32位的page table物理地址形成如下。
① base of PT[31：12]=PDE[31：12]，它是PDE的高20位值。
② base of PT[11：0]=0值，32位地址的低12位补0。
因此，PDE里提供的PT物理基地址是4K边界对齐的。
P（Present）标志位
必须为1，表示page table或page是存在内存中，否则产生#PF异常。它与段描述符中的P标志位意义相同，不同的是段描述符中的P=0时产生#NP异常。
R/W（Read/Write）标志位
这个标志位指示和决定物理page的读/写权限。为0时是只读的，为1时是可读/写的。当CR0.WP为0时，Supervisor可以对只读页进行写操作。关于R/W标志位如何决定物理page读/写权限，在第11.8节有详细描述。
U/S（User/Supervisor）标志位
这个标志位指示和决定物理page的访问权限，当为0时只有Supervisor（0级、1级或者2级权限）才能访问，当为1时User（3级权限）和Supervisor可以访问。关于U/S标志位如何决定物理page的访问权限，在第11.8节有详细描述。
PWT（Page-level Write-Through）标志位
定义页级的Cache类型，见11.3.1节。
PCD（Page-level Cache Disable）标志位
指示页级是否可Cache，见11.3.1节。
A（Accessed）标志位
为1时，指示和决定物理page是否已被访问（读或写）。一旦置位，处理器从不清这个标志位。这个标志位可被OS的内存管理软件利用。
PS（Page Size）标志位
PS标志位仅使用在PDE和PDPE结构中，为1时，表示PDE或PDPE指向物理page frame，为0时，指向下一级页转换表结构。
在这个4K页面的PDE结构里，PS值为0，它将指向PT的物理基地址。在PDE结构中灰色部分为忽略域，不影响使用。
11.3.2.2 4M页面的PDE结构
当PDE.PS为1时，使用下面的4M页面PDE结构。

[插图]
这个PDE结构里将提供4M页面的基地址，然而这个4M物理page frame地址的设置，需要注意。
① 当处理器不支持PSE-36功能时，4M page frame只能映射到32位的物理地址空间上，这时候PDE[21：13]是保留位，必须设置为0值。
② 当MAXPHYADDR值为36位时，PDE[16：13]是4M page base[35：32]位，而PDE[21：17]是保留位，必须设置为0值。
③ 当MAXPHYADDR值为40位时，PDE[20：13]是4M page base[39：32]位，而PDE[21]位是保留位，必须设置为0值。
④ 当MAXPHYADDR值为52位时，也仅能使用40位的物理地址，同3）。
因此，4M page frame的基地址形成除上述所说外，36位或40位的物理地址低22位将补0，物理页面将在4M边界上对齐。
D（Dirty）标志位
这个标志位仅被用于描述page的属性。当page被写时，处理器将D标志置位，指示已被写过，处理器从不会清D标志位。典型地D标志和A标志可被OS内存管理软件使用。
G（Global page）标志位
这个标志位仅被用于描述page的属性。当CR4.PGE=1时，可置G标志位为1，指示page是global page。在CR3被更新时，TLB内的global page不被刷新。
PAT（Page-Attribute Table）标志位
当CPUID.01H：EDX[16] support位为1时，可以使用PAT功能，PAT标志位可被置位。否则为保留位，必须为0值。它指示了page的属性。
注意，D标志、G标志以及PAT标志位仅被使用在对page的管理上。
① 当4K页面时，使用在PTE结构上。
② 当4M和2M页面时，使用在PDE结构上。
③ 当1G页面时，使用在PDPE结构上。
否则在其他page entry页项结构里D标志和G标志被忽略，PAT标志位为0值。
保留位与忽略位
在各级页表项（entry）结构里，会有保留位或者忽略位。它们的意义是不同的，保留位必须为0，处理器会对保留位进行检查。忽略位不会被检查，不起作用。
PS（Page Size）标志位
在4M和2M页面里，PDE的PS标志位为1。在1G页面里，PDPE的标志位为1。在其他的page表项结构里为0值（在PTE结构里PS位被用做PAT标志位）。
11.3.2.3 4K页面的PTE结构
PTE结构指向物理page frame基址（在4M页面里由PDE结构指向）。4K页的page frame是4K边界对齐的。
[插图]
在32位paging模式下4K页面使用的是32位的最高映射物理地址。因此page frame的形成如下。
① page base[31：12]=PTE[31：12]，PTE的高20位对应物理页面的高20位。
② page base[12：0]=0值。物理页面的低12位补0。
在上图中，PTE结构的Bit7位由PS标志位变为PAT标志位。
描述page的属性
如同4M页面的PDE结构，D标志、G标志，以及PAT标志被使用在4K页面的PTE结构里。其意义是完全一致的。
11.3.3 使用32位paging
到目前为止，protected.asm模块是未开启paging机制的。在这一小节里，我们将在protected.asm模块里打开paging机制，并作为一个练习实验来使用32位paging。
实验11-2：使用与测试32位paging
这一小节的源代码在topic11\ex11-2\目录下。
配置页转换表环境
在开启paging机制前必须先设置好各级的页转换表结构，代码如下。
代码清单11-3（topic11\ex11-02\protected.asm）：
；---------------------------------------------
； init_32bit_paging（）：建立 32位paging 环境
；---------------------------------------------
init_32bit_paging：
； ① 0x000000-0x3fffff 映射到 0x0 page frame，使用 4M 页面
； ② 0x400000-0x400fff 映射到 0x400000 page frame，使用 4K 页面
；； PDT 物理地址设在 0x200000 位置上，PT物理地址在 0x201000位置上
； ① 设置 PDT[0]（映射 0 page frame）
      ； base=0，PS=1，P=1，R/W=1，U/S=1
      mov DWORD [PDT32_BASE + 0]，0000h | PS | RW | US | P
； ② 设置 PDT[1]
      ； PT的地址在0x201000位置上，设置为supervisor，only-read 权限
      ； PT base=201000h，P=1
      mov DWORD [PDT32_BASE + 1 * 4]，201000h | P
； ③ 设置 PT[0]（映射0x400000 page frame），设置为supervisor，only-read 权限
      mov DWORD [201000h + 0]，400000h | P  ； 4K page framg=400000h
      ret
init_32bit_paging（）函数的职责是设置32位paging模式下的页转换表结构，作为练习实验，为了简明这里只映射了两块区域。
① virtual address的0到0x3FFFFF区域，使用4M页面来映射。
② virtual address的0x400000到0x400FFF区域，使用4K页面来映射。
PDT的物理基地址设在0x200000位置，而PT的物理基地址设在0x201000位置上，于是virtual address区域0到0x3FFFFF将使用PDE[0]，而0x400000将使用PDE[1]，如上面代码所示，直接对PDE结构进行设置。
开启PSE功能
在32位paging分页模式下，为了使用4M页面，需要开启PSE功能。
代码清单11-4（topic11\ex11-02\protected.asm）：
pse_enable：
      mov eax，1
      cpuid
      bt edx，3                                ； PSE support？
      jnc pse_enable_done
      mov eax，cr4
      bts eax，4                               ； CR4.PSE=1
      mov cr4，eax
pse_enable_done：
      ret
上面先检测是否支持PSE功能，通过CPUID.01H：EDX[3].PSE位查询。（检查是否支持PSE似乎有些多余！并且上面的代码也没有在不支持的情况下进行提示。）最后对CR4.PSE进行置位。
当CR4.PSE=0时，将使用4K页面（PDE.PS=1时作用被忽略）。
因此，下面两种情况下效果是一致的。
① CR4.PSE=0时：关闭4M页面。
② CR4.PSE=1且PDE.PS=0时：使用4K页面。
开启paging
在对CR0.PG置位时，必须先设置PDT的物理基地址，即对CR3赋值。
代码清单11-5（topic11\ex11-02\protected.asm）：
； 初始化 paging 环境
      call init_32bit_paging
；设置 PDT 地址
      mov eax，PDT32_BASE
      mov cr3，eax
；设置 CR4.PSE
      call pse_enable
； 打开 paging
      mov eax，cr0
      bts eax，31
      mov cr0，eax
上面的代码是在protected模式下进行设置，当置CR0.PG为1时，处理器将立即进入paging机制。在mov cr0，eax指令的下一条指令将使用paging管理，处理器将在各级page表结构里walk查找EIP指针地址。
最后，为了直接显示paging机制的效果，在lib\page32.asm模块里写了一个dump_page（）函数，用来打印出被映射virtual address的PDE和PTE信息，源代码在page32.asm文件里。
代码清单11-6（topic11\ex11-02\protected.asm）：
mov esi，0x200000                ； dump virtual address 0x200000
call dump_page
mov esi，msg3
call puts
mov esi，0x400000                ； dump virtual address 0x400000
call dump_page
这段代码在用户代码里做测试，分别打印virtual address 0x200000和0x400000的各级page表结构信息。
下面是实验的结果。
[插图]
结果所示，virutal address 0x200000是在4M页面内，它的page frame地址是0，后面显示为Attribute属性，在Attribute显示里大写为置位，小写为清0。4M页面的属性为PS=1，User/Writable（用户权限可访问，可读/写）。
virtual address 0x400000是4K页面，注意它的D和A标志为0，显示未曾被访问过。并且它的访问权限是Supervisor和Only-read。它对用户代码有两个方面的限制。
① 只能被Supervisor访问，拥有0、1和2级权限。
② Only-read限制，对于用户代码来说是不可写的。
测试一：在用户代码里写0x400000地址
下面我们在用户代码里向0x400000地址写数据，将产生#PF异常。
[插图]
测试二：在0级代码里写0x400000地址
对于Supervisor访问者，当CR0.WP=0时，它可以写Only-read页面。下面我们测试在0级代码里写0x400000地址，结果如下。
[插图]
注意，此时0x400000页面的D标志和A标志已经被置位（已被写访问过）。
测试三：在开启WP功能下，0级代码里写0x400000地址
代码清单11-7（topic11\ex11-02\protected.asm）：
；测试二：在 CR0.WP=0时，在0级代码里写0x400000地址
mov DWORD [0x400000]，0
；测试三：CR0.WP=1时，写0x400000
mov eax，cr0
bts eax，WP_BIT
mov cr0，eax
mov DWORD [0x400000]，0
在0级代码里开启CR0.WP控制位后，再尝试往0x400000地址里写数据，那么将产生#GP异常。
[插图]
结果所示，执行流程未进入用户代码就产生了#PF异常。