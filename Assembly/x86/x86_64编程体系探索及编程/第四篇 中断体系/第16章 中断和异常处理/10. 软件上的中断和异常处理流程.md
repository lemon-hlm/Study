[TOC]

当中断或异常发生, 处理器最终目的将是调用相应的中断/异常处理程序进行处理, 看下面的**中断/异常服务例程调用流程**(**保护模式**下)

![config](./images/13.png)

下面看在保护模式和IA\-32e模式下, 处理器需要经过什么步骤达到执行处理程序

# 1 处理器对gate描述符和code描述符的检查

成功加载CS和EIP寄存器之前, 处理器会对gate描述符和code描述符、vector、以及selector进行检查

## 1.1 检查 IDT limit

读取gate描述符时, 处理器将检查vector是否超出IDT的limit

```c
if(IA32_EFER.LMA == 1)      /* 是否处于long mode */
{
    descriptor_size = 16;   /* 16个字节 */
}else
    descriptor_size = 8;    /* 8个字节 */
    
if (IDTR.limit >= vector * descriptor_size + (descriptor_size -1))
{
    /* 通过 */
}else{
    /* 失败, 产生 #GP 异常(一般保护错误)
}
```

若处理器当前处于IA\-32e模式(long mode), 那么gate描述符大小是16字节, 保护模式是8字节

IDTR.limit值必须大于等于:

- legacy模式下, vector \* 8 + 7
- IA-32e模式下, vector \* 16 + 15

加上7或15是为了确保一个完整的gate描述符不超过limit值, 这样才能被通过. 否则失败产生\#GP异常. **而\#GP异常必然导致\#DF(Double fault)异常**的发生, 最后结果是**机器遭到RESET**.

## 1.2 gate描述符的检查

处理器对gate描述符进行一系列的合规检查, 如下:

```c
if(IA32_EFER.LMA == 1)      /* IA-32e模式下
{
    if (gate_descriptor.type == interrupt_gate_64
            || gate_descriptor.type == trap_gate_64)
    {
        /* 通过 */
    }else{
        /* 失败: 产生#GP异常
    }
}else{                      /* legacy保护模式下 */
    if(gate_descriptor.type == INTERRUPT_GATE
            || gate_descriptor.type == TRAP_GATE
            || gate_descriptor.type == TASK_GATE)
    {
        /* pass */
    }else{
        /* 失败: 产生#GP异常 */
    }
}

if (gate_descriptor.S == 1)
{
    /* 失败: 产生#GP异常 */
}

if (gate_descriptor.P == 0)
{
    /* 失败: 产生#NP异常 */
}
```

处理器检查下面几个方面

① 在legacy保护模式下, 描述符类型是否为Interrupt\-gate, Trap\-gate或Task\-gate

② 在IA\-32e模式下, 描述符类型是否为64位的Interrupt\-gate, Trap\-gate

③ 描述符的S标志位需为0, 是System descriptor, 否则产生\#GP异常

④ 描述符P标志位需为1, 是present, 否则产生\#NP异常

实际情况更复杂, 在**legacy保护模式**下, **Interrupt\-gate和Trap\-gate分别为32位和16位**; 而**IA\-32e模式**下, Interrupt\-gate和Trap\-gate**固定是64位**.

## 1.3 目标代码段selector的检查

处理器将从gate描述符中读取selector, 处理器会对这个selector检查

```c
selector = gate_descriptor.selector;            /* 读取gate描述符的selector */

/* 下面检查是否属于NULL selector
if (selector == 0 || selector == 1 || selector == 2 || selector == 3)
{
    /* 失败: 产生#GP异常 */
}

/* 检查selector是否超限 */
if (selector.TI == 0)
{
    limit = GDTR.limit;     /* GDT */
}else{
    limit = LDTR.limit
}

if (IA32_EFER.LMA == 0)
{
    if (limit >= (selector & 0xFFF8) + 7)
    {
        /* 通过 */
    }else{
        /* 失败: 产生#GP异常
    }
    
}
```