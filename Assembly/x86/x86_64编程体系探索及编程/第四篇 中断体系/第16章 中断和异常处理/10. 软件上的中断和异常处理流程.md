[TOC]

当中断或异常发生, 处理器最终目的将是调用相应的中断/异常处理程序进行处理, 看下面的**中断/异常服务例程调用流程**(**保护模式**下)

![config](./images/13.png)

下面看在保护模式和IA\-32e模式下, 处理器需要经过什么步骤达到执行处理程序

# 1 处理器对gate描述符和code描述符的检查

成功加载**CS**和**EIP**寄存器之前, 处理器会对gate描述符和code描述符、vector、以及selector进行检查

## 1.1 检查 IDT limit

读取gate描述符时, 处理器将检查**vector**是否超出**IDT的limit**

```c
if(IA32_EFER.LMA == 1)      /* 是否处于long mode */
{
    descriptor_size = 16;   /* 16个字节 */
}else
    descriptor_size = 8;    /* 8个字节 */
    
if (IDTR.limit >= vector * descriptor_size + (descriptor_size -1))
{
    /* 通过 */
}else{
    /* 失败, 产生 #GP 异常(一般保护错误)
}
```

若处理器当前处于**IA\-32e模式**(long mode), 那么**gate描述符**大小是**16字节**, 保护模式是8字节

**IDTR.limit(该值是以字节为单位计算的！！！**)值必须**大于等于**:

- **legacy模式**下, vector \* 8 + 7
- **IA-32e模式**下, vector \* 16 + 15

加上7或15是为了确保一个完整的gate描述符不超过limit值, 这样才能被通过. 否则失败产生\#GP异常. **而\#GP异常必然导致\#DF(Double fault)异常**的发生, 最后结果是**机器遭到RESET**.

## 1.2 gate描述符的检查

处理器对gate描述符进行一系列的合规检查, 如下:

```c
if(IA32_EFER.LMA == 1)      /* IA-32e模式下
{
    if (gate_descriptor.type == interrupt_gate_64
            || gate_descriptor.type == trap_gate_64)
    {
        /* 通过 */
    }else{
        /* 失败: 产生#GP异常
    }
}else{                      /* legacy保护模式下 */
    if(gate_descriptor.type == INTERRUPT_GATE
            || gate_descriptor.type == TRAP_GATE
            || gate_descriptor.type == TASK_GATE)
    {
        /* pass */
    }else{
        /* 失败: 产生#GP异常 */
    }
}

if (gate_descriptor.S == 1)
{
    /* 失败: 产生#GP异常 */
}

if (gate_descriptor.P == 0)
{
    /* 失败: 产生#NP异常 */
}
```

处理器检查下面几个方面

① 在**legacy保护模式**下, **描述符类型**是否为**Interrupt\-gate**, **Trap\-gate**或**Task\-gate**

② 在**IA\-32e模式**下, **描述符类型**是否为**64位的Interrupt\-gate**, **Trap\-gate**

③ 描述符的**S标志位需为0**, 是**System descriptor**, 否则产生\#GP异常

④ 描述符**P标志位**需为1, 是present, 否则产生\#NP异常

实际情况更复杂, 在**legacy保护模式**下, **Interrupt\-gate和Trap\-gate分别为32位和16位**; 而**IA\-32e模式**下, Interrupt\-gate和Trap\-gate**固定是64位**.

## 1.3 目标代码段selector的检查

处理器将从gate描述符中读取**selector**, 处理器会对这个selector检查

```c
selector = gate_descriptor.selector;            /* 读取gate描述符的selector */

/* 下面检查是否属于NULL selector
if (selector == 0 || selector == 1 || selector == 2 || selector == 3)
{
    /* 失败: 产生#GP异常 */
}

/* 检查selector是否超限 */
if (selector.TI == 0)
{
    limit = GDTR.limit;     /* GDT */
}else{
    limit = LDTR.limit
}

if (IA32_EFER.LMA == 0)
{
    if (limit >= (selector & 0xFFF8) + 7)
    {
        /* 通过 */
    }else{
        /* 失败: 产生#GP异常
    }
    
}
```

检查两个方面.

① 是否为Null selector

② **selector**是否超过**descriptor table**的**limit**

当selector值为0, 1, 2或3时, 这个selector属于Null selector, 处理器将\#GP异常

selector的**TI标志**决定**code segment descriptor**在**GDT还是LDT**内,这个描述符表的limit必须大于等于:

>selector & 0xFFF8 + 7, 也就是(selector>>3) \* 8 +7

无论是**legacy模式还是在IA\-32e的64位模式**下, **code segment descriptor**依然是**8个字节宽**. 而**64位模式**下处理器**不会检测CS selector是否超出limit**.

## 1.4 目标代码段描述符的检查

处理器使用**selector**在**GDT/LDT**里读取**目标代码段描述符**.目标代码段描述符的检查如下

```c
if (code_descriptor.C_D == 0        /* 属于Data段 */
        || code_descriptor.S == 0)  /* 属于System段 */
{
    /* 失败, 产生#GP异常 */
}

if (code_descriptor.P == 0)
{
    /* 失败, 产生#NP异常 */
}

if (IA32_EFER.LMA == 1)
{
    if (code_descriptor.L == 1 && code_descriptor.D == 0)
    {
        /* 通过: L = 1, D = 0 */
    }else{
        /* 失败: 不是64位代码, 产生#GP异常 */
    }
}
```

处理器检查:

① 目标**描述符类型**是否为**Code segment descriptor**, 否则将产生\#GP异常

② 描述符的S标志是否为1, 否则产生\#GP异常. **S为0**表明是**系统段描述符**, **S为1**表明是**代码或数据段描述符**

③ 描述符的P标志是否为1, 否则产生\#NP异常

④ 在**IA\-32e模式**下**目标代码**必须是**64位代码**, Code segment descriptor的**L标志位为1**并且**D标志位为0**(指示**中断/异常处理程序运行在64位模式！！！**)

由于在**IA\-32e模式**下, **中断/异常处理程序**是运行在**64位模式**下, 因此**目标代码段描述符**的**L=1并且D=0**.

而**legacy保护模式**下, **目标代码**可以是**32位或16位**的代码, 具体**取决于D标志位(！！！**).

# 2 权限的检查

如下:

```c
if (IA32_EFER.LMA == 1)     /* IA-32e模式下 */
{
    if ((opcode == 0xCE) && (CS.L == 1))
    {
        /* 失败: 在64位模式下不支持INTO指令, 产生#UD异常 */
    }
}

if (opcode == 0xCD || opcode == 0xCC || opcode == 0xCE)
{
    /* 属于INT, INT3或者INT0指令, 则需要权限检查 */
    if ((CPL <= gate_descriptor.DPL) && (CPL >= code_descriptor.DPL))
    {
        /* 通过 */
    }else{
        /* 失败, 产生#GP异常 */
    }
}
```

然而处理器**只会对使用下面的指令(！！！**)调用**中断/异常处理程序**时进行**权限检查**.

① **INT指令**: 提供一个vector, 由**int指令**(**opcode码为0xCD**)**主动**发起调用中断处理程序

② **INT3**指令: 这是**断点异常指令**(opcode码为**0xCC**), 由这条指令**调用\#BP异常处理程序**

③ **INTO**指令: 这是**溢出异常调用指令**(opcode码为**0xCE**), 由这条指令**调用\#OF异常处理程序**

上面由**软件调用**的中断/异常, 处理器**才会进行权限检查**, 让软件对重要**代码及数据**进行**受限制的访问**

下面的中断/异常处理程序调用情形里, **处理器不会权限检查**

① 处理器接收到**硬件中断请求**(例如: 由INTR和NMI pin接收的中断或APIC产生的中断)而调用中断处理程序

② **软件发生异常(非指令主动触发！！！**)而调用相应的异常处理程序

```x86asm
mov eax, [eax]  ; 产生#PF异常, 忽略权限检查
int 14          ; 直接调用14号 #PF 处理程序, 处理器将进行权限检查
```

如上面代码, 同样是对#PF异常处理程序调用, 使用**INT指令直接调用**, 处理器会进行**权限检查**

>另一个不同之处, 使用**int指令**调用异常处理程序, 处理器**不会压入error code**

这个权限检查中, 所需要的权限必须如下.

① CPL <= gate描述符的DPL

② CPL >= 目标code段描述符的DPL

这里说明了**中断/异常处理程序**运行在**高权限级别**里, **不同于call\-gate的调用**, 中断调用不适用selector, 因此没有RPL需要检查.

# 3 权限处理的三种情形

在调用中断或异常的处理程序时, 会遇到三种全兴情形需要处理

```c
if (code_descriptor.C == 0)         /* non-conforming代码段 */
{
    if (CPL == code_descriptor.DPL)
    {
        /* 同级调用: 代码段, 权限和stack都不改变 */
    }else if (CPL > code_descriptor.DPL){
        /* 代码段, 权限和stack都会切换 */
    }else{
        /* 失败: 产生#GP异常 */
    }
}else{                              /* conforming 代码段 */
    /* 同级调用: 切换到目标代码段, 权限和stack不改变 */
}
```

三种情形如下.

① 目标代码段是non\-conforming类型, 当CPL的值等于目标Code段的DPL值时, 这是同级调用, 代码段、权限和stack都不改变

② 目标代码段是non\-conforming类型, 当CPL的值大于目标Code段的DPL值时: 将切换到高权限代码, stack也会发生切换

③ 目标代码段是conforming类型, 会发生代码段的切换, 可是权限和stack不会改变

第1种和第3种情形虽然权限和stack都不改变, 但它们是有区别的, conforming类型的段会发生代码的切换(即CS会被刷新, 加载目标代码段描述符)

# 4 第1种情形: 同级调用

# 5 第2种情形: 

# 6 第3种情形: conforming代码段

