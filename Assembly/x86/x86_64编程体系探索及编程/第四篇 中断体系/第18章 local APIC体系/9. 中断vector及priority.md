- 1 local interrupt的vector设置
- 2 有效的vector值
    - 2.1 使用0～15时
    - 2.2 使用16～31时
- 3 local interrupt的优先级
    - 3.1 TPR（Task Priority Register）
    - 3.2 处理器当前的优先级
- 4 在64位模式下的优先级

LVT寄存器和ICR的vector域提供local interrupt的vector值，这个vector的使用将和保护模式下中断/异常处理的vector一致，从IDT里读取interrupt描述符。

# 1 local interrupt的vector设置

在LVT寄存器和ICR里vector域的设置依赖于它们的delivery mode。

① Fixed模式：允许在vector里提供自定义的vector值。

② NMI模式：vector值被忽略，processor将使用固定的2号NMI vector值。

③ SMI模式：vector值必须设置为0值。

④ ExtINT模式：使用在LVT寄存器里，ICR不支持。使用ExtINT模式，processor将接收由外部中断控制器（如8259中断控制器）经data bus发送过来的vector值。

⑤ INIT模式：vector值必须设置为0值。

⑥ Lowest priority模式和Start-Up模式：使用在ICR里，允许在vector提供自定义的vector值。

# 2 有效的vector值

在前面所述的需要提供vector值时，不应该使用x86/x64体系中预定义（或保留）的0～31号作为vector，正常的中断向量号应该使用32～255（用户自定义的vector）。

## 2.1 使用0～15时

vector设置为0～15，它是无效的中断向量号，中断不会被响应。local APIC将在ESR（Error Status Register）里记录这个错误。从而引发LVT error中断，在未屏蔽时将执行由LVT error寄存器设置的错误处理程序。

## 2.2 使用16～31时

vector设置为16～31，local APIC不会认为它是无效的。可是当local interrupt使用这个范围内的中断向量号将会和系统所定义中断/异常处理例程产生冲突。引起调用OS中预定义的异常处理例程，导致执行错误的中断处理。

# 3 local interrupt的优先级

在local APIC里，中断的优先级基于中断vector来判定，vector的值越大，优先级越高。将256个中断向量号分为16个priority level（中断优先等级）或称为priority class，基于下面的算法。

```c
priority_level=vector / 16
```

那么，priority将分成0～15的等级，每个等级对应16个中断向量号。

![config](./images/41.png)

等级0对应的vector为0～15，等级1对应的vector为16～31，因此这两个在local APIC中属于无效的priority level（等级0无效，等级1不应该使用）。

那么有效的priority level是2～15，如上图所示，等级2对应于32～47的中断向量号。等级15是最高级，等级2最低。

![config](./images/42.png)

根据前面所述，通常一个中断向量号，可以分为两部分，高4位对应于priority level，低4位是rank或sub-class值。在同一个等级里，rank值高则优先级高。

### 3.1 TPR（Task Priority Register）

local APIC提供了一个TPR（task priority register，任务优先级寄存器），在TPR里设定一个值，允许local APIC只响应优先级高于这个值的中断。

![config](./images/43.png)

如上所示，TPR[7：4]设定一个中断门坎值。假如软件设置TPR[7：4]值为0则local APIC允许响应所有的中断请求；假如TPR[7：4]值为15，则抑制所有的中断。下面是TPR的使用算法。

```c
if （vector[7：4] > TPR[7：4]）  /* 中断请求的优先级是否高于 TPR 的门坎值 */
{
       /* 响应中断请求 */
}
else
{
       /* 低于或等于：中断请求被屏蔽 */
}
```

值得注意的是，使用NMI、SMI、INIT、ExtINT，以及Start-Up交付模式的中断不受TPR的影响。

### 3.2 处理器当前的优先级

然而，一个中断请求能得到响应，并不是只依据TPR[7：4]的值，还需要依赖于ISR（In-Service Register），在TPR和ISR的互相作用下产生“处理器当前的优先级”。

```c
if （TPR[7：4] >= MSB_OF（ISR）） /* TPR[7：4]和ISR记录的最高中断服务例程vector[7：4]进行
比较 */
{
   PPR[7：0]=TPR[7：0]；
}
else
{
   PPR[7：4]=MSB_OF（ISR） & 0xf0； /* PPR 的 [7：4] 位 */
   PPR[3：0]=0；       /* 低 4位为 0 */
}
```

在TPR[7：4]和ISR记录的正在服务的最高中断优先级服务例程的vector[7：4]间进行比较，两者中的最高值就是“处理器当前的优先级”，它记录在只读的PPR（Processor Priority Register，处理器优先级寄存器）里。

![config](./images/44.png)

PPR和TPR这两个寄存器的结构和意义是一样的。当ISR的值为0时PPR的值就等于TPR的值。中断请求的优先级只有高于PPR[7：4]才可能被响应。

![config](./images/45.png)

从上面的运行结果我们可以看到，当设TPR的值为0x32时（PPR也为0x32），0x33号中断请求记录在IRR里（第0x33位置位），但被抑制没有响应。

# 4 在64位模式下的优先级

在x64体系里，提供了CR8寄存器作为TPR（Task Priority Register）的编程接口，CR8寄存器仅在64位模式下有效：

![config](./images/46.png)

访问CR8寄存器需要0级的权限，CR8寄存器仅使用低4位（bit 3～bit 0），这个值是前面所述的16个priority level（优先等级）。

```c
void write_cr8（int priority_level）
{
       cr8=priority_level & 0x0f；  /* 写 CR8 寄存器 */
       TPR[7：4]=cr8[3：0]；    /* 更新 TPR */
       TPR[3：0]=0；
}
int read_cr8（）
{
       cr8[3：0]=TPR[7：4]；    /* 从 TPR里读 */
       return cr8；
}
```
CR8寄存器的作用是和TPR一致的。从上面的式子我们可以看到：