- 3.2　CNU　as汇编
    
    - 3.2.1　编译as汇编语言程序

    - 3.2.2　as汇编语法

    - 3.2.3　指令语句、操作数和寻址

    - 3.2.4　区与重定位

    - 3.2.5　符号

    - 3.2.6　as汇编命令

    - 3.2.7　编写16位代码

    - 3.2.8　AS汇编器命令行选项
    
内核中其余所有汇编语言程序（包括C产生的汇编程序）均使用gas来编译，并与C语言程序编译产生的模块链接。本文以80x86 CPU硬件平台为基础介绍Linux内核中使用汇编程序语法和GNU as汇编器（as汇编器）的使用。

汇编有很高的速度和效率。Linux中，它的32位初始化代码、所有中断和异常处理过程接口程序以及很多宏定义都使用as汇编或扩展的嵌入汇编。

在编译C语言程序时，GNU gcc编译器会首先输出一个作为中间结果的**as汇编语言文件**，然后gcc会调用as汇编器把这个临时汇编语言程序编译成**目标文件**。即实际上**as汇编器**最初是专门用于**汇编gcc产生的中间汇编语言程序**，并非作为一个独立的汇编器使用。因此，as汇编器也支持很多C语言特性。

GNU as的汇编器所属的rpm包：**binutils-XXX**。

## 1. 编译as汇编语言程序

gas、gld 的名称已经过时，现在GNU assembler的名称是 as

编译命令格式如下：

```
as [] [-o objfile] [srcfile.s ...]
```

其中，objfile时as编译输出的目标文件名；srcfile.s时as的输入汇编语言程序名。

默认输出目标文件时a.out。

as的输出文件是输入的汇编语言程序编译生成的二进制数据文件，即目标文件。目标文件主要用于作为链接器ld的输入文件。目标文件中包含已汇编过的程序代码、协助ld产生可执行程序的信息，可能还包括调试符号信息。

假设要单独编译/boot/head.s汇编程序，可以如下：

![编译汇编](images/5.png)

## 2. as汇编语法

为维持与gcc输出汇编程序的兼容性，as汇编器使用At&T系统V的汇编语法。与Intel很不一样，主要区别如下：

- AT&T 语法中立即操作数前面要加字符“$； 寄存器操作数名前加“%”； 绝对跳转/调用（相对于程序计数器有关的跳转/调用）操作数前加“*”。Intel汇编语法没这些限制。

- 两个源和目的操作数次序刚好相反。AT&T的源和目的操作数是从左到右“源, 目的”。例如Intel语句 add eax, 4对应AT&T的addl $4, %eax。

- AT&T语法中内存操作数的长度（宽度）由操作码最后一个字符来确定。操作码后缀b、w和l分别指示内存引用宽度为8位字节（byte）、16位字（word）和32位长字（long）。Intel通过在内存操作数前使用前缀byte ptr、word ptr和dword ptr来达到相同目的。因此，Intel中mov al, byte ptr foo对应于AT&T的movb $foo, %al。

- AT&T语法中立即形式的远跳转和远调用位ljmp/lcall $section, $offset, 而Intel的是jmp/call far section:offset。同样，AT&T语法中远返回指令lret $stack-adjust。

- AT&T汇编器不提供对多代码段程序的支持，UNIX类OS要求所有代码在一个段中。

### 2.1 汇编程序预处理

as汇编器具有对汇编语言程序内置的简单预处理功能。

- 该预处理功能会调整并删除多余空格和制表符；

- 删除所有注释语句并使用单个空格或一些换行符替换它们；
 
- 把字符常数换成对应的数值。

但预处理不会对宏定义进行处理，也没有处理包含文件的功能。如果需要该功能，那么让程序使用大写后缀“.S”，让as使用gcc的CPP预处理功能。

as汇编语言除了C语言注释语句（即“/\*···\*/”），还使用“#”作为单行注释开始字符。所以需要预处理。

### 2.2 符号、语句和常数

符号（Symbol）是由字符组成的标识符。字符集、数字和3字符“-”、“.”、“$”。符号不允许用数字字符开始。

语句（Statement）以换行符或行分割字符“;”作为结束。若在一行最后使用反斜杠字符“\”，可以一条语句多行。

语句由零个或多个标号（Label）开始，后面可以更一个确定语句类型的关键符号。标号由符号后面跟随一个冒号（“:”）构成。关键符号确定了语句余下部分的语义。如果该关键符号以一个“.”开始，那么当前语句就是一个汇编命令（或称为伪指令、指示符）。如果关键符号以一个字母开始，当前语句就是一条汇编语言指令语句。

一条语句通用格式：

```
标号: 汇编命令  注释部分（可选）
或
标号: 指令助记符  操作数1, 操作数2        注释部分（可选）
```

常数是一个数字，分为字符常数和数字常数两类。字符常数还分位字符串和单个字符；数字常数可分为整数、大数和浮点数。

字符串必须用双引号括住，并且可以使用反斜杠“\”转义。

单个字符常数可以写成在该字符前面加一个单引号，例如“A”表示值65。转义码也可以用于单个字符常数，例如“\\\\”表示反斜杠字符常数。

整数常数4种表示方法，0b或0B开始的二进制数（0 ~ 1）、0开始的八进制（0 ~ 7）、非0开始的十进制和使用0x或0X开头的十六进制。

大数（Bignum）是位数超过32位二进制位数。内核代码中几乎不用浮点数。

## 3. 指令语句、操作数和寻址

指令（Instructions）是CPU执行的操作，通常也称为操作码（Opcode）。操作数（Operand）是指令操作的对象。而地址（Address）是指定数据在内存中的位置。指令语句是程序运行时刻执行的一条语句，它通常四部分：

- 标号（可选）

- 操作码（指令助记符）

- 操作数（由具体指令指定）

- 注释
 
对于两个操作数的指令语句，第1个是源操作数，第2个是目的操作数，即指令操作结果存在第二个操作数中。

操作数可以是立即数（即值是常数值得表达式）、寄存器（值在CPU的寄存器中）或内存中（值在内存中）。间接操作数（Indirect Operand）含有实际操作数值的地址值。AT&T语法通过在操作数前加一个“*”字符来指定一个间接操作数。只有调转/调用指令才能使用间接操作数。

### 3.1 指令操作码的命名

AT&T语法中操作数的长度（宽度）由操作码最后一个字符来确定。如果没有带字符后缀，并且指令语句中不含内存操作数，那as会根据**目的寄存器操作数**来尝试确定操作数宽度。例如，“mov %ax, %bx”等价于“movw %ax, %bx”。“mov $1, %bx”等价于“movw $1, %bx”。

AT&T与Intel语法几乎指令操作码相同，但有例外。符号扩展和零扩展指令都需要2个宽度来指明，即需要为源和目的操作数指明宽度，AT&T语法中通过使用两个操作码后缀来做到。AT&T语法中符号扩展和零扩展的基本操作码名称分别为movs...和movz...，Intel中分别是movsx和movzx。例如，“使用符号扩展从%al移动到%edx”的AT&T语句是“movsbl %al, %edx”，即从byte到long是bl，从byte到word是bw、从word到long是wl。AT&T语法与Intel语法中转换指令的对应关系如图3-2。

![3-2 AT&T语法与Intel语法中转换指令的对应关系](images/1.png)

### 3.2 指令操作码前缀



### 3.3 内存引用



### 3.4 跳转指令

## 6. as汇编命令

汇编指令是指示汇编器操作方式的伪指令。汇编指令用于要求汇编器为变量分配空间、确定程序开始地址、指定当前汇编的区、修改位置计数器值等。所有汇编指令的名称都以“.”开始，其余是字符，并且**大小写无关**。下面常用汇编命令的说明。

- .align abs-expr1, abs-expr2, abs-expr3

存储对齐汇编命令。用于在当前子区中把位置计数器值设置（增加）到下一个指定存储边界处。

abs-expr1指定要求的边界对齐值。对于使用a.out格式目标文件的80x86系统，表示位置计数器值后其二进制值最右面0值的个数，即2的幂值。例如，“.align 3”表示把位置计数器增加到8的倍数上。对于ELF格式的80x86系统，该表达式值直接就是要对齐的字节数。例如，“.align 8”表示把位置计数器增加到8的倍数上。

abs-expr2表示用于对齐而填充的字节值。默认是0。

abs-expr3表示用于指示对其操作允许填充跳过的最大字节数。若对齐操作要求跳过的字节数大于这个最大值，那么对齐操作就被取消。若想省略第二个参数，可以在第1和第3个参数之间使用两个逗号。

- .ascii "string"

从位置计数器所指当前位置为字符串分配空间并存储字符串，可使用逗号分开写出多个。例如，“ascii "hello world!", "My assembler"”。该汇编命令会让as把这些字符串汇编在连续的地址位置处，每个字符串后面不会自动添加0（NULL）。

- .asciz "string"
- .byte expressions
- .comm symbol, length
- .data subsection
- .desc symbol, abs-expr
- .fill repeat, size, value
- .global symbol（或.globl symbol）

会使得链接器ld能看见符号symbol。如果在我们的目标文件中定义了符号symbol，那么它的值将能被链接过程中的其他目标文件使用。

- .int expressions
- .lcomm symbol, length
- .long expressions
- .octa bignums
- .org new_lc, fill
- .quad bignums

指定0个或多个用逗号分开的8B大数bignum。如果大数放不进8B中，则取低8B。

- .short expressions(同.word expressions)

指定某个区中0个或多个用逗号分开的2字节数。对于每个表达式，在运行时会产生一个16位值。

- .space size, fill

产生size个字节，每个字节填值fill。如果省略了逗号和fill，fill默认是0

- .string "string"

定义一个或多个用逗号分隔的字符串。在字符串中可以使用转义字符。每个字符串都自动附加一个NULL字符结尾。

- .text subsection

通知as将随后的语句汇编进编号位subsection的子区中。如果省略了编号subsection，则默认使用编号0。

- .word expressions

对于32位机器

## 7. 编写16位代码

在运行于16位模式的指令语句之前添加汇编命令“.code16”

## 8. AS汇编器命令行选项

- -a：开启程序列表

- -f：快速操作

- -o：指定输出的目标文件名

- -R：组合数据区和代码区

- -W：取消警告信息