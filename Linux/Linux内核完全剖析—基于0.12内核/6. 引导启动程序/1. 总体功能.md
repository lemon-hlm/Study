主要在boot/目录下的汇编文件。bootsect.S和setup.S是实模式下的16位程序，Intel汇编语法，使用Intel 8086汇编编译器和连接器as86和ld86；head.s是GNU汇编，运行在保护模式下，使用GNU的as（gas）编译，这是AT&T语法。

因为当时GNU as仅支持i386以及后的CPU代码指令，不支持实模式16位代码。2.4.x起，bootsect.S和setup.S才完全使用统一的as编写。

先说明Linux系统启动部分的主要执行流程。主机上电，80x86的CPU进入实模式，并从地址0xFFF0开始自动执行程序代码，这儿通常是ROM-BIOS的地址。BIOS进行POST，并在物理地址0处开始初始化中断向量（CPU实模式的要求）。此后，它将启动设备的第一个扇区（磁盘引导扇区，512字节）读入内存绝对地址0x7c00，并跳转到这儿。

Linux最前面部分是用汇编写的（boot/bootsect.S），它将由BIOS读入内存绝对地址0x7c00（31KB）处。

当它执行时就会把自己移动到内存绝对地址0x90000（576KB）处，并把启动设备盘中后2KB代码（boot/setup.S）读入到内存0x90200处，而内核其他部分（system模块）则被读入到从内存地址0x10000（64KB）开始处，因此从机器加电开始顺序执行程序如下。

![config](images/1.png)

system模块不会超过0x80000字节（512KB），所以bootsect将system模块读入到物理地址0x10000开始位置并不会覆盖在0x9000（576KB）处开始的bootsect和setup模块。后面setup会将system模块移动到物理内存起始位置处，这样system模块中代码的地址也即等于实际物理地址，以便对内核代码和数据进行操作。图6-2显示了Linux启动时这几个程序或模块在内存中的动态位置。

![config](images/2.png)

启动部分识别主机的某些特性以及VGA卡的类型。需要的话，它会要求用户为控制台选择显示模式。然后将系统从0x10000移动到0x0000处，进入保护模式并跳转到系统部分（0x0000处）。此时32位运行的设置也完成了：IDT、GDT以及LDT被加载，处理器和协处理器也已确认，分页工作也设置好了；最终调用init/main.c的main()。上述操作在boot/head.s中，这个可能是整个内核中最有诀窍的代码了。

bootsect不把系统模块直接加载到物理地址0x0000开始处因为随后的setup开始部分还需要利用ROM BIOS的中断调用功能获取一些参数（例如显卡模式、硬盘参数表等）。

仅在内存中加载了上述内核代码模块并不能让Linux运行起来。还需要一个基本的文件系统支持，即根文件系统（Root file-system）。这通常在另一个硬盘分区中。为通知内核所需的根文件系统在什么地方，bootsect.S44行给出了根文件系统所在的默认块设备号ROOT\_DEV。内核初始化时会使用编译内核时放在引导扇区第509、510（0x1fc\~0x1fd）字节中的指定设备号。bootsect.S45行给出了交换设备号SWAP\_DEV，它指出用作虚拟存储交换空间的外部设备号。