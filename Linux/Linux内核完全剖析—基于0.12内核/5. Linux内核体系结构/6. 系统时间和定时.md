## 1. 系统时间

PC/AT系统中提供了**用电池供电的实时钟（Real Time，RT）电路支持**。通常，**这部分电路与保存系统信息的CMOS RAM集成在一个芯片上，因此这部分电路被称为RT/CMOS RAM电路**。PC/AT微机或其兼容机使用了Motorala的MC146818芯片。

初始化时，Linux 0.12通过init/main.c的time\_init()函数读取这块芯片中保存的当前时间和日期信息，并通过kernel/mktime.c中的kernel\_mktime()函数转换成从1970年1月1日午夜0时开始到当前的以秒为单位的时间，称为UNIX日历时间。该时间确定了系统开始运行的日历时间，被保存在全局变量startup\_time中供内核所有代码使用。用户程序可以通过系统调用time()来读取startup\_time的值，而超级用户可以通过系统调用stime()来修改这个系统时间值。

另外，再通过下面介绍的从系统启动开始计数的系统滴答值jiffies，程序就可以唯一地确定运行时刻的当前时间值。由于每个滴答定时值是10ms，因此内核代码定义了一个宏来方便代码对当前时间的访问。这个宏定义在include/linux/sched.h文件在192行，形式如下：

```
#define CURRENT_TIME (startup_time + jiffies/HZ)
```

其中，HZ=100，是内核系统时钟频率。当前时间宏CURRENT\_TIME被定义为系统开机时间startup_time加上开机后系统运行的时间jiffies/100。在修改一个文件的被访问时间或其i节点的被修改时间时均使用了这个宏。

## 2. 系统定时

在Linux 0.12内核初始化过程中，**PC的可编程定时芯片Intel 8253（8254）的计数器通道0被设置为运行在方式3下**（方波发生器方式），并且初始计数值LATCH被设置为每隔10ms在通道0输出端OUT发一个方波上升沿。由于8254芯片的时钟输入频率时1.193180MHZ，因此初始计数值LATCH=1193180/100，约为11931。**由于OUT引脚被连接到PIC的0级上(也就是说连接在中断控制器上)**，因此每隔10ms会发出一个时钟中断请求（IRQ0）信号。这个时间节拍就是操作系统运行的脉搏，称为1个系统滴答或一个系统时钟周期。因此，每隔1个滴答时间，系统就会调用一次时钟中断处理程序。

时钟中断处理程序timer\_interrupt主要用来通过jiffies变量来累计自系统启动以来经过的时钟滴答数。一次时钟中断jiffies就加1。然后调用C函数do\_timer()进一步处理。调用时的参数CPL是从被中断程序的段选择符（保存在堆栈中的CS段寄存器值）中取得当前代码特权级CPL。

do\_timer()函数则根据特权级对当前进程运行时间作累计。若CPL=0，表示进程运行在内核态时被中断，因此内核就会把进程的内核态运行时间统计数stime加1，否则把进程用户态运行时间统计数加1。

如果软盘处理程序floppy.c在操作过程中添加定时器，则对定时器链表进行处理。若某个定时器时间到（递减后等于0），则调用该定时器的处理函数。然后对当前进程运行时间进行处理，把当前进程运行时间减1。时间片是一个进程在被切换掉之前所能持续运行的CPU时间，其单位是上面定义的滴答数。如果时间片值递减后还大于0，表示其时间片还没用完，于是退出do\_timer()继续运行当前进程。若此时进程时间片已经递减为0，表示进程用完了此次时间片，于是程序就会根据被中断程序的级别来确定进一步处理的方法。若被中断的当前进程是工作在用户态的（特权级别大于0），则do\_timer()就会调用调度程序schedule()切换到其他进程去运行。内核态，即在内核程序中运行时被中断，则do\_timer()会立即退出。因此这样的处理方式决定了Linux系统的进程在内核态运行时不会被调度程序切换。即进程在内核态程序中运行时是不可抢占的（nonpreemptive），但当处于用户态程序中运行时则是可以被抢占的（preemptive）。

