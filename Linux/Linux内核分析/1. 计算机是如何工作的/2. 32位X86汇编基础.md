
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1. X86 CPU的寄存器](#1-x86-cpu的寄存器)
* [2. X86汇编指令](#2-x86汇编指令)
* [3. 练习](#3-练习)
* [4. 参考资料](#4-参考资料)

<!-- /code_chunk_output -->

## 1. X86 CPU的寄存器

一个32位**通用寄存**器如下所示：

![32位通用寄存器](images/4.png)

- 8, 16, and 32 bit versions：低八位作为8位寄存器，低16位作为16位寄存器。16位寄存器叫AX、BP等，32叫EAX、EBP等，我们关注32位
- By convention some registers for special purposes
- Example: ADD EAX, 10
- Other instructions: SUB, AND, etc.

通用寄存器还有一些是段寄存器：

- CS——代码段寄存器(Code Segment Register)，其值为
代码段的段值；
- DS——数据段寄存器(Data Segment Register)，其值为
数据段的段值；
- ES——附加段寄存器(Extra Segment Register)，其值为
附加数据段的段值；
- SS——堆栈段寄存器(Stack Segment Register)，其值为
堆栈段的段值；
- FS——附加段寄存器(Extra Segment Register)，其值为
附加数据段的段值；
- GS——附加段寄存器(Extra Segment Register)，其值为
附加数据段的段值。

其中CS和SS使用最多。指令是存储在CS的，CPU在实际取指令时根据CS:EIP来准确定位一个指令；每个进程有自己的堆栈。

**标志寄存器**

![标志寄存器](images/5.png)

X86_64寄存器与32位寄存器在核心机制上差别不大。

![64位寄存器](images/6.png)

- **通用寄存器**扩展为64位，以R开头
- 增加了一些64位Media和浮点寄存器
- **标志寄存器**EFLAGS叫RFLAGS
- **指令寄存器**EIP叫RIP
- 增加了128位Media寄存器

## 2. X86汇编指令

![mov指令](images/7.png)

- Memory instructions: MOV, PUSH, POP, etc
- Most instructions can take a memory address. 多数指令能够直接读取一个内存地址。
- b,w,l,q分别代表8位，16位,32位和64位

寄存器对内存的操作方法

- **寄存器模式寻址**。%开头的表示是寄存器标识符。movl %eax, %edx(edx=eax)表示将寄存器eax的内容放到edx中。操作寄存器，不与内存打交道。
- **立即寻址**。movl $0x123, %edx(edx=0x123)，$表示一个立即数。将数值0x123放到寄存器edx中。和内存没有关系。
- **直接寻址**。直接访问一个指定的内存地址的数据。movl 0x123, %edx（edx=\*(int32_t\*)0x123），没有$符号表示一个地址。将地址0x123的内容放到寄存器edx中。
- **间接寻址**。movl (%ebx), %edx（edx=\*(int32_t\*)ebx）。(%ebx)是两部分：%寄存器ebx是取内容，括号表示该内容（是一个内存地址）对应的值
- **变址寻址(displaced)**。movl 4(%ebx), %edx(edx=\*(int32_t\*)(ebx+4))。在间接寻址之时改变寄存器的数值。
 
AT&T汇编格式与Intel汇编格式略有不同，Linux内核使用的是AT&T汇编格式

还有几个重要的指令

push、pop、call、ret

![其他指令](images/8.png)

- pushl %eax：pushl表示32位，把eax这个寄存器的内容压栈到栈顶。实际上两个动作：[subl $4, %esp]，ebp表示栈底（堆栈由高地址向低地址增长），esp指向栈顶，堆栈向下增长，将esp(栈顶)减4（32位，4字节）；[movl %eax, (%esp)]]

- popl %eax：取栈顶32位的内容放到寄存器eax中。两个动作，[movl (%esp), %eax]，[addl $4, %esp]

- call 0x12345：调用这个地址（比如函数调用），两个动作，[pushl %eip]，将当前的eip压栈；[movl $0x12345, %eip]，将12345十六进制立即数放到寄存器eip中。

- ret：return。相当于popl %eip，将之前保存的eip还原到寄存器eip中继续执行。

上面对eip的操作实际上程序员无法操作，eip寄存器不能被直接修改，只能通过特殊指令间接修改（比如call、ret）；上面(%esp)等操作以及高地址向低生成堆栈说明使用了存储器堆栈，寄存器esp中存放的是内存地址。

## 3. 练习

分析一段汇编代码

```
···
pushl $8
movl %esp,%ebp
subl $4,%esp
movl $8,(%esp)
···
```

pushl $8：将esp（内容是内存地址）减4，然后将立即数8放到栈顶的位置。

movl %esp,%ebp：将esp的内容放到ebp，即ebp和esp指向同一个位置。

subl $4,%esp：将esp减去4（立即数）

movl $8,(%esp)：将8放到esp。

再看一段

```
···
pushl $8
movl %esp, %ebp
pushl $8
···
```

pushl $8：将esp（内容是内存地址）减4，然后将立即数8放到栈顶的位置。

movl %esp,%ebp：将esp的内容放到ebp，即ebp和esp指向同一个位置。

再

```
pushl $8
movl %esp,%ebp
pushl %esp
pushl $8
addl $4,%esp
popl %esp
```

## 4. 参考资料
```
Assembly目录下的《Linux 汇编入门》
//在64位环境下编译成32位的汇编
gcc -S -o ccode32.s ccode.c -m32
//链接时会缺少构建32 位可执行程序缺少的包，使用以下指令安装：
sudo apt-get install libc6-dev-i386
//编译链接成32位的可执行文件
gcc -o ccode32 ccode.c -m32
```