通过反汇编一个简单的C程序，分析汇编代码理解计算机是如何工作的

```
int g(int x)
{
	return x+7;
}

int f(int x)
{
	return g(x);
}

int main(void)
{
	return f(9) + 1;
}
```

编译到汇编语言，-m32 是将main.c编译成一个32位的汇编代码。

```
gcc -S -o main.s main.c -m32
```

汇编代码：

```
	.file	"main.c"
	.text
	.globl	g
	.type	g, @function
g:
.LFB0:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	movl	8(%ebp), %eax
	addl	$7, %eax
	popl	%ebp
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE0:
	.size	g, .-g
	.globl	f
	.type	f, @function
f:
.LFB1:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$4, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	call	g
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE1:
	.size	f, .-f
	.globl	main
	.type	main, @function
main:
.LFB2:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$4, %esp
	movl	$9, (%esp)
	call	f
	addl	$1, %eax
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE2:
	.size	main, .-main
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-4)"
	.section	.note.GNU-stack,"",@progbits
```

其中以点开头的是用于链接时的辅助信息，不会在实际中执行，删除这些以点开头的内容，留下纯汇编代码

```
1 g:      
2         pushl   %ebp
3         movl    %esp, %ebp
4         movl    8(%ebp), %eax 
5         addl    $7, %eax 
6         popl    %ebp
7         ret
8 f:      
9         pushl   %ebp
10         movl    %esp, %ebp
11         subl    $4, %esp
12         movl    8(%ebp), %eax
13         movl    %eax, (%esp)
14         call    g
15         leave   
16         ret
17 main:   
18         pushl   %ebp
19         movl    %esp, %ebp
20         subl    $4, %esp
21         movl    $9, (%esp)
22         call    f
23         addl    $1, %eax
24         leave   
25         ret
```

与代码对比下：

![code comparing](images/1.png)

ebp指向堆栈的栈底，esp指向堆栈的栈顶。函数调用堆栈是由逻辑上多个堆栈叠加起来的，栈底是相对的栈底。当前函数有它自己的堆栈和相对的栈底。跳出当前函数之后另一个函数还有自己的堆栈和栈底。

eax用于暂存一些数据。函数的返回值默认使用eax寄存器存储返回给上一级函数。

执行过程：

为方便，将地址设为标号，初地址为标号0，压一次栈为1，两个标号之间相差4个字节，低标号是高地址，高标号是低地址。起初ebp和esp为0（相对的）。程序是从man函数开始，所以刚开始eip指向main标号的位置，行号为17：

![1](images/2.png)

标号的第一条指令就是18 pushl %ebp，将ebp的值压栈，栈顶位置（esp）移动（减4），指向1的位置（esp里面存的是内存地址，值是1）：

![2](images/3.png)

19 movl %esp,%ebp：将esp赋给ebp（两个寄存器里面都是内存地址，目前这个值是1），ebp也指向了esp现在的位置，栈顶和栈底同一个位置：

![3](images/4.png)

20 subl $4,%esp：esp减去立即数4（寄存器esp中存的是内存地址），即向下移动一个标号（esp值是2）：

![4](images/5.png)

21 movl $7,(%esp)：(%esp)指的是esp寄存器的内容是一个内存地址，该内存地址的值。将立即数7放到该esp（内存地址）指向的内存：

![5](images/6.png)

22 call f：call f相当于pushl %eip，然后movl f,%eip。当执行这个call动作时候，实际上eip指向的是call的下一条指令23行。所以push进栈的是23。esp=3，eip跳转到f：标号的位置第8行：

![6](images/7.png)

9 pushl %ebp：此时ebp=1，将1压栈，esp到下一个位置，esp=4：

![7](images/8.png)

10 movl %esp,%ebp：esp=4，赋值，ebp=4：

![8](images/9.png)

11 subl $4, %esp：esp=4，将esp减去立即数4，esp向下移动，esp=5：

![9](images/10.png)

12 movl 8(%ebp),%eax：ebp变址寻址加8，向上取2个位置，内容是7，eax=7

13 movl %eax,(%esp)：将eax中的值放到寄存器esp内容（地址）所指向的内存：

![10](images/11.png)

14 call g：相当于push %eip，然后movl g,%eip。eip指向的是call下面的一条指令15行，所以压入15。eip跳向g：标号位置的第1行。esp=6：

![11](images/12.png)

2 pushl %ebp：ebp=4，将4压栈，esp=7：

![12](images/13.png)

3 movl %esp, %ebp：esp=7，赋值，ebp=7：

![13](images/14.png)

4 movl 8(%ebp), %eax：ebp变址寻址加8，向上加两个标号的位置，它的内容是7，eax=7

5 addl $4, %eax：把立即数4加到eax，eax=7+4=11，eax=11

6 popl %ebp：把esp里的内容放到ebp里，然后esp向上移动4，即1个标号，esp=6。效果是ebp又指向了原来标号4的位置，ebp=4：

![14](images/15.png)

7 ret：ret就是popl %eip，执行之后eip指向了第15行，即call g的下一行，esp=5：

![15](images/16.png)

15 leave：leave是先movl %ebp,%esp 然后popl %ebp，ebp=4，赋值后esp=4，pop后ebp=1，esp=3：

![16](images/17.png)

16 ret：即popl %eip，esp向上移动一位esp=2，同时eip指向了23，程序跳转到执行第23行，即call f的下一条指令：

![17](images/18.png)

23 addl $2, %eax：eax=11+2=13，eax存储了默认的返回值。

24 leave：先movl %ebp,%esp再popl %ebp：

![18](images/19.png)

这个时候，栈回到了main函数最初的状态。

25  ret：return到了main函数之前的堆栈了，可能再main函数之前还有一个eip，这些由操作系统管理。

整个过程堆栈先是向下增长，然后向上还原，堆栈增增减减，把程序变成了指令流，从cpu上流了一遍。

### 总结

计算机的工作就是cpu就是不断的通过ip从内存当中取出指令，解释并执行的。C语言中的if else、函数调用、return等，对应着汇编当中的conditional JMP、CALL、RET等。通过这些指令来控制程序的流程，ip指针的跳转。函数调用时，会把先前的堆栈（包括信息、状态）保存下来，然后再在其上叠加一个新的堆栈。当被调用的函数执行完后，这个新的堆栈将会弹出，返回到上一层的函数堆栈，还可以得到之前堆栈当中保存的信息、状态。在这个过程当中，eip、ebp、esp、eax等寄存器不断的变化，堆栈不断的增减，整个程序变成指令流，从cpu上流过。

