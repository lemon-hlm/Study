
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 ARM32 内核内存布局图](#1-arm32-内核内存布局图)

<!-- /code_chunk_output -->

问题：

- 在 32bit Linux中，内核空间的线性映射的虚拟地址和物理地址是如何换算的？
- 在 32bit Linux中，**高端内存**的起始地址是如计算出来的？
- 请画出A R M 32 Linux内核的内存布局图。

# 1 ARM32 内核内存布局图

Linux内核在启动时会打印出内核内存空间的布局图，下面是ARM Vexpress平台打印
出来的内存空间布局图：

```
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000  (   4 kB)
    fixmap  : 0xffc00000 - 0xfff00000  (3072 kB)    
    vmalloc : 0xf0000000 - 0xff000000  ( 240 MB)
    lowmem  : 0xc0000000 - 0xef800000  ( 760 MB)
    pkmap   : 0xbfe00000 - 0xc0000000  (   2 MB)
    modules : 0xbf000000 - 0xbfe00000  (  14 MB)
     .text  : 0xc0008000 - 0xc0658750  (6466 kB)
     .init  : 0xc0659000 - 0xc0782000  (1188 kB)
     .data  : 0xc0782000 - 0xc07bl920  ( 191 kB)
     .bss   : 0xc07bl920 - 0xc07db378  ( 167 kB)
```

这部分息的打印是在**mem\_init**()函数中头现的。

```cpp
//[start_kernel->mm_init->mem_init]


```

编译器在**编译**目标文件并且**链接**完成之后，就可以知道**内核映像文件**最终的大小，接下来**打包成二进制文件**，该操作由arch/arm/kernel/vmlinux.ld.S控制，其中也划定了内核的内存布局。

**内核image**本身占据的内存空间**从\_text段到\_end段**，并且分为如下几个段。

- 代码段：\_tex和\_etext为**代码段**的起始和结束地址，包含了编译后的内核代码。
- init段：\_init\_begin和\_init\_end为init段的起始和结束地址，包含了**大部分模块初始化的数据**。
- 数据段：为数据段的起始和结束地址，保存大部分**内核的变量**。
- BSS段：\_bss_start和BSS段的开始和结束地址，包含初始化为0的所有**静态全局变量**。

上述**几个段**的大小在**编译链接**时根据**内核配置**来确定，因为**每种配置的代码段和数据段长度都不相同**，这取决于要编译哪些内核模块，但是**起始地址_text总是相同**的。内核编译完成之后，会生成一个System.map文件，查询这个文件可以找到这些地址的具体数值。

```

```

内核模块使用虚拟地址从MODULES\_VADDR到MODULES\_END的这段14MB大小的内存区域。

```
#define MODULES_VADDR  (PAGE_OFFSET - SZ_16M)
/*
* The highmem pkmap virtual space shares the end of the module area.
*/
#ifdef CONFIG_HIGHMEM
#define MODULES_END  (PAGE_OFFSET - PMD_SIZE)
#else
#define MODULES_END  (PAGE_OFFSET)
#endif
```

