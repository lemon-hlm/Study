本章思考题

1. 在ARM处理器中，如何实现独占访问内存？
2. atomic\_cmpxchg()和 atomic\_xchg()分别表示什么含义？
3. 为什么spinlock的临界区不能睡眠（不考虑RT\-Linux的情况）？
4. Linux内核中经典spinlock的实现有什么缺点？
5. 为什么spinlock临界区不允许发生抢占？
6. Ticket-based的 spinlock机制是如何实现的？
7. 如果在spin\_lock()和spin\_unlock()的临界区中发全了中断，并且中断处理程序也恰巧修改了该临界资源，那么会发生什么后果？该如何避免呢？
8. 与spinlock相比，信号量有哪些特点？
9. 请简述信号量是如何实现的。
10. 什么时候使用读者信号量，什么时候使用写者信号量，由什么来判断？
11. 读写信号量使用的自旋等待机制(optimistic spinning)是如何实现的？
12. Linux内核已经实现了信号量机制，为何要单独设置一个Mutex机制呢？
13. 请简述MCS锁机制的实现原理。
14. 在编写内核代码时，该如何选择信号量和Mutex?
15. RCU相比读写锁有哪些优势？
16. 请解释Quiescent State和Grace Period。
17. 请简述RCU实现的基本原理。
18. 在大型系统中，经典RCU遇到了什么问题？ Tree RCU又是如何解决该问题的？
19. 在RCU实现中，为什么要使用ULONG\_CMP\_GE()和ULONG\_CMP\_LT()宏来比较两个数的大小，而不直接使用大于号或者小于号来比较？
20. 请简述一个Grace Period的生命周期及其状态机的变化。
21. 请总结原子操作、spinlock、信号量、读写信号量、Mutex和RCU等Linux内核常用锁的特点和使用规则。
22. 在KSM中扫描某个VMA寻找有效的匿名页面，假设此VMA恰巧被其他CPU销毁了，会不会有问题呢？
23. 请简述页锁PG locked的常用使用方法。
24. 在mm/rmap.c 文件中的 page\_get\_anon\_vma()函数中，为什么要使用rcu\_read\_lock()? 什么时候注册RCU回调函数呢？
25. 在mm/oom\_kill.c的select\_bad\_process()函数中，为什么要使用rcu\_read\_lock()? 什么时候注册RCU回调函数呢？

