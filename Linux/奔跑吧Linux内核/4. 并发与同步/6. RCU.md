[TOC]

在阅读本节前请思考如下小问题。

- RCU相比读写锁有哪些优势？
- 请解释Quiescent State和Grace Period。
- 请简述RCU实现的基本原理。
- 在大型系统中，经典RCU遇到了什么问题？ Tree RCU又是如何解决该问题的？
- 在RCU实现中，为什么要使用ULONG\_CMP\_GE()和ULONG\_CMP\_LT()宏来比较两个数的大小，而不直接使用大于号或者小于号来比较？
- 请简述一个Grace Period的生命周期及其状态机的变化。

RCU全称**read\-copy\-update**，是 Linux内核中一种重要的**同步机制**。

Linux内核中己经有
了**原子操作**、**spinlock**、**读写spinlock**、**读写信号量**、**mutex**等锁机制，为什么要单独设计一个比它们实现要复杂得多的新机制呢？

回忆**spinlock**、**读写信号量**和**mutex**的实现，它们都使用了**原子操作指令**，即**原子地访问内存**，**多CPU**争用**共享的变量**会让**cache—致性变得很糟(！！！**)，使得**性能下降**。

以**读写信号量**为例，除了**上述缺点**外，读写信号量还有一个**致命弱点**，它**只允许多个读者同时存在**，但是**读者和写者不能同时存在(！！！**)。那么**RCU机制要实现的目标**是，希望**读者线程没有同步开销**，或者说**同步开销变得很小**，甚至可以忽略不计，不需要额外的锁，不需要使用原子操作指令和内存屏障，即可畅通无阻地访问；而把需要同步的任务交给写者线程，写者线程等待所有读者线程完成后才会把旧数据销毁。在RCU中，如果有多个写者同时存在，那么需要额外的保护机制。RCU机制的原理可以概括为RCU记录了所有指向共享数据的指针的使用者，当要修改该共享数据时，首先创建一个副本，在副本中修改。所有读访问线程都离开读临界区之后，指针指向新的修改后副本的指针，并且删除旧数据。

RCU的一个重要的应用场景是链表，有效地提高遍历读取数据的效率。读取链表成员数据时通常只需要rcu\_read\_lock(),允许多个线程同时读取该链表，并且允许一个线程同时修改链表。那为什么这个过程能保证链表访问的正确性呢？

在读者遍历链表时，假设另外一个线程删除了一个节点。删除线程会把这个节点从链表中移出，但不会直接销毁它。RCU会等到所有读线程读取完成后，才会销毁这个节点。

