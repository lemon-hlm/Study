第1章  ARM体系结构

第2章 内存管理

本章思考题

- 2.1 物理内存初始化

    - 2.1.1 内存管理概述

    - 2.1.2 内存大小

    - 2.1.3 物理内存映射

    - 2.1.4 zone初始化

    - 2.1.5 空间划分

    - 2.1.6物理内存初始化

- 2.2 页表的映射过程

    - 2.2.1 ARM32页表映射

    - 2.2.2 ARM64页表映射

- 2.3 内核内存的布局图

    - 2.3.1 ARM32内核内存布局图

    - 2.3.2 ARM64内核内存布局图

- 2.4 分配物理页面

    - 2.4.1 伙伴系统分配内存

    - 2.4.2 释放页面

    - 2.4.3 小结

- 2.5 slab分配器

    - 2.5.1 创建slab描述符

    - 2.5.2 分配slab对象

    - 2.5.3 释放slab缓冲对象

    - 2.5.4kmalloc分配函数

    - 2.5.5 小结

- 2.6 vmalloc

- 2.7 VMA操作

    - 2.7.1 查找VMA

    - 2.7.2 插入VMA

    - 2.7.3 合并VMA

    - 2.7.4 红黑树例子

    - 2.7.5 小结

- 2.8 malloc

    - 2.8.1 brk实现

    - 2.8.2 VM_LOCK情况

    - 2.8.4 小结

- 2.9 mmap

    - 2.9.1 mmap概述

    - 2.9.2 mmap小节

- 2.10 缺页中断处理

    - 2.10.1 do\_page\_fault()

    - 2.10.2 匿名页面缺页中断

    - 2.10.3 文件映射缺页中断

    - 2.10.4 写时复制

    - 2.10.5小结

- 2.11 page引用计数

    - 2.11.1 struct page数据结构

    - 2.11.2 \_count和\_mapcount的区别

    - 2.11.3 页面锁PG\_Locked

    - 2.11.4 小结

- 2.12 反向映射RMAP

    - 2.12.1 父进程分配匿名页面

    - 2.12.2 父进程创建子进程

    - 2.12.3 子进程发生COW

    - 2.12.4 RMAP应用

    - 2.12.5 小结

- 2.13 回收页面

    - 2.13.1 LRU链表

    - 2.13.2 kswapd内核线程

    - 2.13.3 balance\_pgdat函数

    - 2.13.4 shrink\_zone函数

    - 2.13.5 shrink\_active\_list函数

    - 2.13.6 shrink\_inactive\_list函数

    - 2.13.7 跟踪LRU活动情况

    - 2.13.8 Refault Distance算法

    - 2.13.9 小结

- 2.14 匿名页面生命周期

    - 2.14.1 匿名页面的诞生

    - 2.14.2 匿名页面的使用

    - 2.14.3 匿名页面的换出

    - 2.14.4 匿名页面的换入

    - 2.14.5 匿名页面销毁

- 2.15 页面迁移

    - 2.15.1 migrate\_pages()函数

    - 2.15.2 页迁移的应用

- 2.16 内存规整（memory compaction）

    - 2.16.1 内存规整实现

    - 2.16.2 小结

- 2.17 KSM

    - 2.17.1 KSM实现

    - 2.17.2 匿名页面和KSM页面的区别

    - 2.17.3 小结

2.18 2016年最火的内存漏

- 2.19 内存管理数据结构和API

    - 2.19.1 内存管理数据结构的关系图

    - 2.19.2 内存管理中常用API

- 2.20 最新更新和展望

    - 2.20.1 页面回收策略从zone迁移到node

    - 2.20.2 OOMKiller改进

    - 2.20.3 swap优化

    - 2.20.4 展望

第3章 进程管理

本章思考题

- 3.1 进程的诞生

    - 3.1.1 init进程

    - 3.1.2 fork

    - 3.1.3 小结

- 3.2 CFS调度器

    - 3.2.1 权重计算

    - 3.2.2 进程创建

    - 3.2.3 进程调度

    - 3.2.4 scheduler tick

    - 3.2.5 组调度

    - 3.2.6 PELT算法改进

    - 3.2.7 小结

- 3.3 SMP负载均衡

    - 3.3.1 CPU域初始化

    - 3.3.2 SMP负载均衡

    - 3.3.3 唤醒进程

    - 3.3.4 调试

    - 3.3.5 小结

- 3.4 HMP调度器

    - 3.4.1 初始化

    - 3.4.1 HMP负载调度

    - 3.4.3 新创建的进程

    - 3.4.4 小结

- 3.5 NUMA调度器

    - 3.5.1 node和page的关系

    - 3.5.2 扫描进程

    - 3.5.3 NUMA缺页中断

    - 3.5.4 进程迁移

    - 3.5.3 总结

- 3.6 EAS绿色节能调度器

    - 3.6.1 能效模型

    - 3.6.2 WALT算法

    - 3.6.3 唤醒进程

    - 3.6.4 CPU动态调频

    - 3.6.5 小结

- 3.7 实时调度

    - 3.7.1 低延迟例子

- 3.8 最新更新与展望

    - 3.8.1 进程管理最新更新

    - 3.8.2 展望

第4章 并发与同步

本章思考题

- 4.1 原子操作与内存屏障

    - 4.1.1 原子操作

    - 4.1.2 内存屏障

- 4.2 spinlock

    - 4.2.1 spinlock实现

    - 4.2.2 spinlock变种

    - 4.2.3 spinlock和raw\_spin\_lock

- 4.3 信号量

    - 4.3.1 信号量

    - 4.3.2 小结

- 4.4 Mutex互斥体

    - 4.4.1 MCS锁机制

    - 4.4.2 Mutex锁的实现

    - 4.4.3 小结

- 4.5 读写锁

    - 4.5.1 读者信号量

    - 4.5.2 写者锁

    - 4.5.3 小结

- 4.6 RCU

    - 4.6.1 经典RCU和Tree RCU

    - 4.6.2 TreeRCU设计

    - 4.6.3 小结

- 4.7 内存管理中的锁

- 4.8 最新更新与展望

    - 4.8.1 QueuedSpinlock

    - 4.8.2读写信号量优化

    - 4.8.3 展望

    - 4.8.4 推荐书籍

第5章 中断管理

本章思考题

5.1 Linux中断管理机制... 623

5.1.1 ARM中断控制器... 623

5.1.2 硬件中断号和Linux中断号的映射... 627

5.1.3 注册中断... 638

5.1.4 ARM底层中断处理... 646

5.1.5 高层中断处理... 654

5.1.6 小结... 663

5.2 软中断和Tasklet

5.2.1SoftIRQ软中断...665

5.2.2 Tasklet

5.2.3 local\_bh\_disable/local\_bh\_enable

5.2.4小结...676

5.3Workqueue工作队列...679

5.3.1 初始化工作队列... 680

5.3.2创建工作队列...686

5.3.3调度一个work.692

5.3.4 取消一个work. 703

5.3.5 和调度器的交互... 707

5.3.6 小结... 709

第6章  调试... 712

6.1 QEMU调试Linux内核... 712

6.1.1 QEMU运行ARM Linux内核... 712

6.1.2 QEMU调试ARM-Linux内核... 715

6.1.3 QEMU运行ARMv8开发平台... 716

6.1.4 文件系统支持... 718

6.1.5图形化调试...719

6.1.6 实验进阶... 722

6.2 Ftrace. 723

6.3SystemTap.740

6.3.1 ARM上运行SystemTap. 740

6.4 内存检测... 744

6.4.1slub_debug.744

6.4.2内存泄漏检测kmemleak.748

6.4.3 Kasan内存检测... 750

6.5 死锁检测... 753

6.6 内核调试秘籍... 759

6.6.1 printk

6.6.2动态打印

6.6.3 RAMConsole

6.6.4 OOPS分析

6.6.5 BUG\_ON()和WARN\_ON()