[TOC]

在阅读本节前请思考如下小问题。

- 软中断的回调函数执行过程中是否允许响应本地中断？
- 同一类型的软中断是否允许多个CPU并行执行？
- 软中断上下文包括哪几种情况？
- 软中断上下文和进程上下文哪个优先级高？为什么？
- 是否允许同一个Tasklet在多个CPU上并行执行？

# 0 概述

中断管理中有一个很重要的设计理念 — 上下半部机制（Top half and Bottom half)。第1节中介绍的硬件中断管理基本属于上半部的范畴，中断线程化属于下半部的范畴。在**中断线程化机制**合并到Linux内核**之前**，早己经有一些其他的**下半部机制**，例如**软中断(SoftIRQ**)、**tasklet**和**工作队列（workqueue**) 等。中断上半部有一个很重要的原则：**硬件中断处理程序**应该执行地**越快越好**。也就是说，希望它**尽快离开**并**从硬件中断返回**，这么做的原因如下。

- **硬件中断处理程序**以**异步方式执行**，它会**打断其他重要的代码**执行，因此为了避免被打断的程序停止时间太长，硬件中断处理程序必须尽快执行完成。
- 硬件中断处理程序通常在**关中断的情况**下执行。所谓的关中断，是指**关闭了本地CPU的所有中断响应(！！！**)。关中断之后，本地CPU不能再响应中断，因此硬件中断处理程序必须尽快执行完成。以ARM处理器为例，中断发生时，ARM 处理器会自动关闭本地CPU的IRQ/FIQ中断，直到从中断处理程序退出时才打开本地中断，这整个过程都处于关中断状态。

上半部通常是完成整个中断处理任务中的一小部分，例如响应中断表明中断己经被软件接收，简单的数据处理如DMA操作，以及硬件中断处理完成时发送EOI信号给中断控制器等，这些工作对时间比较敏感。此外中断处理任务还有一些计算任务，例如数据复制、数据包封装和转发、计算时间比较长的数据处理等，这些任务可以放到中断下半部来执行。Linux内核并没有严格的规则约束究竟什么样的任务应该放到下半部来执行，这要驱动开发者来决定。中断任务的划分对系统性能会有比较大的影响。

那**下半部具体在什么时候执行**呢？这个**没有确切的时间点**，一般是从**硬件中断返回**后**某一个时间点内**会被执行。下半部执行的关键点是允许响应所有的中断，是一个**开中断的环境**。

# 1 SoftIRQ软中断

软中断是Linux内核很早引入的机制，最早可以追溯到Linux 2.3开发期间。**软中断**是预留给系统中**对时间要求最为严格和最重要的下半部使用**的，而且**目前驱动**中**只有块设备**和**网络子系统**使用了**软中断**。系统**静态定义**了**若干种软中断类型**，并且Linux内核开发者**不希望用户再扩充新的软中断类型**，如有需要，建议使用**tasklet机制**。己经定义好的软中断类型如下：

```c
[include/linux/interrupt.h]
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	BLOCK_IOPOLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};
```

通过**枚举类型来静态声明软中断**，并且每一种软中断都使用**索引**来表示一种相对的**优先级**，索引号越小，软中断优先级高，并**在一轮软中断处理中**得到**优先执行**。其中：

- **HI\_SOFTIRQ**, 优先级为0 , 是**最高优先级**的软中断类型。
- **TIMER\_SOFTIRQ**, 优先级为1，**Timer定时器**的软中断。
- NET\_TX\_SOFTIRQ, 优先级为2 , **发送网络数据包**的软中断。
- NET\_RX\_SOFTIRQ，优先级为3，**接收网络数据包**的软中断。
- BLOCK\_SOFTIRQ 和 BLOCK\_IOPOLL\_SOFTIRQ, 优先级分别是4和5, 用于**块设备的软中断**。
- TASKLET\_SOFTIRQ, 优先级为6，专门为**tasklet机制**准备的软中断。
- SCHED\_SOFTIRQ, 优先级为7 , **进程调度**以及**负载均衡**。
- HRTIMER\_SOFTIRQ，优先级为8 , **高精度定时器**。
- RCU\_SOFTIRQ，优先级为9 , 专门为**RCU服务**的软中断。

此外系统还定义了一个用于**描述softirq软中断**的数据结构struct softirq\_action，并且定义了**软中断描述符数组**softirq\_vec[]，**类似硬件中断描述符**数据结构irq\_desc[]，**每个软中断类型对应一个描述符**，其中**软中断的索引号**就是该数组的**索引**。

```c
[include/linux/interrupt.h]
struct softirq_action
{
	void	(*action)(struct softirq_action *);
};

[kernel/softirq.c]
static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
```

NR\_SOFTIRQS是软中断枚举类型中表示系统**最大支持软中断类型的数量**。\_**cacheline\_aligned\_in\_smp**用于将softirq\_vec数据结构和**L1缓存行(cache line) 对齐**，在第1.12节己经详细介绍过。

struct softirq\_action数据结构比较简单，只有一个**action的函数指针**，当**触发了该软中断**，就会**调用action回调函数**来处理这个软中断。

此外还有一个**irq\_cpustat\_t**数据结构来**描述软中断状态信息**，可以理解为“**软中断状态寄存器**”，该寄存器其实是一个**unsigned int类型的变量\_\_softirq\_pending**。

同时也定义了一个**irq\_stat[NR\_CPUS]数组**，相当于**每个CPU**有一个**软中断状态信息变量**，可以理解为**每个CPU**有一个“**软中断状态寄存器(！！！**)”。

```c
[include/asm-generic/hardirq.h]
typedef struct {
	unsigned int __softirq_pending;
} ____cacheline_aligned irq_cpustat_t;

[kernel/softirq.c]
#ifndef __ARCH_IRQ_STAT
irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;
EXPORT_SYMBOL(irq_stat);
#endif
```

通过调用**open\_softirq**()函数接口可以**注册一个软中断**，其中**参数nr是软中断的序号**。

```c
[kernel/softirq.c]
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}
```

注意，softirq\_vec[]是一个**多CPU共享的数组(！！！**)，**软中断的初始化**通常是在**系统启动时完成**，系统启动时是**串行执行**的，因此它们之间**不会产生冲突**，所以这里没有额外的保护机制。

raise\_softirq()函数是主动触发一个软中断的API接口函数。

```c
[kernel/softirq.c]
void raise_softirq(unsigned int nr)
{
	unsigned long flags;

	local_irq_save(flags);
	raise_softirq_irqoff(nr);
	local_irq_restore(flags);
}
```

其实**触发软中断**有**两个API接口函数**，分别是**raise\_softirq**()和**raise\_softirq\_irqoff**(),唯一的**区别在于是否主动关闭本地中断(！！！**)，因此**raise\_softirq\_irqoff**()允许在**进程上下文中调用**。

```c
[kernel/softirq.c]
inline void raise_softirq_irqoff(unsigned int nr)
{
	__raise_softirq_irqoff(nr);

	if (!in_interrupt())
		wakeup_softirqd();
}
```

\_\_raise\_softirq\_irqoff()函数实现如下:

```c
[include/linux/irq_cpustat.h]
#define __IRQ_STAT(cpu, member)	(irq_stat[cpu].member)
#define local_softirq_pending() \
	__IRQ_STAT(smp_processor_id(), __softirq_pending)

[include/linux/interrupt.h]
#define set_softirq_pending(x) (local_softirq_pending() = (x))
#define or_softirq_pending(x)  (local_softirq_pending() |= (x))

[kernel/softirq.c]
void __raise_softirq_irqoff(unsigned int nr)
{
	or_softirq_pending(1UL << nr);
}
```

\_\_raise\_softirq\_irqoff()函数会设置**本地CPU的irq\_stat**数据结构中\_\_softirq\_pending成员的**第nr个比特位**，nr表示**软中断的序号**。在**中断返回时(！！！**)，该CPU会检查\_\_**softirq\_pending成员的比特位**，如果\_\_**softirq\_pending不为0**，说明**有pending的软中断需要处理**。

如果**触发点**发生在**中断上下文**，只需要**设置本地CPU \_\_softirq\_pending**中的**软中断对应比特位**即可。**in\_interrupt()为0**, 说明现在运行在**进程上下文**中，那么需要调用**wakeup\_softirqd**()唤醒**ksoftirqd内核线程**来处理。

注意，raise\_softirq()函数修改的是Per\-CPU类型的\_\_softirq_pending变量，这里不需要
考虑多C P U 并发的情况，因此不需要考虑使用spinlock等机制，只考虑是否需要关闭本地
中断即可。可以根据触发软中断场景来考虑是使用raise_softirq〇，还是raise_softirq_irq〇ff()。
上节中在介绍中断退出时， irq_exit() 函数会检查当前是否有 pending 等待的软中断。