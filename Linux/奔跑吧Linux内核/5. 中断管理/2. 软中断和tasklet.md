[TOC]

在阅读本节前请思考如下小问题。

- 软中断的回调函数执行过程中是否允许响应本地中断？
- 同一类型的软中断是否允许多个CPU并行执行？
- 软中断上下文包括哪几种情况？
- 软中断上下文和进程上下文哪个优先级高？为什么？
- 是否允许同一个Tasklet在多个CPU上并行执行？

# 0 概述

中断管理中有一个很重要的设计理念 — 上下半部机制（Top half and Bottom half)。第1节中介绍的硬件中断管理基本属于上半部的范畴，中断线程化属于下半部的范畴。在**中断线程化机制**合并到Linux内核**之前**，早己经有一些其他的**下半部机制**，例如**软中断(SoftIRQ**)、**tasklet**和**工作队列（workqueue**) 等。中断上半部有一个很重要的原则：**硬件中断处理程序**应该执行地**越快越好**。也就是说，希望它**尽快离开**并**从硬件中断返回**，这么做的原因如下。

- **硬件中断处理程序**以**异步方式执行**，它会**打断其他重要的代码**执行，因此为了避免被打断的程序停止时间太长，硬件中断处理程序**必须尽快执行完成**。
- **硬件中断处理程序**通常在**关中断的情况**下执行。所谓的关中断，是指**关闭了本地CPU的所有中断响应(！！！**)。关中断之后，本地CPU不能再响应中断，因此硬件中断处理程序必须尽快执行完成。以ARM处理器为例，中断发生时，ARM 处理器会自动关闭本地CPU的IRQ/FIQ中断，直到从中断处理程序退出时才打开本地中断，这整个过程都处于关中断状态。

**上半部**通常是完成**整个中断处理任务**中的**一小部分**，例如**响应中断**表明中断**己经被软件接收**，简单的数据处理如**DMA操作**，以及硬件中断处理完成时发送**EOI信号**给**中断控制器**等，这些工作**对时间比较敏感**。此外中断处理任务还有一些**计算任务**，例如数据复制、数据包封装和转发、计算时间比较长的数据处理等，这些任务可以放到中断下半部来执行。Linux内核并没有严格的规则约束究竟什么样的任务应该放到下半部来执行，这要驱动开发者来决定。中断任务的划分对系统性能会有比较大的影响。

那**下半部具体在什么时候执行**呢？这个**没有确切的时间点**，一般是从**硬件中断返回**后**某一个时间点内**会被执行。下半部执行的关键点是允许响应所有的中断，是一个**开中断的环境**。

# 1 SoftIRQ软中断

软中断是Linux内核很早引入的机制，最早可以追溯到Linux 2.3开发期间。**软中断**是预留给系统中**对时间要求最为严格和最重要的下半部(！！！**)使用的，而且**目前驱动**中**只有块设备**和**网络子系统**使用了**软中断(！！！**)。系统**静态定义**了**若干种软中断类型**，并且Linux内核开发者**不希望用户再扩充新的软中断类型**，如有需要，建议使用**tasklet机制**。己经定义好的软中断类型如下：

```c
[include/linux/interrupt.h]
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	BLOCK_IOPOLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};
```

通过**枚举类型来静态声明软中断**，并且每一种软中断都使用**索引**来表示一种相对的**优先级**，索引号越小，软中断优先级高，并**在一轮软中断处理中**得到**优先执行**。其中：

- **HI\_SOFTIRQ**, 优先级为0 , 是**最高优先级**的软中断类型。
- **TIMER\_SOFTIRQ**, 优先级为1，**Timer定时器**的软中断。
- NET\_TX\_SOFTIRQ, 优先级为2 , **发送网络数据包**的软中断。
- NET\_RX\_SOFTIRQ，优先级为3，**接收网络数据包**的软中断。
- BLOCK\_SOFTIRQ 和 BLOCK\_IOPOLL\_SOFTIRQ, 优先级分别是4和5, 用于**块设备的软中断**。
- TASKLET\_SOFTIRQ, 优先级为6，专门为**tasklet机制**准备的软中断。
- SCHED\_SOFTIRQ, 优先级为7 , **进程调度**以及**负载均衡**。
- HRTIMER\_SOFTIRQ，优先级为8 , **高精度定时器**。
- RCU\_SOFTIRQ，优先级为9 , 专门为**RCU服务**的软中断。

此外系统还定义了一个用于**描述softirq软中断**的**数据结构**struct **softirq\_action**，并且定义了**软中断描述符数组**softirq\_vec[]，**类似硬件中断描述符**数据结构irq\_desc[]，**每个软中断类型对应一个描述符**，其中**软中断的索引号**就是该数组的**索引**。

```c
[include/linux/interrupt.h]
struct softirq_action
{
	void	(*action)(struct softirq_action *);
};

[kernel/softirq.c]
static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
```

也就是**每个软中断类型**对应一个**描述符**, **静态定义**的. 可以将**softirq\_vec认为是全局软中断表**, 而且是**系统初始化会创建好(也就是action会指定！！！**).

NR\_SOFTIRQS是软中断枚举类型中表示系统**最大支持软中断类型的数量**。\_**cacheline\_aligned\_in\_smp**用于将softirq\_vec数据结构和**L1缓存行(cache line) 对齐**，在第1.12节己经详细介绍过。

struct softirq\_action数据结构比较简单，只有一个**action的函数指针**，当**触发了该软中断**，就会**调用action回调函数**来处理这个软中断。

此外还有一个**irq\_cpustat\_t**数据结构来**描述软中断状态信息**，可以理解为“**软中断状态寄存器**”，该寄存器其实是一个**unsigned int类型的变量\_\_softirq\_pending**。

同时也定义了一个**irq\_stat[NR\_CPUS]数组**，相当于**每个CPU**有一个**软中断状态信息变量**，可以理解为**每个CPU**有一个“**软中断状态寄存器(！！！**)”。

```c
[include/asm-generic/hardirq.h]
typedef struct {
	unsigned int __softirq_pending;
} ____cacheline_aligned irq_cpustat_t;

[kernel/softirq.c]
#ifndef __ARCH_IRQ_STAT
irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;
EXPORT_SYMBOL(irq_stat);
#endif
```

通过调用**open\_softirq**()函数接口可以**注册一个软中断**，其中**参数nr是软中断的序号**。

```c
[kernel/softirq.c]
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}
```

注意，**softirq\_vec**[]是一个**多CPU共享的数组(！！！**)，**软中断的初始化**通常是在**系统启动时完成(！！！每个软中断的action也是系统启动时初始化的！！！**)，系统启动时是**串行执行**的，因此它们之间**不会产生冲突**，所以这里没有额外的保护机制。

raise\_softirq()函数是**主动触发一个软中断**的API接口函数。

```c
[kernel/softirq.c]
void raise_softirq(unsigned int nr)
{
	unsigned long flags;

	local_irq_save(flags);
	raise_softirq_irqoff(nr);
	local_irq_restore(flags);
}
```

其实**触发软中断**有**两个API接口函数**，分别是**raise\_softirq**()和**raise\_softirq\_irqoff**(),唯一的**区别在于是否主动关闭本地中断(！！！**)，因此**raise\_softirq\_irqoff**()允许在**进程上下文中调用**。

```c
[kernel/softirq.c]
inline void raise_softirq_irqoff(unsigned int nr)
{
	__raise_softirq_irqoff(nr);

	if (!in_interrupt())
		wakeup_softirqd();
}
```

\_\_raise\_softirq\_irqoff()函数实现如下:

```c
[include/linux/irq_cpustat.h]
#define __IRQ_STAT(cpu, member)	(irq_stat[cpu].member)
#define local_softirq_pending() \
	__IRQ_STAT(smp_processor_id(), __softirq_pending)

[include/linux/interrupt.h]
#define set_softirq_pending(x) (local_softirq_pending() = (x))
#define or_softirq_pending(x)  (local_softirq_pending() |= (x))

[kernel/softirq.c]
void __raise_softirq_irqoff(unsigned int nr)
{
	or_softirq_pending(1UL << nr);
}
```

\_\_raise\_softirq\_irqoff()函数会设置**本地CPU的irq\_stat**数据结构中\_\_softirq\_pending成员的**第nr个比特位**，nr表示**软中断的序号**。在**中断返回时(！！！**)，该CPU会检查\_\_**softirq\_pending成员的比特位**，如果\_\_**softirq\_pending不为0**，说明**有pending的软中断需要处理**。

如果**触发点**发生在**中断上下文**，只需要**设置本地CPU \_\_softirq\_pending**中的**软中断对应比特位**即可。**in\_interrupt()为0**, 说明现在运行在**进程上下文**中，那么需要调用**wakeup\_softirqd**()唤醒**ksoftirqd内核线程**来处理。

注意，**raise\_softirq**()函数修改的是**Per\-CPU类型**的\_\_**softirq\_pending变量**，这里**不需要考虑多CPU并发**的情况，因此不需要考虑使用spinlock等机制，**只考虑是否需要关闭本地中断(！！！**)即可。可以根据**触发软中断场景**来考虑是使用raise\_softirq()，还是raise\_softirq\_irqoff()。

上节中在介绍**中断退出**时， **irq\_exit**()函数会检查**当前是否有pending 等待的软中断(！！！**)。

```c
[中断发生->irq_handler-> gic_handle_irq() ->handle_domain_irq() ->irq_exit ()]

[kernel/softirq.c]
void irq_exit(void)
{
    ...
	if (!in_interrupt() && local_softirq_pending())
	    // 重要
		invoke_softirq();
    ...
}
```

**local\_softirq\_pending**()函数检查**本地CPU**的\_\_**softirq\_pending****是否有**pending等待的软中断**。注意，这里还有一个判断条件**为! in\_terrupt**(), 也就是说，**中断退出**时**不能处于硬件中断上下文**(Hardirq context)和**软中断上下文（Softirq context**)中。**硬件中断处理过程**一般都是**关中断**的，**中断退出时**也就**退出了硬件中断上下文**，因此该条件会满足。还有一个场景，如果**本次中断点**发生在一个**软中断处理过程**中，那么**中断退出**时会**返回到软中断上下文**中，因此这种情况**不允许重新调度软中断**，因为**软中断**在**一个CPU**上总是**串行执行(！！！**)的。

```c
[irq_exit() ->invoke_softirq() -> __do_softirq()]
[kernel/softirq.c]
asmlinkage __visible void __do_softirq(void)
{
	unsigned long end = jiffies + MAX_SOFTIRQ_TIME;
	unsigned long old_flags = current->flags;
	int max_restart = MAX_SOFTIRQ_RESTART;
	struct softirq_action *h;
	bool in_hardirq;
	__u32 pending;
	int softirq_bit;
    // 位置1
	current->flags &= ~PF_MEMALLOC;
    // 位置2
	pending = local_softirq_pending();
	// 位置3
	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);

restart:
	/* Reset the pending bitmask before enabling irqs */
	// 位置4
	set_softirq_pending(0);
    // 位置5
	local_irq_enable();

	h = softirq_vec;
    // 位置6
	while ((softirq_bit = ffs(pending))) {
		unsigned int vec_nr;
		int prev_count;

		h += softirq_bit - 1;

		vec_nr = h - softirq_vec;
		prev_count = preempt_count();

		h->action(h);
		h++;
		pending >>= softirq_bit;
	}
    // 位置7
	local_irq_disable();
    // 位置8
	pending = local_softirq_pending();
	if (pending) {
		if (time_before(jiffies, end) && !need_resched() &&
		    --max_restart)
			goto restart;

		wakeup_softirqd();
	}
    // 位置9
	__local_bh_enable(SOFTIRQ_OFFSET);
	// 位置10
	tsk_restore_flags(current, old_flags, PF_MEMALLOC);
}
```

位置1和位置10是**配对使用**的。**PF\_MEMALLOC**目前主要用在**两个地方**，一是**直接内存压缩(direct compaction)的内核路径**，二是**网络子系统**在**分配skbuff失败**时会设置PF\_MEMALLOC标志位，这是在Linux 3.6内核中，社区专家Mel Gorman为了解决**网络磁盘设备**(network Block Device, NBD)使用**交换分区**时出现**死锁**的问题而引入的，己经超出本章的讨论范围.

位置2, 获取**本地CPU(！！！**)的**软中断寄存器\_\_softirq_pending**的值到局部变量pending.

位置3，增加**preempt\_count**中的**SOFTIRQ域的计数**，表明现在是在**软中断上下文**中。

位置4，清除**软中断寄存器\_\_softirq\_pending**。

位置5，**打开本地中断**。这里**先清除\_\_softirq\_pending**位图，然后再**打开本地中断**。需要注意这里和位置4之间的顺序，读者可以思考如果在位置4之前打开本地中断会有什么后果。

位置6，**while循环依次处理软中断**。首先**ffs**()函数会找到**pending中第一个置位的比特位**，然后找到**对应的软中断描述符**和**软中断的序号**，最后**调用action**()函数指针来**执行软中断**处理，依次循环直到**所有软中断都处理完成**。

位置7，**关闭本地中断**。

位置8到位置9，**再次检查\_\_softirq\_pending是否又产生了软中断**。因为**软中断执行过程**是**开中断**的，有可能在这个过程中又发生了中断以及触发了软中断，即有人**调用了raise\_softirq**()。注意，**不是检测到有软中断**就**马上调转到restart标签处**进行软中断处理，这里需要一个**系统平衡的考虑**。需要考虑**3个判断条件**，一是**软中断处理时间没有超过2毫秒**，二是**当前没有进程要求调度**，即!need\_resched(),三是**这种循环不能多于10次**，否则应该**唤醒ksoftirqd内核线程**来处理软中断。

位置9, 代码和位置3代码是配对使用，表示现在**离开软中断上下文**了。

# 2 tasklet

tasklet是利用软中断实现的一种下半部机制，本质上是软中断的一个变种，运行在软中断上下文中。tasklet由tasklet_struct数据结构来描述：