[TOC]

在阅读本节前请思考如下小问题。

- 软中断的回调函数执行过程中是否允许响应本地中断？
- 同一类型的软中断是否允许多个CPU并行执行？
- 软中断上下文包括哪几种情况？
- 软中断上下文和进程上下文哪个优先级高？为什么？
- 是否允许同一个Tasklet在多个CPU上并行执行？

# 0 概述

中断管理中有一个很重要的设计理念 — 上下半部机制（Top half and Bottom half)。第1节中介绍的硬件中断管理基本属于上半部的范畴，中断线程化属于下半部的范畴。在**中断线程化机制**合并到Linux内核**之前**，早己经有一些其他的**下半部机制**，例如**软中断(SoftIRQ**)、**tasklet**和**工作队列（workqueue**) 等。中断上半部有一个很重要的原则：**硬件中断处理程序**应该执行地**越快越好**。也就是说，希望它**尽快离开**并**从硬件中断返回**，这么做的原因如下。

- **硬件中断处理程序**以**异步方式执行**，它会**打断其他重要的代码**执行，因此为了避免被打断的程序停止时间太长，硬件中断处理程序**必须尽快执行完成**。
- **硬件中断处理程序**通常在**关中断的情况**下执行。所谓的关中断，是指**关闭了本地CPU的所有中断响应(！！！**)。关中断之后，**本地CPU不能再响应中断**，因此硬件中断处理程序必须尽快执行完成。以ARM处理器为例，中断发生时，ARM 处理器会自动关闭本地CPU的IRQ/FIQ中断，直到从中断处理程序退出时才打开本地中断，这整个过程都处于关中断状态。

**上半部**通常是完成**整个中断处理任务**中的**一小部分**，例如**响应中断**表明中断**己经被软件接收**，简单的数据处理如**DMA操作**，以及硬件中断处理完成时发送**EOI信号**给**中断控制器**等，这些工作**对时间比较敏感**。此外中断处理任务还有一些**计算任务**，例如数据复制、数据包封装和转发、计算时间比较长的数据处理等，这些任务可以放到中断下半部来执行。Linux内核并没有严格的规则约束究竟什么样的任务应该放到下半部来执行，这要驱动开发者来决定。中断任务的划分对系统性能会有比较大的影响。

那**下半部具体在什么时候执行**呢？这个**没有确切的时间点**，一般是从**硬件中断返回**后**某一个时间点内**会被执行。下半部执行的关键点是允许响应所有的中断，是一个**开中断的环境**。

# 1 SoftIRQ软中断

软中断是Linux内核很早引入的机制，最早可以追溯到Linux 2.3开发期间。**软中断**是预留给系统中**对时间要求最为严格和最重要的下半部(！！！**)使用的，而且**目前驱动**中**只有块设备**和**网络子系统**使用了**软中断(！！！**)。

## 1.1 软中断相关定义

系统**静态定义**了**若干种软中断类型**，并且Linux内核开发者**不希望用户再扩充新的软中断类型**，如有需要，建议使用**tasklet机制**。己经定义好的软中断类型如下：

```c
[include/linux/interrupt.h]
enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	BLOCK_IOPOLL_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
	HRTIMER_SOFTIRQ,
	RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */

	NR_SOFTIRQS
};
```

通过**枚举类型来静态声明软中断**，并且每一种软中断都使用**索引**来表示一种相对的**优先级**，索引号越小，软中断优先级高，并**在一轮软中断处理中**得到**优先执行**。其中：

- **HI\_SOFTIRQ**, 优先级为0 , 是**最高优先级**的软中断类型。
- **TIMER\_SOFTIRQ**, 优先级为1，**Timer定时器**的软中断。
- NET\_TX\_SOFTIRQ, 优先级为2 , **发送网络数据包**的软中断。
- NET\_RX\_SOFTIRQ，优先级为3，**接收网络数据包**的软中断。
- BLOCK\_SOFTIRQ 和 BLOCK\_IOPOLL\_SOFTIRQ, 优先级分别是4和5, 用于**块设备的软中断**。
- TASKLET\_SOFTIRQ, 优先级为6，专门为**tasklet机制**准备的软中断。
- SCHED\_SOFTIRQ, 优先级为7 , **进程调度**以及**负载均衡**。
- HRTIMER\_SOFTIRQ，优先级为8 , **高精度定时器**。
- RCU\_SOFTIRQ，优先级为9 , 专门为**RCU服务**的软中断。

### 1.1.1 struct softirq\_action

此外系统还定义了一个用于**描述softirq软中断**的**数据结构**struct **softirq\_action**，并且定义了**软中断描述符数组**softirq\_vec[]，**类似硬件中断描述符**数据结构irq\_desc[]，**每个软中断类型对应一个描述符**，其中**软中断的索引号**就是该数组的**索引**。

```c
[include/linux/interrupt.h]
struct softirq_action
{
	void	(*action)(struct softirq_action *);
};

[kernel/softirq.c]
static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
```

也就是**每个软中断类型**对应一个**描述符**, **静态定义**的. 可以将**softirq\_vec认为是全局软中断action表(非per CPU**), 而且是**系统初始化会创建好(也就是action会指定！！！**).

NR\_SOFTIRQS是软中断枚举类型中表示系统**最大支持软中断类型的数量**。\_**cacheline\_aligned\_in\_smp**用于将softirq\_vec数据结构和**L1缓存行(cache line) 对齐**，在第1.12节己经详细介绍过。

struct softirq\_action数据结构比较简单，只有一个**action的函数指针**，当**触发了该软中断**，就会**调用action回调函数**来处理这个软中断。

### 1.1.2 irq\_cpustat\_t

此外还有一个**irq\_cpustat\_t**数据结构来**描述软中断状态信息**，可以理解为“**软中断状态寄存器**”，该寄存器其实是一个**unsigned int类型的变量\_\_softirq\_pending**。

同时也定义了一个**irq\_stat[NR\_CPUS]数组**，相当于**每个CPU**有一个**软中断状态信息变量**，可以理解为**每个CPU**有一个“**软中断状态寄存器(！！！**)”。

```c
[include/asm-generic/hardirq.h]
typedef struct {
	unsigned int __softirq_pending;
} ____cacheline_aligned irq_cpustat_t;

[kernel/softirq.c]
#ifndef __ARCH_IRQ_STAT
irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;
EXPORT_SYMBOL(irq_stat);
#endif
```

### 1.1.3 软中断的守护进程ksoftirqd

在**cpu的热插拔**阶段，内核为**每个cpu**创建了一个用于**执行软件中断**的**守护进程ksoftirqd**，同时定义了一个**per\_cpu变量**用于**保存每个守护进程的task\_struct**结构指针：

```c
DEFINE_PER_CPU(struct task_struct *, ksoftirqd);
```

大多数情况下，软中断都会在irq\_exit阶段被执行，在irq\_exit阶段没有处理完的软中断才有可能会在守护进程中执行。

## 1.2 注册软中断

通过调用**open\_softirq**()函数接口可以**注册一个软中断**，其中**参数nr是软中断的序号**。

```c
[kernel/softirq.c]
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}
```

注意，**softirq\_vec**[]是一个**多CPU共享的数组(！！！**)，**软中断的初始化**通常是在**系统启动时完成(！！！每个软中断的action也是系统启动时初始化的！！！**)，系统启动时是**串行执行**的，因此它们之间**不会产生冲突**，所以这里没有额外的保护机制。

## 1.3 触发软中断

总结:

(1) **raise\_softirq**()比**raise\_softirq\_irqoff**()唯一区别在于**前者主动关闭本地中断**, 所以后者可以在进程上下文调用

(2) 设置**本地CPU的irq\_stat**的第nr比特位

(3) 通过**in\_interrupt**判断是否在**中断上下文**, **不在的话**, 唤醒**软中断守护进程ksoftirqd**, 在**守护进程中执行软中断**回调函数; 在**中断上下文(！！！**)的话, 软中断将在**中断退出阶段被执行**

raise\_softirq()函数是**主动触发一个软中断**的API接口函数。

```c
[kernel/softirq.c]
void raise_softirq(unsigned int nr)
{
	unsigned long flags;

	local_irq_save(flags);
	raise_softirq_irqoff(nr);
	local_irq_restore(flags);
}
```

其实**触发软中断**有**两个API接口函数**，分别是**raise\_softirq**()和**raise\_softirq\_irqoff**(),唯一的**区别在于是否主动关闭本地中断(！！！**)，因此**raise\_softirq\_irqoff**()允许在**进程上下文(！！！)中调用**。

```c
[kernel/softirq.c]
inline void raise_softirq_irqoff(unsigned int nr)
{
	__raise_softirq_irqoff(nr);

	if (!in_interrupt())
		wakeup_softirqd();
}
```

\_\_raise\_softirq\_irqoff()函数实现如下:

```c
[include/linux/irq_cpustat.h]
#define __IRQ_STAT(cpu, member)	(irq_stat[cpu].member)
#define local_softirq_pending() \
	__IRQ_STAT(smp_processor_id(), __softirq_pending)

[include/linux/interrupt.h]
#define set_softirq_pending(x) (local_softirq_pending() = (x))
#define or_softirq_pending(x)  (local_softirq_pending() |= (x))

[kernel/softirq.c]
void __raise_softirq_irqoff(unsigned int nr)
{
	or_softirq_pending(1UL << nr);
}
```

\_\_raise\_softirq\_irqoff()函数会设置**本地CPU的irq\_stat**数据结构中\_\_softirq\_pending成员的**第nr个比特位**，nr表示**软中断的序号**。

在**中断返回时(！！！**)，该CPU会检查\_\_**softirq\_pending成员的比特位**，如果\_\_**softirq\_pending不为0**，说明**有pending的软中断需要处理**。

如果**触发点**发生在**中断上下文**，只需要**设置本地CPU \_\_softirq\_pending**中的**软中断对应比特位**即可。**in\_interrupt()为0**, 说明现在运行在**进程上下文**中，那么需要调用**wakeup\_softirqd**()唤醒**ksoftirqd内核线程**来处理。

注意，**raise\_softirq**()函数修改的是**Per\-CPU类型**的\_\_**softirq\_pending变量**，这里**不需要考虑多CPU并发**的情况，因此不需要考虑使用spinlock等机制，**只考虑是否需要关闭本地中断(！！！**)即可。可以根据**触发软中断场景**来考虑是使用raise\_softirq()，还是raise\_softirq\_irqoff()。

## 1.4 软中断的执行

基于上面所说，**软中断的执行**既可以**守护进程**中执行，也可以在**中断的退出阶段**执行。实际上，软中断**更多的是在中断的退出阶段执行**（irq\_exit），以便达到更快的响应. 加入**守护进程机制**，只是担心一旦有大量的软中断等待执行，会使得内核**过长地留在中断上下文**中。

## 1.4.1 中断退出阶段执行软中断

总结:

(1) 判断条件, **中断退出**时不能处于**中断上下文**(还有种情况, **中断点在软中断处理过程**中, **中断退出**时会返回到**软中断上下文<也是中断上下文**>, 也**不能重新调度软中断**, 因为**软中断在一个CPU总是串行执行**); 本地CPU的irq\_stat上有**pending等待的软中断**

(2) 调用软中断**invoke\_softirq**()

(3) 获取本地CPU的软中断状态irq\_stat

(4) 增加当前进程struct thread\_info中的preempt\_count成员里的SOFTIRQ域的值, 表明在软中断上下文

(5) 清除软中断状态寄存器\_\_softirq\_pending, **清除所有**, 因为这里将全部处理

(6) **打开本地中断**, 允许**新的中断**以及**触发软中断**

(7) 循环处理软中断. 遍历**软中断状态irq\_stat(每个CPU一个**), 每一个相当于软中断向量表softirq\_vec\[\]的索引, 得到软中断然后执行

(8) **关闭本地中断**. 

(9) 再次检查\_\_softirq\_pending, 看是否又产生软中断. 条件满足回到步骤(5), 否则唤醒**ksoftirqd内核线程**来处理软中断

(10) 减少当前进程struct thread\_info中的preempt\_count成员里的SOFTIRQ域的值, 表明离开软中断上下文

上节中在介绍**中断退出**时， **irq\_exit**()函数会检查**当前是否有pending 等待的软中断(！！！**)。

```c
[中断发生->irq_handler-> gic_handle_irq() ->handle_domain_irq() ->irq_exit()]

[kernel/softirq.c]
void irq_exit(void)
{
    ...
	if (!in_interrupt() && local_softirq_pending())
	    // 重要
		invoke_softirq();
    ...
}
```

**local\_softirq\_pending**()函数检查**本地CPU**的\_\_**softirq\_pending****是否有**pending等待的软中断**。注意，这里还有一个判断条件**为!in\_terrupt**(), 也就是说，**中断退出**时**不能处于硬件中断上下文**(Hardirq context)和**软中断上下文（Softirq context**)中。**硬件中断处理过程**一般都是**关中断**的，**中断退出时**也就**退出了硬件中断上下文**，因此该条件会满足。还有一个场景，如果**本次中断点**发生在一个**软中断处理过程**中，那么**中断退出**时会**返回到软中断上下文<也是中断上下文**>中，因此这种情况**不允许重新调度软中断**，因为**软中断**在**一个CPU**上总是**串行执行(！！！**)的。

invoke\_softirq()继续查看.

```c
[irq_exit() ->invoke_softirq() -> __do_softirq()]
[kernel/softirq.c]
asmlinkage __visible void __do_softirq(void)
{
	unsigned long end = jiffies + MAX_SOFTIRQ_TIME;
	unsigned long old_flags = current->flags;
	int max_restart = MAX_SOFTIRQ_RESTART;
	struct softirq_action *h;
	bool in_hardirq;
	__u32 pending;
	int softirq_bit;
    // 位置1
	current->flags &= ~PF_MEMALLOC;
    // 位置2
	pending = local_softirq_pending();
	// 位置3
	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);

restart:
	/* Reset the pending bitmask before enabling irqs */
	// 位置4
	set_softirq_pending(0);
    // 位置5
	local_irq_enable();

	h = softirq_vec;
    // 位置6
	while ((softirq_bit = ffs(pending))) {
		unsigned int vec_nr;
		int prev_count;

		h += softirq_bit - 1;

		vec_nr = h - softirq_vec;
		prev_count = preempt_count();

		h->action(h);
		h++;
		pending >>= softirq_bit;
	}
    // 位置7
	local_irq_disable();
    // 位置8
	pending = local_softirq_pending();
	if (pending) {
		if (time_before(jiffies, end) && !need_resched() &&
		    --max_restart)
			goto restart;

		wakeup_softirqd();
	}
    // 位置9
	__local_bh_enable(SOFTIRQ_OFFSET);
	// 位置10
	tsk_restore_flags(current, old_flags, PF_MEMALLOC);
}
```

位置1和位置10是**配对使用**的。**PF\_MEMALLOC**目前主要用在**两个地方**，一是**直接内存压缩(direct compaction)的内核路径**，二是**网络子系统**在**分配skbuff失败**时会设置PF\_MEMALLOC标志位，这是在Linux 3.6内核中，社区专家Mel Gorman为了解决**网络磁盘设备**(network Block Device, NBD)使用**交换分区**时出现**死锁**的问题而引入的，己经超出本章的讨论范围.

位置2, 获取**本地CPU(！！！**)的**软中断寄存器\_\_softirq_pending**的值到局部变量pending.

位置3，增加**preempt\_count**中的**SOFTIRQ域的计数**，表明现在是在**软中断上下文**中, 由此禁止了软中断, 主要为了防止和软中断守护进程发生竞争；

位置4，清除**软中断寄存器\_\_softirq\_pending**, 将所有都清除了。

位置5，**打开本地中断**。这里**先清除\_\_softirq\_pending**位图，然后再**打开本地中断**。需要注意这里和位置4之间的顺序，读者可以思考如果在位置4之前打开本地中断会有什么后果。

位置6，**while循环依次处理软中断**。首先**ffs**()函数会找到**pending中第一个置位的比特位**，然后找到**对应的软中断描述符**和**软中断的序号**，最后**调用action**()函数指针来**执行软中断**处理，依次循环直到**所有软中断都处理完成**。

位置7，**关闭本地中断**。

位置8到位置9，**再次检查\_\_softirq\_pending是否又产生了软中断**。因为**软中断执行过程**是**开中断**的，有可能在这个过程中又发生了中断以及触发了软中断，即有人**调用了raise\_softirq**()。注意，**不是检测到有软中断**就**马上调转到restart标签处**进行软中断处理，这里需要一个**系统平衡的考虑**。需要考虑**3个判断条件**，一是**软中断处理时间没有超过2毫秒**，二是**当前没有进程要求调度**，即!need\_resched(),三是**这种循环不能多于10次**，否则应该**唤醒ksoftirqd内核线程**来处理软中断。

位置9, 代码和位置3代码是配对使用，恢复软中断, 表示现在**离开软中断上下文**了。

### 1.4.2 在ksoftirqd进程中执行

软中断也可能由**ksoftirqd守护进程执行**，这要发生在以下两种情况下：

- 在**irq\_exit中执行软中断**，但是在经过**MAX\_SOFTIRQ\_RESTART次(目前设定为10**)循环后，**软中断还未处理完**，这种情况虽然极少发生，但毕竟有可能；
- 内核的其它代码**主动调用raise\_softirq**，而这时正好**不是在中断上下文中(！！！**)，守护进程将被唤醒；

守护进程最终也会调用\_\_**do\_softirq**执行软中断的回调，具体的代码位于**run\_ksoftirqd**函数中，内核会关闭抢占的情况下执行\_\_do\_softirq，具体的过程这里不做讨论。

# 2 tasklet

tasklet是利用**软中断**实现的一种下半部机制，本质上是**软中断的一个变种**，运行在**软中断上下文(！！！**)中。tasklet由tasklet\_struct数据结构来描述：

```c
[include/linux/interrupt.h]
struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	void (*func)(unsigned long);
	unsigned long data;
};
```

- next: **多个tasklet**串成一个**链表**。
- state: 该**tasklet当前状态**. TASKLET\_STATE\_SCHED表示tasklet己经被调度，正准备运行。TASKLET\_STATE\_RUN表示tasklet正在运行中。
- count: 为**0**表示tasklet处于**激活状态**；**不为0**表示该**tasklet被禁止**，**不允许执行**。
- func: **tasklet处理程序**，类似软中断中的**action函数指针**。
- data: 传递**参数**给tasklet处理函数。

**每个CPU**维护**两个tasklet链表**，一个用于**普通优先级的tasklet\_vec**，另一个用于**高优先级的tasklet\_hi\_vec**，它们都是**Per\-CPU变量**。链表中**每个tasklet\_struct**代表一个**tasklet**。

```c
[kernel/softirq.c]
struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);
```

其中，**tasklet\_vec**使用**软中断**中的**TASKLET\_SOFTIRQ**类型，它的**优先级是6**; 而**tasklet\_hi\_vec**使用的**软中断**中的**HI\_SOFTIRQ**, **优先级是0**，是**所有软中断**中**优先级最高**的。

在**系统启动**时会**初始化这两个链表**，见**softirq\_init**()函数，另外还会**注册TASKLET\_SOFTIRQ**和**HI\_SOFTIRQ**这**两个软中断**，它们的**软中断回调函数**分别为**tasklet\_action**和**tasklet\_hi\_action**。高优先级的**tasklet\_hi**在**网络驱动**中用得比较多，它和普通的tasklet实现机制相同，本文以**普通tasklet为例**。

```c
[start_kernel()->softirq_init()]
[kernel/softirq.c]
void __init softirq_init(void)
{
	int cpu;

	for_each_possible_cpu(cpu) {
		per_cpu(tasklet_vec, cpu).tail =
			&per_cpu(tasklet_vec, cpu).head;
		per_cpu(tasklet_hi_vec, cpu).tail =
			&per_cpu(tasklet_hi_vec, cpu).head;
	}

	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
```

要想在**驱动**中使用**tasklet**，首先**定义一个tasklet**, 可以**静态申明**， 也可以**动态初始化**。

```c
[include/linux/interrupt.h]
#define DECLARE_TASKLET(name, func, data) \
struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }

#define DECLARE_TASKLET_DISABLED(name, func, data) \
struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }
```

上述两个宏都是**静态**地申明一个**tasklet数据结构**。上述两个宏的**唯一区别**在于**count成员**的初始化值不同，DECLARE\_TASKLET宏把**count初始化为0**, 表示**tasklet处于激活状态**；而DECLARE\_TASKLET\_DISABLED宏把**count成员初始化为1** , 表示**该tasklet处于关闭状态**。

当然也可以在驱动代码中调用tasklet\_init()函数**动态初始化tasklet**。

```c
[]
```

在驱动程序中调度tasklet可以使用tasklet\_schedule()函数。

