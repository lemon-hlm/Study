[TOC]

思考题:

- workqueue是运行在中断上下文，还是进程上下文？其回调函数允许睡眠吗？
- 旧版本（Linux 2.6.25)的 workqueue机制在实际过程中遇到了哪些问题和挑战？
- CMWQ机制如何动态管理工作线程池的线程呢？
- 如果有多个work挂入一个工作线程中执行，当某个work的回调函数执行了阻塞操作，那么剩下的work该怎么办？

# 0 概述

工作队列机制(workqueue)是除了软中断和tasklet以外最常用的一种下半部机制。工作队列的基本原理是把work(需要推迟执行的函数）交由一个内核线程来执行，它总是在进程上下文中执行。工作队列的优点是利用进程上下文来执行中断下半部操作，因此工作队列允许重新调度和睡眠，是异步执行的进程上下文，另外它还能解决软中断和tasklet执行时间过长导致系统实时性下降等问题。

当驱动程序或者内核子系统在进程上下文中有异步执行的工作任务时，可以使用work item来描述工作任务，包括该工作任务的执行回调函数，把 work item添加到一个队列中，然后一个内核线程会去执行这个工作任务的回调函数。这里work item被称为工作，队列被称为workqueue，即工作队列，内核线程被称为worker。

工作队列最早是在Linux 2.5.x内核开发期间被引入的机制，早期的工作队列的设计比较简单，由多线程（Multi threaded，每个CPU默认一个工作线程）和单线程（Single threaded, 用户可以自行创建工作线程）组成。在长期测试中发现如下问题:

- 内核线程数量太多。虽然系统中有默认的一套工作线程（kevents)，但是有很多驱动和子系统喜欢自行创建工作线程，例如调用create\_workqueue()函数，这样在大型系统(CPU数量比较多的机器)中可能内核启动结束之后就耗尽了系统PID资源。
- 并发性比较差。Multi threaded的工作线程和CPU是一一绑定的，例如CPU0上的某个工作线程有A 、B 和 C 三个work。假设执行work A上回调函数时发生了睡眠和调度，CPU0就会调度出去执行其他的进程，对 于 B 和 C 来说，它们只能等待CPU0重新调度执行该工作线程，尽管其他CPU比较空闲，也没有办法迁移到其他CPU上执行。
- 死锁问题。系统有一个默认的工作队列kevents, 如果有很多work运行在默认的工作队列kevents上，并且它们有一些数据上依赖关系，那么很有可能会产生死锁。解决办法是为每一个有可能产生死锁的work创建一个专职的工作线程，这样又回到问题1 了。

为此社区专家Tejun Heo在Linux 2.6.36中提出了一套解决方案concurrency\-managed workqueues(CMWQ)。执行work任务的线程称为worker或工作线程。工作线程会串行化地执行挂入到队列中所有的work。如果队列中没有work, 那么该工作线程就会变成idle状态。为了管理众多工作线程，CMWQ提出了工作线程池(worker\-pool)概念，worker\-pool有两种，一是BOUND类型的，可以理解为Per\-CPU类型，每个CPU都有worker\-pool; 另一种是UNBOUND类型的，即不和具体CPU绑定。这两种worker\-pool都会定义两个线程池，一个给普通优先级的work使用，另一个给高优先级的work使用。这些工作线程池中的线程数量是动态分配和管理的，而不是固定的。当工作线程睡眠时，会去检查是否需要唤醒更多的工作线程，如有需要，会去唤醒同一个工作线程池中idle状态的工作线程。

# 1 初始化工作队列

workqueue机制最小的调度单元是work item, 有的书中称为工作任务，由 struct work\_struct数据结构来抽象和描述，本章简称为work或工作任务。

```c
[include/linux/workqueue.h]
struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};
```

