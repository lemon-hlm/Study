[TOC]

操作系统还有一个很重要的功能就是**管理众多的外设**，例如键盘鼠标、显示器、无线网卡、声卡等。**处理器和外设**之间的**运算能力**和**处理速度**通常不在一个数量级上。假设现在**处理器**需要去**获取一个键盘的事件**，如果**处理器**发出一个**请求信号**之后一直在**轮询（polling) 键盘的响应**，由于键盘响应速度比处理器慢得多并且等待用户输入，那么处理器是**很浪费CPU资源**的。与其这样，不如**键盘有事件发生时发送一个信号给处理器**，让处理器暂停当前的工作来处理这个响应，比处理器一直在轮询效率要高，这就是中断机制产生的背景。

凡事都不是绝对的，轮询机制也不完全比中断机制差。例如，在**网络吞吐量大**的应用场景下，**网卡驱动**采用**轮询机制比中断机制效率要高**，比如现在很火的一个开源组件DPDK(Data Plane Development Kit).

本章介绍ARM 架构下中断是如何管理的，Linux内核中的中断管理机制是如何设计与实现的，以及常用的下半部机制，例如软中断、tasklet、workqueue等。

阅读前思考:

- 发生硬件中断后，ARM处理器做了哪些事情？
- 硬件中断号和Linux内核的IRQ中断号是如何映射的？
- 一个硬件中断发生后，Linux内核如何响应并处理该中断？
- 为什么说中断上下文不能执行睡眠操作？

Linux内核支持**众多的处理器体系结构**，因此从**系统角度**来看，Linux内核中断管理可以分成如下4层。

- **硬件层**，例如CPU和中断控制器的连接。
- **处理器架构管理**，例如CPU中断异常处理。
- **中断控制器管理**，例如IRQ中断号的映射。
- Linux内核**通用中断处理器层**，例如**中断注册**和**中断处理**。

**不同的体系结构**对中断控制器有着**不同的设计理念**，例如**ARM**公司提供了一个**通用的中断控制器GIC** (Generic Interrupt Controller), **x86**体系架构则采用**APIC控制器**(Advanced Programmable Interrupt Controller)。目前最新版本的GIC技术规范是 version 3/4, version2 通常在ARMv7架构处理器中使用，例如CortexA7 和 CortexA9 等，它最多可以支持8 核；Version3 和 version4 则支持ARMV8架构，例如CortexA53等。本文以ARMVexpress平台®为例来介绍中断管理的实现，它支持GIC Version 2 版本。

# 1 ARM中断控制器

ARM Vexpress V2P\-CA15\_CA7 平台支持 CortexA 15 和Cortex A7 两个CPU cluster, 中断控制器采用GI04 0 0 控制器，支持GIC version 2技术规范，如图5.1所示，GIC-V 2规范支持如下中断类型。

- SGI 软件触发中断（Software Generated Interrupt)，通常用于多核之间通讯。最多支持16个 SGI中断,硬件中断号从ID0 〜 ID15。SGI通常在Linux内核中被用作IPI中 断 （inter-process interrupts)，并会送达到系统指定的C P U 上。
- PIH私有外设中断（Private Peripheral Interrupt)，这是每个处理核心私有的中断。最多支持16个PPI中断，硬件中断号从ID16〜ID31。PPI通常会送达到指定的C P U 上，应用场景有C P U 本地时钟（local timer)。
- SPI外设中断（Shared Peripheral Interrupt)，公用的外设中断。最多可以支持988个外设中断，硬件中断号从ID32〜ID1019。

![config](./images/1.png)

......................

# 2 硬件中断号和Linux中断号的映射

**注册中断**API函数**request\_irq**()/ **request\_threaded\_irq**()是使用Linux内核**软件中断号**（俗称软件中断号或IRQ中断号），而**不是硬件中断号(！！！**)。

```c
int request_threaded_irq (unsigned int irq,  irq_handler_t handler,
                irq_handler_t thread_fn, unsigned long irqflags,
                const char *devname, void *dev_id)
```

其中，**参数irq**在Linux内核中称为**IRQ number或 interrpt line**，这是一个Linux内核管理的**虚拟中断号**，并**不是指硬件的中断号**。内核中有一个**宏NR\_IRQS**来表示系统支持**中断数量的最大值**，NR\_IRQS和**平台相关**，例如VexpressV2P\-CA15\_CA7平台的定义。

```c++
/* [arch/arm/mach-versatile/include/mach/irqs.h] */

#define IRQ_SIC_END  95
#define NR_IRQS  (IRQ_GPI03_END + 1)
```

在x86平台

```c++
/* arch/x86/include/asm/irq_vectors.h */

#define NR_IRQS_LEGACY			16

#define CPU_VECTOR_LIMIT		(64 * NR_CPUS)
#define IO_APIC_VECTOR_LIMIT		(32 * MAX_IO_APICS)

#if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_PCI_MSI)
#define NR_IRQS						\
	(CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?	\
		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\
		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))
#elif defined(CONFIG_X86_IO_APIC)
#define	NR_IRQS				(NR_VECTORS + IO_APIC_VECTOR_LIMIT)
#elif defined(CONFIG_PCI_MSI)
#define NR_IRQS				(NR_VECTORS + CPU_VECTOR_LIMIT)
#else
#define NR_IRQS				NR_IRQS_LEGACY
#endif
```

此外, Linux内核定义了一个位图来管理这些中断号.

```c++
/* [kernel/irq/irqdesc.c] */

# define IRQ_BITMAP_BITS  NR_IRQS
static DECLARE_BITMAP (allocated_irqs, IRQ_BITMAP_BITS);
```

