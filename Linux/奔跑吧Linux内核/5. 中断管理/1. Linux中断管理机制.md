[TOC]

操作系统还有一个很重要的功能就是**管理众多的外设**，例如键盘鼠标、显示器、无线网卡、声卡等。**处理器和外设**之间的**运算能力**和**处理速度**通常不在一个数量级上。假设现在**处理器**需要去**获取一个键盘的事件**，如果**处理器**发出一个**请求信号**之后一直在**轮询（polling) 键盘的响应**，由于键盘响应速度比处理器慢得多并且等待用户输入，那么处理器是**很浪费CPU资源**的。与其这样，不如**键盘有事件发生时发送一个信号给处理器**，让处理器暂停当前的工作来处理这个响应，比处理器一直在轮询效率要高，这就是中断机制产生的背景。

凡事都不是绝对的，轮询机制也不完全比中断机制差。例如，在**网络吞吐量大**的应用场景下，**网卡驱动**采用**轮询机制比中断机制效率要高**，比如现在很火的一个开源组件DPDK(Data Plane Development Kit).

本章介绍ARM 架构下中断是如何管理的，Linux内核中的中断管理机制是如何设计与实现的，以及常用的下半部机制，例如软中断、tasklet、workqueue等。

阅读前思考:

- 发生硬件中断后，ARM处理器做了哪些事情？
- 硬件中断号和Linux内核的IRQ中断号是如何映射的？
- 一个硬件中断发生后，Linux内核如何响应并处理该中断？
- 为什么说中断上下文不能执行睡眠操作？

Linux内核支持**众多的处理器体系结构**，因此从**系统角度**来看，Linux内核中断管理可以分成如下4层。

- **硬件层**，例如CPU和中断控制器的连接。
- **处理器架构管理**，例如CPU中断异常处理。
- **中断控制器管理**，例如IRQ中断号的映射。
- Linux内核**通用中断处理器层**，例如**中断注册**和**中断处理**。

**不同的体系结构**对中断控制器有着**不同的设计理念**，例如**ARM**公司提供了一个**通用的中断控制器GIC** (Generic Interrupt Controller), **x86**体系架构则采用**APIC控制器**(Advanced Programmable Interrupt Controller)。目前最新版本的GIC技术规范是 version 3/4, version2 通常在ARMv7架构处理器中使用，例如CortexA7 和 CortexA9 等，它最多可以支持8 核；Version3 和 version4 则支持ARMV8架构，例如CortexA53等。本文以ARMVexpress平台®为例来介绍中断管理的实现，它支持GIC Version 2 版本。

# 1 ARM中断控制器

ARM Vexpress V2P\-CA15\_CA7 平台支持 CortexA 15 和Cortex A7 两个CPU cluster, 中断控制器采用GI04 0 0 控制器，支持GIC version 2技术规范，如图5.1所示，GIC-V 2规范支持如下中断类型。

- SGI 软件触发中断（Software Generated Interrupt)，通常用于多核之间通讯。最多支持16个 SGI中断,硬件中断号从ID0 〜 ID15。SGI通常在Linux内核中被用作IPI中 断 （inter-process interrupts)，并会送达到系统指定的C P U 上。
- PIH私有外设中断（Private Peripheral Interrupt)，这是每个处理核心私有的中断。最多支持16个PPI中断，硬件中断号从ID16〜ID31。PPI通常会送达到指定的C P U 上，应用场景有C P U 本地时钟（local timer)。
- SPI外设中断（Shared Peripheral Interrupt)，公用的外设中断。最多可以支持988个外设中断，硬件中断号从ID32〜ID1019。

![config](./images/1.png)

......................

# 2 硬件中断号和Linux中断号的映射

**注册中断**API函数**request\_irq**()/ **request\_threaded\_irq**()是使用Linux内核**软件中断号**（俗称软件中断号或IRQ中断号），而**不是硬件中断号(！！！**)。

```c
/* include/linux/interrupt.h */
int request_threaded_irq (unsigned int irq,  irq_handler_t handler,
                irq_handler_t thread_fn, unsigned long irqflags,
                const char *devname, void *dev_id)
```

其中，**参数irq**在Linux内核中称为**IRQ number或 interrpt line**，这是一个Linux内核管理的**虚拟中断号**，并**不是指硬件的中断号**。

内核中有一个**宏NR\_IRQS**来表示系统支持**中断数量的最大值**，NR\_IRQS和**平台相关**.

例如VexpressV2P\-CA15\_CA7平台的定义。

```c++
/* [arch/arm/mach-versatile/include/mach/irqs.h] */

#define IRQ_SIC_END  95
#define NR_IRQS  (IRQ_GPI03_END + 1)
```

在x86平台

```c++
/* arch/x86/include/asm/irq_vectors.h */

#define NR_IRQS_LEGACY			16

#define CPU_VECTOR_LIMIT		(64 * NR_CPUS)
#define IO_APIC_VECTOR_LIMIT		(32 * MAX_IO_APICS)

#if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_PCI_MSI)
#define NR_IRQS						\
	(CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?	\
		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\
		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))
#elif defined(CONFIG_X86_IO_APIC)
#define	NR_IRQS				(NR_VECTORS + IO_APIC_VECTOR_LIMIT)
#elif defined(CONFIG_PCI_MSI)
#define NR_IRQS				(NR_VECTORS + CPU_VECTOR_LIMIT)
#else
#define NR_IRQS				NR_IRQS_LEGACY
#endif
```

此外, Linux内核定义了一个**位图**来管理这些**中断号**.

```c++
/* [kernel/irq/irqdesc.c] */

#define IRQ_BITMAP_BITS  NR_IRQS
static DECLARE_BITMAP (allocated_irqs, IRQ_BITMAP_BITS);
```

**位图变量allocated\_irqs**分配NR\_IRQS比特位（假设没设置**CONFIG\_SPARSE\_IRQ**),**每个比特位**表示**一个中断号**。

另外还有一个**硬件中断号**的概念，例如Vexpress V2P\-CA15\_CA7平台中的“串口 0”的硬件中断号是37。37的来由是因为GIC把0〜31的硬件中断号预留给了SGI和PPI, 因此外设中断号从第32号开始计算，“串口 0”设备在主板上的序号是5 , 因此该设备的硬件中断号为37。

接下来以“串口 0”设备为例，介绍**硬件中断号**是如何和**Linux内核**的**IRQ中断号**映射的.

**ARM平台**的**设备描述**基本上都采用**Device Tree的模式(简称DTS**),下面先看串口 0设备DTS的描述：

```
[arch/arm/boot/dts/vexpress-v2m.dtsi]

motherboard {
	model = "V2M-P1";
	arm,hbi = <0x190>;
	arm,vexpress,site = <0>;
	compatible = "arm,vexpress,v2m-p1", "simple-bus";
	...
	iofpga@7,00000000 {
		compatible = "arm,amba-bus", "simple-bus";  //总线
	    ...
	    
	    v2m_serial0: uart@09000 {
				compatible = "arm,pl011", "arm,primecell";
				reg = <0x09000 0x1000>;
				interrupts = <5>;   // 硬件中断号
				clocks = <&v2m_oscclk2>, <&smbclk>;
				clock-names = "uartclk", "apb_pclk";
			};
	};
};
```

Vexpress-v2m.dtsi文件描述了**主板上的外设**，其中**串口0设备**是一个符合“**arm,amba-bus**”总线的外设；“arm,pl011”和 “arm,primedell”是该外设的兼容字符串，用于和驱动程序进行匹配工作；**interrupts域**的值为5，表示在主板上为**第5号中断(硬件中断号！！！**)。

系统**初始化**时，**customize\_machine**()函数[arch/arm/kernel/setup.c]会去**枚举并初始化**“**arm,amba-bus**”和“**simple-bus**”**总线上的设备**，最终解析DTS中的相关信息，把**相关信息**添加到**struct device数据结构**中，向 Linux内核**注册一个新的外设**。我们只关注中断相关信息的枚举过程:

```c
[customize_machine() -> of_platform_populate() -> of_platform_bus_create() -> of_amba_device_create()]
customize_machine(): arch/arm/kernel/setup.c
of_platform_populate(): drivers/of/platform.c
of_platform_bus_create(): drivers/of/platform.c
of_amba_device_create(): drivers/of/platform.c

static struct amba_device *of_amba_device_create(struct device_node *node,
						 const char *bus_id,
						 void *platform_data,
						 struct device *parent)
{
    ...
    /* Decode the IRQs and address ranges */
	for (i = 0; i < AMBA_NR_IRQS; i++)
		dev->irq[i] = irq_of_parse_and_map(node, i);
		
	...
}	
```

核心函数是**irq\_of\_parse\_and\_map**(), **解析DTS中串口0设备的硬件中断号**，返回**Linux内核的IRQ中断号**，并保存到struct amba\_device数据结构中的irq()数组中。**串口驱动程序在pl011\_probe**()函数中直接从dev->irq[0]中获取**IRQ中断号**。

```c
[drivers/tty/serial/amba-pl011.c]
static int pl011_probe(struct amba_device *dev, const struct amba_id *id)
{
    ...
    uap->port.irq = dev->irq[0];
    ...   
}
```

接下来探讨**硬件中断号**是如何映射到**Linux IRQ中断号**的。

有开发过ARM7/ARM9的SoC经历的读者应该知道，**那时的SoC内部中断管理**比较简单，通常有一个全局的中断状态寄存器，每个比特位管理一个外设中断，**直接简单的映射硬件中断号到Linux IRQ中断号即可**。随着芯片硬件的发展，通常**一个SoC内部有多个中断控制器**，并且**每个中断控制器**管理的**中断源的数量变得越来越多**，例如包含一个**传统的中断控制器**（如GIC),另外还有一个**GPI0类型的中断控制器**。在一些复杂的SoC中，**多个中断控制器**还可以**级联**成一个树状结构。

面对如此复杂的硬件，原来Linux内核中的中断管理机制显得捉襟见肘，因此**Linux 3.1内核**引入了**irq domain的管理框架**。irq\_domain框架可以**支持多个中断控制器**，并且完美地**支持Device Tree机制**，解决**硬件中断号映射到Linux IRQ中断号**的问题。

**一个中断控制器**用一个**struct irq\_domain数据结构**来抽象描述，struct irq\_domain数据结构定义如下：

```c
[include/linux/irqdomain.h]

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;

	/* Optional data */
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_domain *parent;
#endif

	/* reverse map data. The linear map gets appended to the irq_domain */
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct radix_tree_root revmap_tree;
	unsigned int linear_revmap[];
};
```

- link: 用于将**irq domain**连接到**全局链表irq\_domain\_list**中。
- name： irq domain 的**名称**。
- ops: irq domain映射**操作使用的方法集合**。
- of\_node:对应**中断控制器的device node**。
- hwirq\_max: 该**irq domain**支持**中断数量的最大值**。
- revmap\_size: **线性映射的大小**。
- revmap tree: **Radix Tree 映射的根节点**。
- linear\_revmap:**线性映射用到的lookup table**。

**GIC中断控制器**在**初始化**时**解析DTS信息**中定义了**几个GIC控制器**，**每个GIC控制器**注册一个**irq\_domain数据结构**。**Drivers/irqchip目录**存放着**中断控制器的驱动代码**，其中, irq-gic.c文件是符合GIC-V2规范的驱动，irq-gic-v3.c文件是符合GIC-V3规范的驱动代码。在vexpress\-v2p\-cal5\_a7.dts文件中定义**了GIC中断控制器的相关DTS信息**。

```
[arch/arm/boot/dts/vexpress-v2p-ca15_a7.dts]

gic: interrupt-controller@2c001000 {
		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
		#interrupt-cells = <3>;
		#address-cells = <0>;
		interrupt-controller;  // 表明该设备是一个中断控制器
		reg = <0 0x2c001000 0 0x1000>,
		      <0 0x2c002000 0 0x1000>,
		      <0 0x2c004000 0 0x2000>,
		      <0 0x2c006000 0 0x2000>;
		interrupts = <1 9 0xf04>;
	};
```

系统**初始化**时会去查找DTS中**定义的中断控制器**，定义“**interrupt\-controller**”属性的设备表示是一个中断控制器，例如GIC中断控制器的标识符是“arm,cortex\-a15\-gic”或“arm,cortex\-a9\-gic".

```c
[drivers/irqchip/irq-gic.c]
IRQCHIP_DECLARE(cortex_a15_gic, "arm,cortex-a15-gic", gic_of_init);

[gic_of_init() -> __gic_init_bases()]
static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
			   void __iomem *dist_base, void __iomem *cpu_base,
			   u32 percpu_offset, struct device_node *node)
{
	irq_hw_number_t hwirq_base;
	struct gic_chip_data *gic;
	int gic_irqs, irq_base, i;
	...
	/*
	 * Find out how many interrupts are supported.
	 * The GIC only supports up to 1020 interrupt sources.
	 */
	// 计算GIC控制器最多支持的中断源的个数
	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) & 0x1f;
	gic_irqs = (gic_irqs + 1) * 32;
	if (gic_irqs > 1020)
		gic_irqs = 1020;
	gic->gic_irqs = gic_irqs;

	if (node) {		/* DT case */
		gic->domain = irq_domain_add_linear(node, gic_irqs,  //
						    &gic_irq_domain_hierarchy_ops,
						    gic);
```

计算GIC控制器最多支持的中断源的个数, GIC-V2规范中最多支持1020个中断源。在SoC芯片设计阶段就固定下来一个ARMSoC可以支持多少个中断源了，例如Vexpress V2P-CA15\_CA7平台支持160个中断源。

调用irq\_domain\_add\_linear()函数注册一个irq\_domain。

```c
[__gic_init_bases() -> irq_domain_add_linear() -> __irq_domain_add()]
[kernel/irq/irqdomain.c]
struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
				    irq_hw_number_t hwirq_max, int direct_max,
				    const struct irq_domain_ops *ops,
				    void *host_data)
{
	struct irq_domain *domain;

	domain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),
			      GFP_KERNEL, of_node_to_nid(of_node));

	/* Fill structure */
	INIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);
	domain->ops = ops;
	domain->host_data = host_data;
	domain->of_node = of_node_get(of_node);
	domain->hwirq_max = hwirq_max;
	domain->revmap_size = size;
	domain->revmap_direct_max_irq = direct_max;
	irq_domain_check_hierarchy(domain);

	mutex_lock(&irq_domain_mutex);
	list_add(&domain->link, &irq_domain_list);  // 加入全局链表
	mutex_unlock(&irq_domain_mutex);

	pr_debug("Added domain %s\n", domain->name);
	return domain;
}
EXPORT_SYMBOL_GPL(__irq_domain_add);
```

内部调用\_\_irq\_domain\_add()来初始化一个**irq\_domain数据结构**，注意domain除了指向的irq\_domain数据结构外，还**多了sizeof(unsigned int) \* size大小的内存空间**，用于linear\_revmap[]成员。最后，**irq\_domain**加入**全局的链表irq\_domain\_list** 中。

回到系统枚举阶段的中断号映射过程，在of\_amba\_device\_create()函数中，**irq\_of\_parse\_and\_map**()负责把**硬件中断号**映射到**Linux内核的IRQ中断号**中，该函数定义如下：

```c
[customize_machine() -> of_platform_populate() -> of_platform_bus_create() 
-> of_amba_device_create() -> irq_of_parse_and_map()]

[drivers/of/irq.c]

unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
{
	struct of_phandle_args oirq;

	if (of_irq_parse_one(dev, index, &oirq))
		return 0;

	return irq_create_of_mapping(&oirq);
}
EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
```

of\_irq\_parse\_one()主要用于解析**DTS文件**中**设备定义的属性**, 例如“reg” “interrupts” 等，最后把 DTS中的"**interrupts**"的值存放在oirq->args[1]中。例如，串口0设备的DTS中定义"interrupts”为5, 那么oirq->args[l]的值为5。

irq\_create\_of\_mapping()函数代码片段如下：

```c
[of_amba_device_create() -> irq_of_parse_and_map() -> irq_create_of_mapping()]

[kernel/irq/irqdomain.c]
unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
{
	struct irq_domain *domain;
	irq_hw_number_t hwirq;
	unsigned int type = IRQ_TYPE_NONE;
	int virq;

    // 位置1 找到外设所属的中断控制器
	domain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain; 

	/* If domain has no translation, then we assume interrupt line */
	if (domain->ops->xlate == NULL)
		hwirq = irq_data->args[0];
	else {
	    // 位置2
		if (domain->ops->xlate(domain, irq_data->np, irq_data->args,
					irq_data->args_count, &hwirq, &type))
			return 0;
	}

	if (irq_domain_is_hierarchy(domain)) {
		/*
		 * If we've already configured this interrupt,
		 * don't do it again, or hell will break loose.
		 */
		// 位置3
		virq = irq_find_mapping(domain, hwirq);
		if (virq)
			return virq;
        // 位置4
		virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, irq_data);
		if (virq <= 0)
			return 0;
	} else {
		/* Create mapping */
		virq = irq_create_mapping(domain, hwirq);
		if (!virq)
			return virq;
	}

	/* Set type if specified and different than the current one */
	if (type != IRQ_TYPE_NONE &&
	    type != irq_get_trigger_type(virq))
		irq_set_irq_type(virq, type);
	return virq;
}
EXPORT_SYMBOL_GPL(irq_create_of_mapping);
```

位置1, 通过**device node**找到**外设所属**的**中断控制器的irq\_domain**. **每个irq\_domain**都定义了一系列的**映射相关的方法集合**，例如**GIC\-V2**定义的方法集如下：

```c
[drivers/irqchip/irq-gic.c]

static const struct irq_domain_ops gic_irq_domain_hierarchy_ops = {
	.xlate = gic_irq_domain_xlate,
	.alloc = gic_irq_domain_alloc,
	.free = irq_domain_free_irqs_top,
};
```

其中，**xlate方法**是**翻译（translate**) 的意思，通过**一个device tree节点**和**DTS脚本**中的**中断信息**解码出**硬件的中断号和中断触发类型**，这些中断信息包括DTS脚本中描述的外设的interrupts域等。

位置2, 调用GIC-V2中的**xlate方法**进行**硬件中断号的转换**。对于**GIC\-V2**来说, 由于**第0〜31号硬件中断**是**预留给SGI和 PPI使用**的，外设中断不能使用这些中断号，所以gic\_irq\_domain\_xlate()函数会把**外设硬件中断号加上32**。对于串口0设备来说，它的硬件中断号应该是32+5=37。**hwirq**存储着这个**硬件中断号**，**type**是该**外设的中断类型**。

位置3，如果这个**硬件中断号己经映射过**了，那么**irq\_find\_mapping**()可以找到**映射后的软件中断号**，在此情景下，该硬件中断号还没有映射。

位置4, **irq\_domain\_alloc\_irqs**()函数是**映射的核心函数**，内部调用\_\_irq\_domain\_alloc\_irqs()函数。

```c
[irq_create_of_mapping -> irq_domain_alloc_irqs() -> __irq_domain_alloc_irqs()]

[kernel/irq/irqdomain.c]
int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
			    unsigned int nr_irqs, int node, void *arg,
			    bool realloc)
{
	int i, ret, virq;
    // 位置1
	virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node);
	if (virq < 0) {
		pr_debug("cannot allocate IRQ(base %d, count %d)\n",
			 irq_base, nr_irqs);
		return virq;
	}
	

	if (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {
		pr_debug("cannot allocate memory for IRQ%d\n", virq);
		ret = -ENOMEM;
		goto out_free_desc;
	}

	mutex_lock(&irq_domain_mutex);
	// 位置2
	ret = irq_domain_alloc_irqs_recursive(domain, virq, nr_irqs, arg);
	if (ret < 0) {
		mutex_unlock(&irq_domain_mutex);
		goto out_free_irq_data;
	}
	for (i = 0; i < nr_irqs; i++)
	    // 位置3
		irq_domain_insert_irq(virq + i);
	mutex_unlock(&irq_domain_mutex);

	return virq;
}
```

位置1, irq\_domain\_alloc\_descs()函数要从**allocated\_irqs位图**中**查找第一个空闲的比特位**，最终调用到\_\_irq\_alloc\_descs()函数.

```c
[kernel/irq/irqdesc.c]
int __ref
__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
		  struct module *owner)
{
	int start, ret;

	mutex_lock(&sparse_irq_lock);

	start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,
					   from, cnt, 0);
	
	bitmap_set(allocated_irqs, start, cnt);
	mutex_unlock(&sparse_irq_lock);
	return alloc_descs(start, cnt, node, owner);

}
EXPORT_SYMBOL_GPL(__irq_alloc_descs);
```

**bitmap\_find\_next\_zero\_area**函数在**allocated\_irqs位图**中查找**第一个连续cnt个为0**的比特位区域。**bitmap\_set**()函数设置这些比特位，表示这些比特位**已经被占用**。

**alloc\_descs**()函数用于分配一个**struct irq\_desc数据结构**，该数据结构用于描述**中断描述符**，后续会详细介绍。

内核中有**两种方式**来分配**struct irq\_desc数据结构**

- 一是内核配置了**CONFIG\_SPARSE\_IRQ**选项，那么会采用**Radix Tree**的方式来存储这些数据结构；
- 二是采用数组的方式，这是内核在早期釆用的方法，即定义一个**全局的数组**，**每个中断**对应一个**struct irq\_desc**。

下面以后者举例：

```c
[kernel/irq/irqdesc.c]

struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
	[0 ... NR_IRQS-1] = {
		.handle_irq	= handle_bad_irq,
		.depth		= 1,
		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),
	}
};
```

irq\_desc[]数组定义了NR\_IRQS个中断描述符，数组下标表示IRQ中断号，通过**IRQ中断号**可以找到**相应的中断描述符**。struct irq\_deSC数据结构定义了很多有用的成员，**先来看和映射相关**的。

```c
[include/linux/irqdesc.h]
struct irq_desc {
	struct irq_data		irq_data;
	const char		*name;
	irq_flow_handler_t	handle_irq;
    ...
}
    
[include/linux/irq.h]
struct irq_data {
	u32			mask;
	unsigned int		irq;
	unsigned long		hwirq;
	struct irq_chip		*chip;
	struct irq_domain	*domain;
};
```

struct irq\_desc数据结构内置了struct irq\_data结构体，struct irq\_data结构体成员**irq指软件中断号**，**hwirq指硬件中断号**。如果把这两个成员填写完成，即**完成了硬件中断号到软件中断号的映射**。

irq\_domain\_alloc\_descs()函数返回**allocated\_irqs位图**中**第一个空闲的比特位**，这是**软件中断号**。

回到上面, 位置2, irq\_domain\_alloc\_irqs\_recursive()函数调用irq\_domain中的alloc回调函数进行硬件中断号和软件中断号的映射.