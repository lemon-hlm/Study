[TOC]

阅读前思考:

- 发生**硬件中断后**，ARM**处理器**做了哪些事情？
- **硬件中断号**和Linux内核的**IRQ中断号**是如何映射的？
- 一个**硬件中断发生**后，Linux**内核**如何响应并处理该中断？
- 为什么说**中断上下文不能执行睡眠操作**？

Linux内核支持**众多的处理器体系结构**，因此从**系统角度**来看，Linux内核中断管理可以分成如下4层。

- **硬件层**，例如CPU和中断控制器的连接。
- **处理器架构管理**，例如CPU中断异常处理。
- **中断控制器管理**，例如IRQ中断号的映射。
- Linux内核**通用中断处理器层**，例如**中断注册**和**中断处理**。

**不同的体系结构**对中断控制器有着**不同的设计理念**，例如**ARM**公司提供了一个**通用的中断控制器GIC** (Generic Interrupt Controller), **x86**体系架构则采用**APIC控制器**(Advanced Programmable Interrupt Controller)。

目前最新版本的**GIC**技术规范是**version 3/4**, version2通常在ARMv7架构处理器中使用，例如CortexA7 和 CortexA9 等，它最多可以支持8 核；Version3 和 version4 则支持ARMV8架构，例如CortexA53等。本文以ARMVexpress平台为例来介绍中断管理的实现，它支持**GIC Version 2**版本。

# 1 ARM中断控制器

ARM Vexpress V2P\-CA15\_CA7 平台支持 CortexA 15 和Cortex A7 两个CPU cluster, 中断控制器采用GI04 0 0 控制器，支持GIC version 2技术规范，如图5.1所示，GIC-V 2规范支持如下中断类型。

- SGI 软件触发中断（Software Generated Interrupt)，通常用于多核之间通讯。最多支持16个 SGI中断,硬件中断号从ID0 〜 ID15。SGI通常在Linux内核中被用作IPI中 断 （inter-process interrupts)，并会送达到系统指定的C P U 上。
- PIH私有外设中断（Private Peripheral Interrupt)，这是每个处理核心私有的中断。最多支持16个PPI中断，硬件中断号从ID16〜ID31。PPI通常会送达到指定的C P U 上，应用场景有C P U 本地时钟（local timer)。
- SPI外设中断（Shared Peripheral Interrupt)，公用的外设中断。最多可以支持988个外设中断，硬件中断号从ID32〜ID1019。

![config](./images/1.png)

......................

# 2 硬件中断号和Linux中断号的映射

**注册中断**API函数**request\_irq**()/ **request\_threaded\_irq**()是使用Linux内核**软件中断号**（俗称软件中断号或IRQ中断号），而**不是硬件中断号(！！！**)。

```c
/* include/linux/interrupt.h */
int request_threaded_irq (unsigned int irq,  irq_handler_t handler,
                irq_handler_t thread_fn, unsigned long irqflags,
                const char *devname, void *dev_id)
```

其中，**参数irq**在Linux内核中称为**IRQ number或 interrpt line**，这是一个Linux内核管理的**虚拟中断号**，并**不是指硬件的中断号**。

内核中有一个**宏NR\_IRQS**来表示系统支持**中断数量的最大值**，NR\_IRQS和**平台相关**.

例如VexpressV2P\-CA15\_CA7平台的定义。

```c++
/* [arch/arm/mach-versatile/include/mach/irqs.h] */

#define IRQ_SIC_END  95
#define NR_IRQS  (IRQ_GPI03_END + 1)
```

在x86平台

```c++
/* arch/x86/include/asm/irq_vectors.h */

#define NR_IRQS_LEGACY			16

#define CPU_VECTOR_LIMIT		(64 * NR_CPUS)
#define IO_APIC_VECTOR_LIMIT		(32 * MAX_IO_APICS)

#if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_PCI_MSI)
#define NR_IRQS						\
	(CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?	\
		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\
		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))
#elif defined(CONFIG_X86_IO_APIC)
#define	NR_IRQS				(NR_VECTORS + IO_APIC_VECTOR_LIMIT)
#elif defined(CONFIG_PCI_MSI)
#define NR_IRQS				(NR_VECTORS + CPU_VECTOR_LIMIT)
#else
#define NR_IRQS				NR_IRQS_LEGACY
#endif
```

此外, Linux内核定义了一个**位图**来管理这些**中断号**.

```c++
/* [kernel/irq/irqdesc.c] */

#define IRQ_BITMAP_BITS  NR_IRQS
static DECLARE_BITMAP (allocated_irqs, IRQ_BITMAP_BITS);
```

**位图变量allocated\_irqs**分配NR\_IRQS比特位（假设没设置**CONFIG\_SPARSE\_IRQ**),**每个比特位**表示**一个中断号**。

另外还有一个**硬件中断号**的概念，例如Vexpress V2P\-CA15\_CA7平台中的“串口 0”的硬件中断号是37。37的来由是因为GIC把0〜31的硬件中断号预留给了SGI和PPI, 因此外设中断号从第32号开始计算，“串口 0”设备在主板上的序号是5 , 因此该设备的硬件中断号为37。

接下来以“串口 0”设备为例，介绍**硬件中断号**是如何和**Linux内核**的**IRQ中断号**映射的.

**ARM平台**的**设备描述**基本上都采用**Device Tree的模式(简称DTS**),下面先看串口 0设备DTS的描述：

```
[arch/arm/boot/dts/vexpress-v2m.dtsi]

motherboard {
	model = "V2M-P1";
	arm,hbi = <0x190>;
	arm,vexpress,site = <0>;
	compatible = "arm,vexpress,v2m-p1", "simple-bus";
	...
	iofpga@7,00000000 {
		compatible = "arm,amba-bus", "simple-bus";  //总线
	    ...
	    
	    v2m_serial0: uart@09000 {
				compatible = "arm,pl011", "arm,primecell";
				reg = <0x09000 0x1000>;
				interrupts = <5>;   // 硬件中断号
				clocks = <&v2m_oscclk2>, <&smbclk>;
				clock-names = "uartclk", "apb_pclk";
			};
	};
};
```

Vexpress-v2m.dtsi文件描述了**主板上的外设**，其中**串口0设备**是一个符合“**arm,amba-bus**”总线的外设；“arm,pl011”和 “arm,primedell”是该外设的兼容字符串，用于和驱动程序进行匹配工作；**interrupts域**的值为5，表示在主板上为**第5号中断(硬件中断号！！！**)。

系统**初始化**时，**customize\_machine**()函数[arch/arm/kernel/setup.c]会去**枚举并初始化**“**arm,amba-bus**”和“**simple-bus**”**总线上的设备**，最终解析DTS中的相关信息，把**相关信息**添加到**struct device数据结构**中，向 Linux内核**注册一个新的外设**。我们只关注中断相关信息的枚举过程:

```c
[customize_machine() -> of_platform_populate() -> of_platform_bus_create() -> of_amba_device_create()]
customize_machine(): arch/arm/kernel/setup.c
of_platform_populate(): drivers/of/platform.c
of_platform_bus_create(): drivers/of/platform.c
of_amba_device_create(): drivers/of/platform.c

static struct amba_device *of_amba_device_create(struct device_node *node,
						 const char *bus_id,
						 void *platform_data,
						 struct device *parent)
{
    ...
    /* Decode the IRQs and address ranges */
	for (i = 0; i < AMBA_NR_IRQS; i++)
		dev->irq[i] = irq_of_parse_and_map(node, i);
		
	...
}	
```

核心函数是**irq\_of\_parse\_and\_map**(), **解析DTS中串口0设备的硬件中断号**，返回**Linux内核的IRQ中断号**，并保存到struct amba\_device数据结构中的irq()数组中。**串口驱动程序在pl011\_probe**()函数中直接从dev->irq[0]中获取**IRQ中断号**。

```c
[drivers/tty/serial/amba-pl011.c]
static int pl011_probe(struct amba_device *dev, const struct amba_id *id)
{
    ...
    uap->port.irq = dev->irq[0];
    ...   
}
```

接下来探讨**硬件中断号**是如何映射到**Linux IRQ中断号**的。

有开发过ARM7/ARM9的SoC经历的读者应该知道，**那时的SoC内部中断管理**比较简单，通常有一个全局的中断状态寄存器，每个比特位管理一个外设中断，**直接简单的映射硬件中断号到Linux IRQ中断号即可**。随着芯片硬件的发展，通常**一个SoC内部有多个中断控制器**，并且**每个中断控制器**管理的**中断源的数量变得越来越多**，例如包含一个**传统的中断控制器**（如GIC),另外还有一个**GPI0类型的中断控制器**。在一些复杂的SoC中，**多个中断控制器**还可以**级联**成一个树状结构。

面对如此复杂的硬件，原来Linux内核中的中断管理机制显得捉襟见肘，因此**Linux 3.1内核**引入了**irq domain的管理框架**。irq\_domain框架可以**支持多个中断控制器**，并且完美地**支持Device Tree机制**，解决**硬件中断号映射到Linux IRQ中断号**的问题。

**一个中断控制器**用一个**struct irq\_domain数据结构**来抽象描述，struct irq\_domain数据结构定义如下：

```c
[include/linux/irqdomain.h]

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;

	/* Optional data */
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_domain *parent;
#endif

	/* reverse map data. The linear map gets appended to the irq_domain */
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct radix_tree_root revmap_tree;
	unsigned int linear_revmap[];
};
```

- link: 用于将**irq domain**连接到**全局链表irq\_domain\_list**中。
- name： irq domain 的**名称**。
- ops: irq domain映射**操作使用的方法集合**。
- of\_node:对应**中断控制器的device node**。
- hwirq\_max: 该**irq domain**支持**中断数量的最大值**。
- revmap\_size: **线性映射的大小**。
- revmap tree: **Radix Tree 映射的根节点**。
- linear\_revmap:**线性映射用到的lookup table**。

**GIC中断控制器**在**初始化**时**解析DTS信息**中定义了**几个GIC控制器**，**每个GIC控制器**注册一个**irq\_domain数据结构**。**Drivers/irqchip目录**存放着**中断控制器的驱动代码**，其中, irq-gic.c文件是符合GIC-V2规范的驱动，irq-gic-v3.c文件是符合GIC-V3规范的驱动代码。在vexpress\-v2p\-cal5\_a7.dts文件中定义**了GIC中断控制器的相关DTS信息**。

```
[arch/arm/boot/dts/vexpress-v2p-ca15_a7.dts]

gic: interrupt-controller@2c001000 {
		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
		#interrupt-cells = <3>;
		#address-cells = <0>;
		interrupt-controller;  // 表明该设备是一个中断控制器
		reg = <0 0x2c001000 0 0x1000>,
		      <0 0x2c002000 0 0x1000>,
		      <0 0x2c004000 0 0x2000>,
		      <0 0x2c006000 0 0x2000>;
		interrupts = <1 9 0xf04>;
	};
```

系统**初始化**时会去查找DTS中**定义的中断控制器**，定义“**interrupt\-controller**”属性的设备表示是一个中断控制器，例如GIC中断控制器的标识符是“arm,cortex\-a15\-gic”或“arm,cortex\-a9\-gic".

```c
[drivers/irqchip/irq-gic.c]
IRQCHIP_DECLARE(cortex_a15_gic, "arm,cortex-a15-gic", gic_of_init);

[gic_of_init() -> __gic_init_bases()]
static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
			   void __iomem *dist_base, void __iomem *cpu_base,
			   u32 percpu_offset, struct device_node *node)
{
	irq_hw_number_t hwirq_base;
	struct gic_chip_data *gic;
	int gic_irqs, irq_base, i;
	...
	/*
	 * Find out how many interrupts are supported.
	 * The GIC only supports up to 1020 interrupt sources.
	 */
	// 计算GIC控制器最多支持的中断源的个数
	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) & 0x1f;
	gic_irqs = (gic_irqs + 1) * 32;
	if (gic_irqs > 1020)
		gic_irqs = 1020;
	gic->gic_irqs = gic_irqs;

	if (node) {		/* DT case */
		gic->domain = irq_domain_add_linear(node, gic_irqs,  //
						    &gic_irq_domain_hierarchy_ops,
						    gic);
```

计算GIC控制器最多支持的中断源的个数, GIC-V2规范中最多支持1020个中断源。在SoC芯片设计阶段就固定下来一个ARMSoC可以支持多少个中断源了，例如Vexpress V2P-CA15\_CA7平台支持160个中断源。

调用irq\_domain\_add\_linear()函数注册一个irq\_domain。

```c
[__gic_init_bases() -> irq_domain_add_linear() -> __irq_domain_add()]
[kernel/irq/irqdomain.c]
struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
				    irq_hw_number_t hwirq_max, int direct_max,
				    const struct irq_domain_ops *ops,
				    void *host_data)
{
	struct irq_domain *domain;

	domain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),
			      GFP_KERNEL, of_node_to_nid(of_node));

	/* Fill structure */
	INIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);
	domain->ops = ops;
	domain->host_data = host_data;
	domain->of_node = of_node_get(of_node);
	domain->hwirq_max = hwirq_max;
	domain->revmap_size = size;
	domain->revmap_direct_max_irq = direct_max;
	irq_domain_check_hierarchy(domain);

	mutex_lock(&irq_domain_mutex);
	list_add(&domain->link, &irq_domain_list);  // 加入全局链表
	mutex_unlock(&irq_domain_mutex);

	pr_debug("Added domain %s\n", domain->name);
	return domain;
}
EXPORT_SYMBOL_GPL(__irq_domain_add);
```

内部调用\_\_irq\_domain\_add()来初始化一个**irq\_domain数据结构**，注意domain除了指向的irq\_domain数据结构外，还**多了sizeof(unsigned int) \* size大小的内存空间**，用于linear\_revmap[]成员。最后，**irq\_domain**加入**全局的链表irq\_domain\_list** 中。

回到系统枚举阶段的中断号映射过程，在of\_amba\_device\_create()函数中，**irq\_of\_parse\_and\_map**()负责把**硬件中断号**映射到**Linux内核的IRQ中断号**中，该函数定义如下：

```c
[customize_machine() -> of_platform_populate() -> of_platform_bus_create() 
-> of_amba_device_create() -> irq_of_parse_and_map()]

[drivers/of/irq.c]

unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
{
	struct of_phandle_args oirq;

	if (of_irq_parse_one(dev, index, &oirq))
		return 0;

	return irq_create_of_mapping(&oirq);
}
EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
```

of\_irq\_parse\_one()主要用于解析**DTS文件**中**设备定义的属性**, 例如“reg” “interrupts” 等，最后把 DTS中的"**interrupts**"的值存放在oirq->args[1]中。例如，串口0设备的DTS中定义"interrupts”为5, 那么oirq->args[l]的值为5。

irq\_create\_of\_mapping()函数代码片段如下：

```c
[of_amba_device_create() -> irq_of_parse_and_map() -> irq_create_of_mapping()]

[kernel/irq/irqdomain.c]
unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
{
	struct irq_domain *domain;
	irq_hw_number_t hwirq;
	unsigned int type = IRQ_TYPE_NONE;
	int virq;

    // 位置1 找到外设所属的中断控制器
	domain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain; 

	/* If domain has no translation, then we assume interrupt line */
	if (domain->ops->xlate == NULL)
		hwirq = irq_data->args[0];
	else {
	    // 位置2
		if (domain->ops->xlate(domain, irq_data->np, irq_data->args,
					irq_data->args_count, &hwirq, &type))
			return 0;
	}

	if (irq_domain_is_hierarchy(domain)) {
		/*
		 * If we've already configured this interrupt,
		 * don't do it again, or hell will break loose.
		 */
		// 位置3
		virq = irq_find_mapping(domain, hwirq);
		if (virq)
			return virq;
        // 位置4
		virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, irq_data);
		if (virq <= 0)
			return 0;
	} else {
		/* Create mapping */
		virq = irq_create_mapping(domain, hwirq);
		if (!virq)
			return virq;
	}

	/* Set type if specified and different than the current one */
	if (type != IRQ_TYPE_NONE &&
	    type != irq_get_trigger_type(virq))
		irq_set_irq_type(virq, type);
	return virq;
}
EXPORT_SYMBOL_GPL(irq_create_of_mapping);
```

位置1, 通过**device node**找到**外设所属**的**中断控制器的irq\_domain**. **每个irq\_domain**都定义了一系列的**映射相关的方法集合**，例如**GIC\-V2**定义的方法集如下：

```c
[drivers/irqchip/irq-gic.c]

static const struct irq_domain_ops gic_irq_domain_hierarchy_ops = {
	.xlate = gic_irq_domain_xlate,
	.alloc = gic_irq_domain_alloc,
	.free = irq_domain_free_irqs_top,
};
```

其中，**xlate方法**是**翻译（translate**) 的意思，通过**一个device tree节点**和**DTS脚本**中的**中断信息**解码出**硬件的中断号和中断触发类型**，这些中断信息包括DTS脚本中描述的外设的interrupts域等。

位置2, 调用GIC-V2中的**xlate方法**进行**硬件中断号的转换**。对于**GIC\-V2**来说, 由于**第0〜31号硬件中断**是**预留给SGI和 PPI使用**的，外设中断不能使用这些中断号，所以gic\_irq\_domain\_xlate()函数会把**外设硬件中断号加上32**。对于串口0设备来说，它的硬件中断号应该是32+5=37。**hwirq**存储着这个**硬件中断号**，**type**是该**外设的中断类型**。

位置3，如果这个**硬件中断号己经映射过**了，那么**irq\_find\_mapping**()可以找到**映射后的软件中断号**，在此情景下，该硬件中断号还没有映射。

位置4, **irq\_domain\_alloc\_irqs**()函数是**映射的核心函数**，内部调用\_\_irq\_domain\_alloc\_irqs()函数。

```c
[irq_create_of_mapping -> irq_domain_alloc_irqs() -> __irq_domain_alloc_irqs()]

[kernel/irq/irqdomain.c]
int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
			    unsigned int nr_irqs, int node, void *arg,
			    bool realloc)
{
	int i, ret, virq;
    // 位置1
	virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node);
	if (virq < 0) {
		pr_debug("cannot allocate IRQ(base %d, count %d)\n",
			 irq_base, nr_irqs);
		return virq;
	}
	

	if (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {
		pr_debug("cannot allocate memory for IRQ%d\n", virq);
		ret = -ENOMEM;
		goto out_free_desc;
	}

	mutex_lock(&irq_domain_mutex);
	// 位置2
	ret = irq_domain_alloc_irqs_recursive(domain, virq, nr_irqs, arg);
	if (ret < 0) {
		mutex_unlock(&irq_domain_mutex);
		goto out_free_irq_data;
	}
	for (i = 0; i < nr_irqs; i++)
	    // 位置3
		irq_domain_insert_irq(virq + i);
	mutex_unlock(&irq_domain_mutex);

	return virq;
}
```

位置1, irq\_domain\_alloc\_descs()函数要从**allocated\_irqs位图**中**查找第一个空闲的比特位**，最终调用到\_\_irq\_alloc\_descs()函数.

```c
[kernel/irq/irqdesc.c]
int __ref
__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
		  struct module *owner)
{
	int start, ret;

	mutex_lock(&sparse_irq_lock);

	start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,
					   from, cnt, 0);
	
	bitmap_set(allocated_irqs, start, cnt);
	mutex_unlock(&sparse_irq_lock);
	return alloc_descs(start, cnt, node, owner);

}
EXPORT_SYMBOL_GPL(__irq_alloc_descs);
```

**bitmap\_find\_next\_zero\_area**函数在**allocated\_irqs位图**中查找**第一个连续cnt个为0**的比特位区域。**bitmap\_set**()函数设置这些比特位，表示这些比特位**已经被占用**。

**alloc\_descs**()函数用于分配一个**struct irq\_desc数据结构**，该数据结构用于描述**中断描述符**，后续会详细介绍。

内核中有**两种方式**来分配**struct irq\_desc数据结构**

- 一是内核配置了**CONFIG\_SPARSE\_IRQ**选项，那么会采用**Radix Tree**的方式来存储这些数据结构；
- 二是采用数组的方式，这是内核在早期釆用的方法，即定义一个**全局的数组**，**每个中断**对应一个**struct irq\_desc**。

下面以后者举例：

```c
[kernel/irq/irqdesc.c]

struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
	[0 ... NR_IRQS-1] = {
		.handle_irq	= handle_bad_irq,
		.depth		= 1,
		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),
	}
};
```

irq\_desc[]数组定义了NR\_IRQS个中断描述符，数组下标表示IRQ中断号，通过**IRQ中断号**可以找到**相应的中断描述符**。struct irq\_deSC数据结构定义了很多有用的成员，**先来看和映射相关**的。

```c
[include/linux/irqdesc.h]
struct irq_desc {
	struct irq_data		irq_data;
	const char		*name;
	irq_flow_handler_t	handle_irq;
    ...
}
    
[include/linux/irq.h]
struct irq_data {
	u32			mask;
	unsigned int		irq;
	unsigned long		hwirq;
	struct irq_chip		*chip;
	struct irq_domain	*domain;
};
```

struct irq\_desc数据结构内置了struct irq\_data结构体，struct irq\_data结构体成员**irq指软件中断号**，**hwirq指硬件中断号**。如果把这两个成员填写完成，即**完成了硬件中断号到软件中断号的映射**。

irq\_domain\_alloc\_descs()函数返回**allocated\_irqs位图**中**第一个空闲的比特位**，这是**软件中断号**。

回到上面, 位置2, irq\_domain\_alloc\_irqs\_recursive()函数调用**irq\_domain**中的**alloc回调函数**进行**硬件中断号和软件中断号的映射**.

```c
[irq_create_of_mapping -> irq_domain_alloc_irqs() -> __irq_domain_alloc_irqs() 
-> irq_domain_alloc_irqs_recursive() -> gic_irq_domain_alloc]

[drivers/irqchip/irq-gic.c]
static int gic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
				unsigned int nr_irqs, void *arg)
{
	int i, ret;
	irq_hw_number_t hwirq;
	unsigned int type = IRQ_TYPE_NONE;
	struct irq_fwspec *fwspec = arg;

	ret = gic_irq_domain_xlate(domain, fwspec, &hwirq, &type);
	if (ret)
		return ret;

	for (i = 0; i < nr_irqs; i++)
		gic_irq_domain_map(domain, virq + i, hwirq + i);

	return 0;
}
```

gic\_irq\_domain\_xlate()函数己在前又中介绍，最后解析出**硬件中断号存放在hwirq中**，gic\_irq\_domain\_map()函数做**映射**工作。

```c
[drivers/irqchip/irq-gic.c]
static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq,
				irq_hw_number_t hw)
{
	if (hw < 32) {
	    //位置1
		irq_set_percpu_devid(irq);
		irq_domain_set_info(d, irq, hw, &gic_chip, d->host_data,
				    handle_percpu_devid_irq, NULL, NULL);
		set_irq_flags(irq, IRQF_VALID | IRQF_NOAUTOEN);
	} else {
	    // 位置2
		irq_domain_set_info(d, irq, hw, &gic_chip, d->host_data,
				    handle_fasteoi_irq, NULL, NULL);
		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);

		gic_routable_irq_domain_ops->map(d, irq, hw);
	}
	return 0;
}
```

参数hw指硬件中断号，位置1的if中代码是处理系统预留给SGI和 PPI中断类型，位置2的else中代码是处理SPI类型的外设中断。irq\_domain\_set\_info()函数会设置一些很重要的参数到中断描述符中。

```c
[kernel/irq/irqdomain.c]
void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
			 irq_hw_number_t hwirq, struct irq_chip *chip,
			 void *chip_data, irq_flow_handler_t handler,
			 void *handler_data, const char *handler_name)
{
	irq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);
	__irq_set_handler(virq, handler, 0, handler_name);
	irq_set_handler_data(virq, handler_data);
}
```

先看irq\_domain\_set\_hwirq\_and\_chip()函数

```c
[kernel/irq/irqdomain.c]
int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,
				  irq_hw_number_t hwirq, struct irq_chip *chip,
				  void *chip_data)
{
	struct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);

	if (!irq_data)
		return -ENOENT;

	irq_data->hwirq = hwirq;
	irq_data->chip = chip ? chip : &no_irq_chip;
	irq_data->chip_data = chip_data;

	return 0;
}
```

通过**IRQ中断号**获取**struct irq\_data数据结构**，然后把**硬件中断号hwirq**设置到struct irq\_data数据结构中的**hwirq成员**中，这样就完成了**硬件中断号**到**软件中断号的映射**。**参数chip**指**硬件中断控制器**的**struct irq\_chip**中定义的**与中断控制器底层**操作相关的**方法集合**。

```c
[include/linux/irq.h]
struct irq_chip {
	const char	*name;
	unsigned int	(*irq_startup)(struct irq_data *data);
	void		(*irq_shutdown)(struct irq_data *data);
	void		(*irq_enable)(struct irq_data *data);
	void		(*irq_disable)(struct irq_data *data);

	void		(*irq_ack)(struct irq_data *data);
	void		(*irq_mask)(struct irq_data *data);
	void		(*irq_mask_ack)(struct irq_data *data);
	void		(*irq_unmask)(struct irq_data *data);
	void		(*irq_eoi)(struct irq_data *data);

	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
	int		(*irq_retrigger)(struct irq_data *data);
	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type);
	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);

	void		(*irq_bus_lock)(struct irq_data *data);
	void		(*irq_bus_sync_unlock)(struct irq_data *data);

	void		(*irq_cpu_online)(struct irq_data *data);
	void		(*irq_cpu_offline)(struct irq_data *data);

	void		(*irq_suspend)(struct irq_data *data);
	void		(*irq_resume)(struct irq_data *data);
	void		(*irq_pm_shutdown)(struct irq_data *data);

	void		(*irq_calc_mask)(struct irq_data *data);

	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
	int		(*irq_request_resources)(struct irq_data *data);
	void		(*irq_release_resources)(struct irq_data *data);

	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);

	unsigned long	flags;
};
```

其中，比较常用的方法如下。

- irq\_startup: **初始化**一个中断。
- irq\_shutdown: **结束**一个中断。
- irq\_enable: 使能一个中断。
- irq\_disable: 关闭一个中断。
- irq\_ack: 应答一个中断。
- irq\_mask: 屏蔽一个中断源。
- irq\_mask\_ack: 应答并屏蔽该中断源。
- irq\_unmask: 解除一个中断源的屏蔽操作。
- irq\_eoi: 发送EOI信号给中断控制器，表示硬件中断处理己经完成。
- irq\_set\_affinity: 绑定一个中断到某个CPU上。
- irq\_retrigger: 重新发送中断到CPU上。
- irq\_set\_type: 设置中断触发类型。
- irq\_Set\_wake: 使能/关闭该中断在电源管理中的唤醒功能。
- irq\_bus\_lock: 函数指针，用于实现保护访问慢速设备的锁。

并**不是每个中断控制器**都需要实现struct irq\_chip中定义的**所有的方法集**，对于**GIC\-V2中断控制器**来说，实现的方法集如下：

```c
[drivers/irqchip/irq-gic.c]
static struct irq_chip gic_chip = {
	.name			= "GIC",
	.irq_mask		= gic_mask_irq,
	.irq_unmask		= gic_unmask_irq,
	.irq_eoi		= gic_eoi_irq,
	.irq_set_type		= gic_set_type,
	.irq_retrigger		= gic_retrigger,
#ifdef CONFIG_SMP
	.irq_set_affinity	= gic_set_affinity,
#endif
	.irq_set_wake		= gic_set_wake,
};
```

回到**irq\_domain\_set\_info**()函数中，**其中\_\_irq\_set\_handler**()用于设置**中断描述符desc->hander\_irq**的**回调函数**，对于**SPI类型**的外设中断来说，回调函数是**handle\_fasteoi\_irq**()。

如图5.3所示是**硬件中断号**和**软件中断号的整个映射过程**。

![config](./images/2.png)

# 3 注册中断

当一个外设中断发生后，内核会执行一个函数来响应该中断，这个函数通常被称为中断处理程序（interrupt handler) 或中断服务例程。**中断处理程序**是**内核用于响应中断(内核态运行！！！中断处理程序包括硬件中断处理程序和其下半部处理机制，包括中断线程化、软中断和workqueue等，这里特指硬件中断处理程序**)的,并且它运行在**中断上下文**中（**和进程上下文不同**）。

中断处理程序最基本的工作是**通知硬件设备**中断**己经被接收**，**不同的硬件设备**的**中断处理程序是不同**的，有的常常需要做很多的处理工作，这也是Linux内核把中断处理程序分成**上半部**和**下半部**的原因。

中断处理程序要求**快速完成**并且**退出中断**，但是如果中断处理程序需要完成的**任务比较繁重**，这两个需求就会有冲突，因此**上下半部机制**就诞生了。

在**编写外设驱动**时通常**需要注册中断**，注册中断的API如下：

```c
[include/linux/interrupt.h]
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
```

request\_irq()是比较旧的API接口，在Linux2.6.30中新增了**线程化的中断注册函数request\_threaded\_irq()**。中断线程化是实时Linux项目开发的一个新特性，目的是**降低中断处理对系统实时延迟的影响**。Linux内核已经把中断处理分成了上下半部，为什么还需要引入中断线程化机制呢？

在Linux内核里，**中断具有最高的优先级**，只要有中断发生，内核会暂停手头的工作转向中断处理，等到**所有挂起等待（pending)的中断和软中断处理完毕后(所有中断处理完成后！！！**)才会执行**进程调度**，因此这个过程会**造成实时任务得不到及时处理(！！！**)。**中断上下文总是抢占进程上下文(！！！**)，**中断上下文**不仅是**中断处理程序**,还包括**Softirq软中断**、**tasklet等**，中断上下文成了优化Linux实时性的最大挑战之一。

假设一个**高优先级任务**和一个**中断同时发生**，那么内核**首先执行中断处理程序(！！！**)，中断处理程序完成**之后有可能触发软中断(！！！**)，也可能**有一些tasklet任务**要执行或有**新的中断发生**，这样**高优先级任务的延迟**变得不可预测。**中断线程化**的目的是把**中断处理中**一些**繁重的任务**作为**内核线程来运行**，**实时进程**可以有**比中断线程更高的优先级(！！！**)。这样高优先级的实时进程可以得到优先处理，实时进程的延迟粒度变得小得多，当然**并不是所有的中断都可以线程化(！！！**)，例如**时钟中断**。

```c
[kernel/irq/manage.c]
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id)
```

- irq: IRQ中断号，注意这里使用的是**软件中断号**，而**不是硬件中断号**。
- handler: 指 **primary handler**, 有些类似于旧版本API函数request\_irq()的中断处理函数handler。中断发生时会**优先执行primary handler**。如果**primary handler为NULL**且**thread\_fn不为NULL**, 那么会执行系统**默认的 primary handler**: **irq\_default\_primary\_handler**()函数。
- thread\_fh: 中断**线程化的处理程序**。如果**thread\_fn不为NULL**, 那么会**创建一个内核线程**。primary handler和thread\_fn**不能同时为NULL**。
- irqflags: 中断**标志位**，如表5.2所示。
- devname: 该**中断名称**。
- dev_id: 传递给**中断处理程序的参数**。

![config](./images/3.png)

上述**前缀为“IRQF\_”描述**的中断标志位用于**申请中断时**描述**该中断的特性**。

前缀**为“IRQS\_”的**中断标志位是位于**struct irq\_desc**数据结构的**istate成员**，在 struct irq\_desc数据结构定义中是**core\_intemal\_state\_\_do\_not\_mess\_with\_it**成员，通过一个**宏**把它改名成istate。

```c
[kernel/irq/internals.h]
enum {
	IRQS_AUTODETECT		= 0x00000001,
	IRQS_SPURIOUS_DISABLED	= 0x00000002,
	IRQS_POLL_INPROGRESS	= 0x00000008,
	IRQS_ONESHOT		= 0x00000020,
	IRQS_REPLAY		= 0x00000040,
	IRQS_WAITING		= 0x00000080,
	IRQS_PENDING		= 0x00000200,
	IRQS_SUSPENDED		= 0x00000800,
};
```

- IRQS\_AUTODETECT : 表示**某个irq\_desc**处于**自动侦测状态**。
- IRQS\_WAITING: 表示某个irq\_desc处于等待状态。
- IRQS\_SPURIOUS\_DISABLED: 表示某个irq\_desc被视为“伪中断”并被禁用。
- IRQS\_POLL\_INPROGRESS: 表示某个irq\_desc正处于轮询调用action。
- IRQS\_ONESHOT: 表示**只执行一次**。
- IRQS\_REPLAY: 重新发一次中断。
- IRQS\_PENDING: 表示该**中断被挂起**。
- IRQS\_SUSPENDED:表示该中断被暂停。

本节最常用的两个标志位是**IRQS\_0NESH0T**和**IRQS\_PENDING**。

**IRQS\_0NESH0T标志位**是在**注册中断函数\_\_setup\_irq**()中由中断标志位**IRQF\_0NESH0T**转换过来的。在**中断线程化程序**执行完成后需要特别**小心对待**，见irq\_finalize\_oneshot()函数。

IRQS\_PENDING标志位在**handle\_fasteoi\_irq**()函数中，当**没有指定硬件中断处理函数**，或者**irq\_data**\->state\_use\_accessors中设置了**IRQD\_IRQ\_DISABLED**标志位，说明该**中断被禁用**了，这时需要**挂起该中断**。

struct **irq\_data**数据结构中的**state\_use\_accessors**成员也有**一组中断标志位**，以前缀“IRQD\_”开头，通常用于描述成层中断的状态，如下：

```c
[include/linux/irq.h]
enum {
	IRQD_TRIGGER_MASK		= 0xf,      // 常用
	IRQD_SETAFFINITY_PENDING	= (1 <<  8),
	IRQD_NO_BALANCING		= (1 << 10),
	IRQD_PER_CPU			= (1 << 11),
	IRQD_AFFINITY_SET		= (1 << 12),
	IRQD_LEVEL			= (1 << 13),
	IRQD_WAKEUP_STATE		= (1 << 14),
	IRQD_MOVE_PCNTXT		= (1 << 15),
	IRQD_IRQ_DISABLED		= (1 << 16),  // 常用
	IRQD_IRQ_MASKED			= (1 << 17),
	IRQD_IRQ_INPROGRESS		= (1 << 18),  // 常用
	IRQD_WAKEUP_ARMED		= (1 << 19),
};
```

- IRQD\_TRIGGER\_MASK: 表示中断**触发的类型**，例如上升沿触发或者下降沿触发等。
- IRQD\_IRQ\_DISABLED: 表示该中断处于**关闭状态**。
- IRQD\_IRQ\_INPROGRESS: 表示该中断**正在被处理**中。

下面从request\_threaded\_irq()来看注册中断的实现。

```
[kernel/irq/manage.c]
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id)
{
    struct irqaction *action;
	struct irq_desc *desc;
	int retval;

    // 位置1
	if (((irqflags & IRQF_SHARED) && !dev_id) ||
	    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||
	    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))
		return -EINVAL;
    // 位置2
	desc = irq_to_desc(irq);
	if (!desc)
		return -EINVAL;
    // 位置3
	if (!irq_settings_can_request(desc) ||
	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))
		return -EINVAL;
    // 位置4
	if (!handler) {
		if (!thread_fn)
			return -EINVAL;
		handler = irq_default_primary_handler;
	}
    // 位置5
	action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);

	action->handler = handler;
	action->thread_fn = thread_fn;
	action->flags = irqflags;
	action->name = devname;
	action->dev_id = dev_id;
    // 位置6
	chip_bus_lock(desc);
	retval = __setup_irq(irq, desc, action);
	chip_bus_sync_unlock(desc);

	return retval;
}
```

位置1是一个例行的检查，对于那些**共享中断的设备**来说，这里**强制要求传递一个参数dev\_id**。如果没有额外参数，中断处理程序**无法识别**出究竟是**哪个外设产生的中断**，通常根据**dev\_id**查询**设备寄存器**来确定是**哪个**共享外设的中断。

位置2，通过**IRQ中断号**获取**中断描述符**struct **irq\_desc**。

位置3，**irq\_settings\_can\_request**()判断**是否设置了\_IRQ\_NOREQUEST标志位**，它是**系统预留**的，外设**不可以使用**这些中断描述符。另外设置了\_IRQ\_PER\_CPU\_DEVID标志位的中断描述符是预留给**IRQF\_PERCPU类型的中断(属于特定某个CPU的中断！！！**)，应该使用**request\_percpu\_irq**()函数API**注册中断**。

位置4，primary handler和thread\_fn**不能同时为NULL**. 当primary handler为NULL时使用默认的handler, **irq\_default\_primary\_handler**()函数直接返回**IRQ\_WAKE\_THREAD(默认的直接返回, 用于快速响应, 然后让中断线程工作！！！**), 表示要**唤醒中断线程**。

位置5，分配一个**struct irqaction数据结构**，填充相应的成员。

位置6，调用\_\_**setup\_irq**()函数**继续注册中断**。chip\_bus\_lock()调用irq\_data.chip\->irq\_bus\_lock的回调函数进行**加锁保护**。对于GIC\-V2控制器来说，并没有定义irq\_bus\_lock回调函数。下面继续介绍.

**struct irqaction数据结构**是每个中断**irqaction的描述符**.

```c
[include/linux/interrupt.h]
struct irqaction {
	irq_handler_t		handler;
	void			*dev_id;
	struct irqaction	*next;
	irq_handler_t		thread_fn;
	struct task_struct	*thread;
	unsigned int		irq;
	unsigned int		flags;
	unsigned long		thread_flags;
	unsigned long		thread_mask;
	const char		*name;
} ____cacheline_internodealigned_in_smp;
```

- handler: **primary handler函数指针**。
- thread\_fh: 中断**线程处理程序的函数指针**。
- dev\_id: 传递给**中断处理程序的参数**。
- irq: **软件中断号**。
- thread: **中断线程的task\_struct**数据结构。
- flags: **注册**中断时用的**中断标志位**，以前缀“**IRQF\_”开头**。
- thread\_flags: 中断**线程相关的标志位**。
- thread\_mask: 用于**跟踪中断线程活动的位图**。
- name: 注册**中断的名称** 。

\_\_setup\_irq()函数很长, 分段阅读.

```c
[request_threaded_irq() -> ]
[kernel/irq/manage.c]
static int
__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
{
	struct irqaction *old, **old_ptr;
	unsigned long flags, thread_mask = 0;
	int ret, nested, shared = 0;
	cpumask_var_t mask;

	if (!desc)
		return -EINVAL;
    // 位置1
	if (desc->irq_data.chip == &no_irq_chip)
		return -ENOSYS;

	/*
	 * Check whether the interrupt nests into another interrupt
	 * thread.
	 */
	// 位置2
	nested = irq_settings_is_nested_thread(desc);
	if (nested) {
		if (!new->thread_fn) {
			ret = -EINVAL;
			goto out_mput;
		}
		/*
		 * Replace the primary handler which was provided from
		 * the driver for non nested interrupt handling by the
		 * dummy function which warns when called.
		 */
		new->handler = irq_nested_primary_handler;
	} else {
	    // 位置3
		if (irq_settings_can_thread(desc))
			irq_setup_forced_threading(new);
	}
```

位置1, 如果**desc->irq\_data.chip**指向no\_irq\_chip，说明**还没有正确初始化中断控制器**。对于**GIC\-V2中断控制器**来说，它是在**gic\_irq\_domain\_alloc**()函数中就**指定chip指针**指向**该中断控制器的struct irq\_chip \*gic\_chip**数据结构。

位置2, 处理**中断是否嵌套**的情况。对于设置了\_IRQ\_NESTED\_THREAD**嵌套类型的中断描述符**，驱动程序**注册中断时**应该指定**中断线程化处理函数thread\_fn**。嵌套类型的中断**没有primary handler**,但是这里**设定handler指向irq\_nested\_primary\_handler**()函数，该函数会**打印一句日志** “Primary handler called for nested irq”。

位置3，**irq\_settings\_can\_thread**()函数判断该中断**是否可以被线程化**. 如果该中断**没有设置\_IRQ\_NOTHREAD标志**, 说明**可以被中断线程化**, 那么调用**irq\_setup\_forced\_threading**()函数.

```c
[kernel/irq/manage.c]
static void irq_setup_forced_threading(struct irqaction *new)
{
	if (!force_irqthreads)
		return;
	if (new->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))
		return;
    // 位置1
	new->flags |= IRQF_ONESHOT;

	if (!new->thread_fn) {
		set_bit(IRQTF_FORCED_THREAD, &new->thread_flags);
		new->thread_fn = new->handler;
		new->handler = irq_default_primary_handler;
	}
}
```

系统**配置**了**CONFIG\_IRQ\_FORCED\_THREADING**选项且**内核启动参数**包含"**threadirqs**"时, **全局变量force\_irqthreads**会为**true**, 表示系统**支持强制中断线程化**. 如果**注册**的中断传入**IRQF\_NO\_THREAD | IRQF\_PERCPU | IRQF\_ONESHOT**参数, 也**不符合中断线程化要求**. **IRQF\_PERCPU**是一个**特殊的中断**, 不是一般意义上的**外设中断**, **不适合强制中断线程化**.  

**强制中断线程化**是一个**过渡方案**, 目前还有很多的驱动使用**旧版本**的注册中断API\-**request\_irq**(), 这些驱动的中断处理通常采用**上下半部的方式**.

位置1, **上半部**通常是在**关中断的状态下进行**的, 所以中断不会嵌套, 因此这里也设置**IRQ\_ONESHOT类型**, 保证所有的线程化后的thread\_fn都**执行完成**后才**打开中断源**, 稍后中断线程化部分详细介绍.

对于那些**注册中断**时**没有指定thread\_fn**的, **强制中断线程化(！！！只有这种情况下！！！**)会把**原来的primary handler**处理的函数弄到**中断线程中运行**, **原来的primary handler**只执行**默认的irq\_default\_primary\_handler**, 并且设置**IRQTF\_FORCED\_THREAD标志位**, 表明该**中断已经被强制中断线程化**.

```c
[__setup_irq()]

...
if (new->thread_fn && !nested) {
		struct task_struct *t;
		static const struct sched_param param = {
			.sched_priority = MAX_USER_RT_PRIO/2,
		};

		t = kthread_create(irq_thread, new, "irq/%d-%s", irq,
				   new->name);

		sched_setscheduler_nocheck(t, SCHED_FIFO, &param);
		get_task_struct(t);
		new->thread = t;
		set_bit(IRQTF_AFFINITY, &new->thread_flags);
	}
...
```

接下来对于**没有嵌套的线程化中断创建一个内核线程(！！！**), 它是一个**实时线程**, **调度策略为SCHED\_FIFO**, 优先级是**50**. 该**中断线程**以"**irq"、中断号和中断名称联合命名**. **get\_task\_struct**()增加该线程的**task\_struct->usage计数**, 确保即该**内核线程异常退出**了也**不会释放task\_struct**, 防止中断线程化的处理程序访问了**空指针**.

```c
[__setup_irq()]

...
// 位置1
if (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)
		new->flags &= ~IRQF_ONESHOT;

	/*
	 * The following block of code has to be executed atomically
	 */
	raw_spin_lock_irqsave(&desc->lock, flags);
	// 位置2
	old_ptr = &desc->action;
	old = *old_ptr;
	if (old) {
		/* add new interrupt at end of irq queue */
		do {
		    // 位置3
			thread_mask |= old->thread_mask;
			old_ptr = &old->next;
			old = *old_ptr;
		} while (old);
		shared = 1;
	}
    // 位置4
	if (new->flags & IRQF_ONESHOT) {
		if (thread_mask == ~0UL) {
			ret = -EBUSY;
			goto out_mask;
		}
		new->thread_mask = 1 << ffz(thread_mask);
    // 位置5
	} else if (new->handler == irq_default_primary_handler &&
		   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {
		pr_err("Threaded irq requested with handler=NULL and !ONESHOT for irq %d\n",
		       irq);
		ret = -EINVAL;
		goto out_mask;
	}
...
```

位置1, **IRQCHIP\_ONESHOT\_SAFE**标志位表示该**中断控制器不支持嵌套**，即**只支持one shot**，例如**MSI based interrupt**，因此flags可以删掉驱动注册的IRQF\_ONESHOT标志位。

位置2，old\_ptr是一个**二级指针**，指向**desc\->action指针本身的地址**，old指向desc\->action指向的**链表**。对于**共享中断**，**多个中断action描述符**通过**struct irqaction**中的**next成员连接成一个链表**。old不为空，说明之前已经有中断添加到中断描述符irq\_desc中，换句话说，这是一个**共享的中断**。

位置3，**遍历到这个链表尾**，这时**old\_ptr**指向链表**最后一个元素的next指针本身的地址**。**shared变量标记**这是一个共享中断。struct irqaction数据结构中也有一个**thread\_mask位图成员**，在**共享中断**中**每一个action**有**一个比特位**来表示。

位置4，对于**IRQF\_ONESHOT**类型的中断来说，需要**一个位图**来管理**所有的共享中断**，当**所有的共享中断的线程**都执行**完毕**，并且**desc->threads\_active等于0**后，才能算中断处理完成，该中断才可以执行unmask操作来解除中断源的屏蔽操作。变量thread\_mask中每一个比特位表示一个共享中断的中断action描述符，当然也有IRQF\_ONESHOT类型的中断只有一个irqaction的情况。

位置5，对于不是IRQF\_ONESHOT类型的中断，且中断注册时没有指定primary handler的中断来说，默认会使用irq\_default\_primary\_handler()，该函数直接返回IRQ\_WAKE\_THREAD让内核去唤醒中断线程。在一些电平触发的中断中可能存在问题，因为primary handler仅仅是去唤醒中断线程，但中断还处于使能状态，也就是电平没有被改变，例如高电平还是一直高电平，这里导致中断一直触发，引发中断风暴。通常情况下，primary handler会去做清中断的动作。因此对于**电平触发的中断**（**IRQF\_TRIGGER\_HIGH和 IRQF\_TRIGGER\_LOW**) , 驱动程序开发者必须设置primary handler，否则这里会报错。有一种特殊情况，就是中断控制器本身支持one shot功能，struct irq\_chip数据结构的flags成员会设置IRQCHIP\_ONESHOT\_SAFE标志位。

在使用request\_threaded\_rqq注册中断线程化时，如果没有指定primary handler，并且中断控制器不支持硬件ONESHOT功能，那么必须要显式地指定IRQF\_ONESHOT标志位，否则内核会报错

```c
[__setup_irq()]

    if (!shared) {
    		ret = irq_request_resources(desc);
    		
    		init_waitqueue_head(&desc->wait_for_threads);
    
    		/* Setup the type (level, edge polarity) if configured: */
    		if (new->flags & IRQF_TRIGGER_MASK) {
    			ret = __irq_set_trigger(desc, irq,
    					new->flags & IRQF_TRIGGER_MASK);
    		}
    
    		irqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);
    
    		if (new->flags & IRQF_PERCPU) {
    			irqd_set(&desc->irq_data, IRQD_PER_CPU);
    			irq_settings_set_per_cpu(desc);
    		}
    
    		/* Set default affinity mask once everything is setup */
    		setup_affinity(irq, desc, mask);
    
    }
    
    new->irq = irq;
    // 位置1
	*old_ptr = new;

	/* Reset broken irq detection when installing new handler */
	desc->irq_count = 0;
	desc->irqs_unhandled = 0;
	
	raw_spin_unlock_irqrestore(&desc->lock, flags);
	if (new->thread)
		wake_up_process(new->thread);
	return 0;
```

整个!shared, 处理不是共享中断的情况. 设置中断类型, 清IRQD\_IRQ\_INPROGRESS标志位等.

位置1, 