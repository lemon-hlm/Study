[TOC]

操作系统还有一个很重要的功能就是**管理众多的外设**，例如键盘鼠标、显示器、无线网卡、声卡等。**处理器和外设**之间的**运算能力**和**处理速度**通常不在一个数量级上。假设现在**处理器**需要去**获取一个键盘的事件**，如果**处理器**发出一个**请求信号**之后一直在**轮询（polling) 键盘的响应**，由于键盘响应速度比处理器慢得多并且等待用户输入，那么处理器是**很浪费CPU资源**的。与其这样，不如**键盘有事件发生时发送一个信号给处理器**，让处理器暂停当前的工作来处理这个响应，比处理器一直在轮询效率要高，这就是中断机制产生的背景。

凡事都不是绝对的，轮询机制也不完全比中断机制差。例如，在**网络吞吐量大**的应用场景下，**网卡驱动**采用**轮询机制比中断机制效率要高**，比如现在很火的一个开源组件DPDK(Data Plane Development Kit).

本章介绍ARM 架构下中断是如何管理的，Linux内核中的中断管理机制是如何设计与实现的，以及常用的下半部机制，例如软中断、tasklet、workqueue等。

阅读前思考:

- 发生硬件中断后，ARM处理器做了哪些事情？
- 硬件中断号和Linux内核的IRQ中断号是如何映射的？
- 一个硬件中断发生后，Linux内核如何响应并处理该中断？
- 为什么说中断上下文不能执行睡眠操作？

Linux内核支持**众多的处理器体系结构**，因此从**系统角度**来看，Linux内核中断管理可以分成如下4层。

- **硬件层**，例如CPU和中断控制器的连接。
- **处理器架构管理**，例如CPU中断异常处理。
- **中断控制器管理**，例如IRQ中断号的映射。
- Linux内核**通用中断处理器层**，例如**中断注册**和**中断处理**。

**不同的体系结构**对中断控制器有着**不同的设计理念**，例如**ARM**公司提供了一个**通用的中断控制器GIC** (Generic Interrupt Controller), **x86**体系架构则采用**APIC控制器**(Advanced Programmable Interrupt Controller)。目前最新版本的GIC技术规范是 version 3/4, version2 通常在ARMv7架构处理器中使用，例如CortexA7 和 CortexA9 等，它最多可以支持8 核；Version3 和 version4 则支持ARMV8架构，例如CortexA53等。本文以ARMVexpress平台®为例来介绍中断管理的实现，它支持GIC Version 2 版本。

# 1 ARM中断控制器

ARM Vexpress V2P\-CA15\_CA7 平台支持 CortexA 15 和Cortex A7 两个CPU cluster, 中断控制器采用GI04 0 0 控制器，支持GIC version 2技术规范，如图5.1所示，GIC-V 2规范支持如下中断类型。

- SGI 软件触发中断（Software Generated Interrupt)，通常用于多核之间通讯。最多支持16个 SGI中断,硬件中断号从ID0 〜 ID15。SGI通常在Linux内核中被用作IPI中 断 （inter-process interrupts)，并会送达到系统指定的C P U 上。
- PIH私有外设中断（Private Peripheral Interrupt)，这是每个处理核心私有的中断。最多支持16个PPI中断，硬件中断号从ID16〜ID31。PPI通常会送达到指定的C P U 上，应用场景有C P U 本地时钟（local timer)。
- SPI外设中断（Shared Peripheral Interrupt)，公用的外设中断。最多可以支持988个外设中断，硬件中断号从ID32〜ID1019。

![config](./images/1.png)

......................

# 2 硬件中断号和Linux中断号的映射

**注册中断**API函数**request\_irq**()/ **request\_threaded\_irq**()是使用Linux内核**软件中断号**（俗称软件中断号或IRQ中断号），而**不是硬件中断号(！！！**)。

```c
/* include/linux/interrupt.h */
int request_threaded_irq (unsigned int irq,  irq_handler_t handler,
                irq_handler_t thread_fn, unsigned long irqflags,
                const char *devname, void *dev_id)
```

其中，**参数irq**在Linux内核中称为**IRQ number或 interrpt line**，这是一个Linux内核管理的**虚拟中断号**，并**不是指硬件的中断号**。

内核中有一个**宏NR\_IRQS**来表示系统支持**中断数量的最大值**，NR\_IRQS和**平台相关**.

例如VexpressV2P\-CA15\_CA7平台的定义。

```c++
/* [arch/arm/mach-versatile/include/mach/irqs.h] */

#define IRQ_SIC_END  95
#define NR_IRQS  (IRQ_GPI03_END + 1)
```

在x86平台

```c++
/* arch/x86/include/asm/irq_vectors.h */

#define NR_IRQS_LEGACY			16

#define CPU_VECTOR_LIMIT		(64 * NR_CPUS)
#define IO_APIC_VECTOR_LIMIT		(32 * MAX_IO_APICS)

#if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_PCI_MSI)
#define NR_IRQS						\
	(CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?	\
		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\
		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))
#elif defined(CONFIG_X86_IO_APIC)
#define	NR_IRQS				(NR_VECTORS + IO_APIC_VECTOR_LIMIT)
#elif defined(CONFIG_PCI_MSI)
#define NR_IRQS				(NR_VECTORS + CPU_VECTOR_LIMIT)
#else
#define NR_IRQS				NR_IRQS_LEGACY
#endif
```

此外, Linux内核定义了一个**位图**来管理这些**中断号**.

```c++
/* [kernel/irq/irqdesc.c] */

#define IRQ_BITMAP_BITS  NR_IRQS
static DECLARE_BITMAP (allocated_irqs, IRQ_BITMAP_BITS);
```

**位图变量allocated\_irqs**分配NR\_IRQS比特位（假设没设置**CONFIG\_SPARSE\_IRQ**),**每个比特位**表示**一个中断号**。

另外还有一个**硬件中断号**的概念，例如Vexpress V2P\-CA15\_CA7平台中的“串口 0”的硬件中断号是37。37的来由是因为GIC把0〜31的硬件中断号预留给了SGI和PPI, 因此外设中断号从第32号开始计算，“串口 0”设备在主板上的序号是5 , 因此该设备的硬件中断号为37。

接下来以“串口 0”设备为例，介绍**硬件中断号**是如何和**Linux内核**的**IRQ中断号**映射的.

**ARM平台**的**设备描述**基本上都采用**Device Tree的模式(简称DTS**),下面先看串口 0设备DTS的描述：

```
[arch/arm/boot/dts/vexpress-v2m.dtsi]

motherboard {
	model = "V2M-P1";
	arm,hbi = <0x190>;
	arm,vexpress,site = <0>;
	compatible = "arm,vexpress,v2m-p1", "simple-bus";
	...
	iofpga@7,00000000 {
		compatible = "arm,amba-bus", "simple-bus";  //总线
	    ...
	    
	    v2m_serial0: uart@09000 {
				compatible = "arm,pl011", "arm,primecell";
				reg = <0x09000 0x1000>;
				interrupts = <5>;   // 硬件中断号
				clocks = <&v2m_oscclk2>, <&smbclk>;
				clock-names = "uartclk", "apb_pclk";
			};
	};
};
```

Vexpress-v2m.dtsi文件描述了**主板上的外设**，其中**串口0设备**是一个符合“**arm,amba-bus**”总线的外设；“arm,pl011”和 “arm,primedell”是该外设的兼容字符串，用于和驱动程序进行匹配工作；**interrupts域**的值为5，表示在主板上为**第5号中断(硬件中断号！！！**)。

系统**初始化**时，**customize\_machine**()函数[arch/arm/kernel/setup.c]会去**枚举并初始化**“**arm,amba-bus**”和“**simple-bus**”**总线上的设备**，最终解析DTS中的相关信息，把**相关信息**添加到**struct device数据结构**中，向 Linux内核**注册一个新的外设**。我们只关注中断相关信息的枚举过程:

```c
[customize_machine() -> of_platform_populate() -> of_platform_bus_create() -> of_amba_device_create()]
customize_machine(): arch/arm/kernel/setup.c
of_platform_populate(): drivers/of/platform.c
of_platform_bus_create(): drivers/of/platform.c
of_amba_device_create(): drivers/of/platform.c

static struct amba_device *of_amba_device_create(struct device_node *node,
						 const char *bus_id,
						 void *platform_data,
						 struct device *parent)
{
    ...
    /* Decode the IRQs and address ranges */
	for (i = 0; i < AMBA_NR_IRQS; i++)
		dev->irq[i] = irq_of_parse_and_map(node, i);
		
	...
}	
```

核心函数是**irq\_of\_parse\_and\_map**(), **解析DTS中串口0设备的硬件中断号**，返回**Linux内核的IRQ中断号**，并保存到struct amba\_device数据结构中的irq()数组中。**串口驱动程序在pl011\_probe**()函数中直接从dev->irq[0]中获取**IRQ中断号**。

```c
[drivers/tty/serial/amba-pl011.c]
static int pl011_probe(struct amba_device *dev, const struct amba_id *id)
{
    ...
    uap->port.irq = dev->irq[0];
    ...   
}
```

接下来探讨**硬件中断号**是如何映射到**Linux IRQ中断号**的。

有开发过ARM7/ARM9的SoC经历的读者应该知道，**那时的SoC内部中断管理**比较简单，通常有一个全局的中断状态寄存器，每个比特位管理一个外设中断，**直接简单的映射硬件中断号到Linux IRQ中断号即可**。随着芯片硬件的发展，通常**一个SoC内部有多个中断控制器**，并且**每个中断控制器**管理的**中断源的数量变得越来越多**，例如包含一个**传统的中断控制器**（如GIC),另外还有一个**GPI0类型的中断控制器**。在一些复杂的SoC中，**多个中断控制器**还可以**级联**成一个树状结构。

面对如此复杂的硬件，原来Linux内核中的中断管理机制显得捉襟见肘，因此**Linux 3.1内核**引入了**irq domain的管理框架**。irq\_domain框架可以**支持多个中断控制器**，并且完美地**支持Device Tree机制**，解决**硬件中断号映射到Linux IRQ中断号**的问题。

**一个中断控制器**用一个**struct irq\_domain数据结构**来抽象描述，struct irq\_domain数据结构定义如下：

```c
[include/linux/irqdomain.h]

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;

	/* Optional data */
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_domain *parent;
#endif

	/* reverse map data. The linear map gets appended to the irq_domain */
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct radix_tree_root revmap_tree;
	unsigned int linear_revmap[];
};
```

- link: 用于将**irq domain**连接到**全局链表irq\_domain\_list**中。
- name： irq domain 的**名称**。
- ops: irq domain映射**操作使用的方法集合**。
- of\_node:对应**中断控制器的device node**。
- hwirq\_max: 该**irq domain**支持**中断数量的最大值**。
- revmap\_size: **线性映射的大小**。
- revmap tree: **Radix Tree 映射的根节点**。
- linear\_revmap:**线性映射用到的lookup table**。

**GIC中断控制器**在**初始化**时**解析DTS信息**中定义了**几个GIC控制器**，**每个GIC控制器**注册一个**irq\_domain数据结构**。**Drivers/irqchip目录**存放着**中断控制器的驱动代码**，其中, irq-gic.c文件是符合GIC-V2规范的驱动，irq-gic-v3.c文件是符合GIC-V3规范的驱动代码。在vexpress\-v2p\-cal5\_a7.dts文件中定义**了GIC中断控制器的相关DTS信息**。

```
[arch/arm/boot/dts/vexpress-v2p-ca15_a7.dts]

gic: interrupt-controller@2c001000 {
		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
		#interrupt-cells = <3>;
		#address-cells = <0>;
		interrupt-controller;  // 表明该设备是一个中断控制器
		reg = <0 0x2c001000 0 0x1000>,
		      <0 0x2c002000 0 0x1000>,
		      <0 0x2c004000 0 0x2000>,
		      <0 0x2c006000 0 0x2000>;
		interrupts = <1 9 0xf04>;
	};
```

系统**初始化**时会去查找DTS中**定义的中断控制器**，定义“**interrupt\-controller**”属性的设备表示是一个中断控制器，例如GIC中断控制器的标识符是“arm,cortex\-a15\-gic”或“arm,cortex\-a9\-gic".

```c
[drivers/irqchip/irq-gic.c]
IRQCHIP_DECLARE(cortex_a15_gic, "arm,cortex-a15-gic", gic_of_init);

[gic_of_init() -> __gic_init_bases()]
static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
			   void __iomem *dist_base, void __iomem *cpu_base,
			   u32 percpu_offset, struct device_node *node)
{
	irq_hw_number_t hwirq_base;
	struct gic_chip_data *gic;
	int gic_irqs, irq_base, i;
	...
	/*
	 * Find out how many interrupts are supported.
	 * The GIC only supports up to 1020 interrupt sources.
	 */
	// 计算GIC控制器最多支持的中断源的个数
	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) & 0x1f;
	gic_irqs = (gic_irqs + 1) * 32;
	if (gic_irqs > 1020)
		gic_irqs = 1020;
	gic->gic_irqs = gic_irqs;

	if (node) {		/* DT case */
		gic->domain = irq_domain_add_linear(node, gic_irqs,  //
						    &gic_irq_domain_hierarchy_ops,
						    gic);
```

计算GIC控制器最多支持的中断源的个数, GIC-V2规范中最多支持1020个中断源。在SoC芯片设计阶段就固定下来一个ARMSoC可以支持多少个中断源了，例如Vexpress V2P-CA15\_CA7平台支持160个中断源。

调用irq\_domain\_add\_linear()函数注册一个irq\_domain。

```c
[__gic_init_bases() -> irq_domain_add_linear() -> __irq_domain_add()]
[kernel/irq/irqdomain.c]
struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
				    irq_hw_number_t hwirq_max, int direct_max,
				    const struct irq_domain_ops *ops,
				    void *host_data)
{
	struct irq_domain *domain;

	domain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),
			      GFP_KERNEL, of_node_to_nid(of_node));

	/* Fill structure */
	INIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);
	domain->ops = ops;
	domain->host_data = host_data;
	domain->of_node = of_node_get(of_node);
	domain->hwirq_max = hwirq_max;
	domain->revmap_size = size;
	domain->revmap_direct_max_irq = direct_max;
	irq_domain_check_hierarchy(domain);

	mutex_lock(&irq_domain_mutex);
	list_add(&domain->link, &irq_domain_list);  // 加入全局链表
	mutex_unlock(&irq_domain_mutex);

	pr_debug("Added domain %s\n", domain->name);
	return domain;
}
EXPORT_SYMBOL_GPL(__irq_domain_add);
```

内部调用\_\_irq\_domain\_add()来初始化一个**irq\_domain数据结构**，注意domain除了指向的irq\_domain数据结构外，还**多了sizeof(unsigned int) \* size大小的内存空间**，用于linear\_revmap[]成员。最后，**irq\_domain**加入**全局的链表irq\_domain\_list** 中。

回到系统枚举阶段的中断号映射过程，在of\_amba\_device\_create()函数中，**irq\_of\_parse\_and\_map**()负责把**硬件中断号**映射到**Linux内核的IRQ中断号**中，该函数定义如下：

```c
[customize_machine() -> of_platform_populate() -> of_platform_bus_create() 
-> of_amba_device_create() -> irq_of_parse_and_map()]

[drivers/of/irq.c]

unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
{
	struct of_phandle_args oirq;

	if (of_irq_parse_one(dev, index, &oirq))
		return 0;

	return irq_create_of_mapping(&oirq);
}
EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
```

of\_irq\_parse\_one()主要用于解析**DTS文件**中**设备定义的属性**, 例如“reg” “interrupts” 等，最后把 DTS中的"**interrupts**"的值存放在oirq->args[1]中。例如，串口0设备的DTS中定义"interrupts”为5, 那么oirq->args[l]的值为5。

irq\_create\_of\_mapping()函数代码片段如下：

```c
[of_amba_device_create() -> irq_of_parse_and_map() -> irq_create_of_mapping()]

[kernel/irq/irqdomain.c]
unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
{
	struct irq_domain *domain;
	irq_hw_number_t hwirq;
	unsigned int type = IRQ_TYPE_NONE;
	int virq;

    // 位置1 找到外设所属的中断控制器
	domain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain; 

	/* If domain has no translation, then we assume interrupt line */
	if (domain->ops->xlate == NULL)
		hwirq = irq_data->args[0];
	else {
	    // 位置2
		if (domain->ops->xlate(domain, irq_data->np, irq_data->args,
					irq_data->args_count, &hwirq, &type))
			return 0;
	}

	if (irq_domain_is_hierarchy(domain)) {
		/*
		 * If we've already configured this interrupt,
		 * don't do it again, or hell will break loose.
		 */
		// 位置3
		virq = irq_find_mapping(domain, hwirq);
		if (virq)
			return virq;
        // 位置4
		virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, irq_data);
		if (virq <= 0)
			return 0;
	} else {
		/* Create mapping */
		virq = irq_create_mapping(domain, hwirq);
		if (!virq)
			return virq;
	}

	/* Set type if specified and different than the current one */
	if (type != IRQ_TYPE_NONE &&
	    type != irq_get_trigger_type(virq))
		irq_set_irq_type(virq, type);
	return virq;
}
EXPORT_SYMBOL_GPL(irq_create_of_mapping);
```

位置1, 通过**device node**找到**外设所属**的**中断控制器的irq\_domain**. **每个irq\_domain**都定义了一系列的**映射相关的方法集合**，例如**GIC\-V2**定义的方法集如下：

```c
[drivers/irqchip/irq-gic.c]

static const struct irq_domain_ops gic_irq_domain_hierarchy_ops = {
	.xlate = gic_irq_domain_xlate,
	.alloc = gic_irq_domain_alloc,
	.free = irq_domain_free_irqs_top,
};
```

其中，**xlate方法**是**翻译（translate**) 的意思，通过**一个device tree节点**和**DTS脚本**中的**中断信息**解码出**硬件的中断号和中断触发类型**，这些中断信息包括DTS脚本中描述的外设的interrupts域等。

位置2, 调用GIC-V2中的**xlate方法**进行**硬件中断号的转换**。对于**GIC\-V2**来说, 由于**第0〜31号硬件中断**是**预留给SGI和 PPI使用**的，外设中断不能使用这些中断号，所以gic\_irq\_domain\_xlate()函数会把**外设硬件中断号加上32**。对于串口0设备来说，它的硬件中断号应该是32+5=37。**hwirq**存储着这个**硬件中断号**，**type**是该**外设的中断类型**。

位置3，如果这个**硬件中断号己经映射过**了，那么**irq\_find\_mapping**()可以找到**映射后的软件中断号**，在此情景下，该硬件中断号还没有映射。

位置4, **irq\_domain\_alloc\_irqs**()函数是**映射的核心函数**，内部调用\_\_irq\_domain\_alloc\_irqs()函数。

```c
[irq_create_of_mapping -> irq_domain_alloc_irqs() -> __irq_domain_alloc_irqs()]

[kernel/irq/irqdomain.c]
int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
			    unsigned int nr_irqs, int node, void *arg,
			    bool realloc)
{
	int i, ret, virq;
    // 位置1
	virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node);
	if (virq < 0) {
		pr_debug("cannot allocate IRQ(base %d, count %d)\n",
			 irq_base, nr_irqs);
		return virq;
	}
	

	if (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {
		pr_debug("cannot allocate memory for IRQ%d\n", virq);
		ret = -ENOMEM;
		goto out_free_desc;
	}

	mutex_lock(&irq_domain_mutex);
	// 位置2
	ret = irq_domain_alloc_irqs_recursive(domain, virq, nr_irqs, arg);
	if (ret < 0) {
		mutex_unlock(&irq_domain_mutex);
		goto out_free_irq_data;
	}
	for (i = 0; i < nr_irqs; i++)
	    // 位置3
		irq_domain_insert_irq(virq + i);
	mutex_unlock(&irq_domain_mutex);

	return virq;
}
```

位置1, irq\_domain\_alloc\_descs()函数要从**allocated\_irqs位图**中**查找第一个空闲的比特位**，最终调用到\_\_irq\_alloc\_descs()函数.

```c
[kernel/irq/irqdesc.c]
int __ref
__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
		  struct module *owner)
{
	int start, ret;

	mutex_lock(&sparse_irq_lock);

	start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,
					   from, cnt, 0);
	
	bitmap_set(allocated_irqs, start, cnt);
	mutex_unlock(&sparse_irq_lock);
	return alloc_descs(start, cnt, node, owner);

}
EXPORT_SYMBOL_GPL(__irq_alloc_descs);
```

**bitmap\_find\_next\_zero\_area**函数在**allocated\_irqs位图**中查找**第一个连续cnt个为0**的比特位区域。**bitmap\_set**()函数设置这些比特位，表示这些比特位**已经被占用**。

**alloc\_descs**()函数用于分配一个**struct irq\_desc数据结构**，该数据结构用于描述**中断描述符**，后续会详细介绍。

内核中有**两种方式**来分配**struct irq\_desc数据结构**

- 一是内核配置了**CONFIG\_SPARSE\_IRQ**选项，那么会采用**Radix Tree**的方式来存储这些数据结构；
- 二是采用数组的方式，这是内核在早期釆用的方法，即定义一个**全局的数组**，**每个中断**对应一个**struct irq\_desc**。

下面以后者举例：

```c
[kernel/irq/irqdesc.c]

struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
	[0 ... NR_IRQS-1] = {
		.handle_irq	= handle_bad_irq,
		.depth		= 1,
		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),
	}
};
```

irq\_desc[]数组定义了NR\_IRQS个中断描述符，数组下标表示IRQ中断号，通过**IRQ中断号**可以找到**相应的中断描述符**。struct irq\_deSC数据结构定义了很多有用的成员，**先来看和映射相关**的。

```c
[include/linux/irqdesc.h]
struct irq_desc {
	struct irq_data		irq_data;
	const char		*name;
	irq_flow_handler_t	handle_irq;
    ...
}
    
[include/linux/irq.h]
struct irq_data {
	u32			mask;
	unsigned int		irq;
	unsigned long		hwirq;
	struct irq_chip		*chip;
	struct irq_domain	*domain;
};
```

struct irq\_desc数据结构内置了struct irq\_data结构体，struct irq\_data结构体成员**irq指软件中断号**，**hwirq指硬件中断号**。如果把这两个成员填写完成，即**完成了硬件中断号到软件中断号的映射**。

irq\_domain\_alloc\_descs()函数返回**allocated\_irqs位图**中**第一个空闲的比特位**，这是**软件中断号**。

回到上面, 位置2, irq\_domain\_alloc\_irqs\_recursive()函数调用**irq\_domain**中的**alloc回调函数**进行**硬件中断号和软件中断号的映射**.

```c
[irq_create_of_mapping -> irq_domain_alloc_irqs() -> __irq_domain_alloc_irqs() 
-> irq_domain_alloc_irqs_recursive() -> gic_irq_domain_alloc]

[drivers/irqchip/irq-gic.c]
static int gic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
				unsigned int nr_irqs, void *arg)
{
	int i, ret;
	irq_hw_number_t hwirq;
	unsigned int type = IRQ_TYPE_NONE;
	struct irq_fwspec *fwspec = arg;

	ret = gic_irq_domain_xlate(domain, fwspec, &hwirq, &type);
	if (ret)
		return ret;

	for (i = 0; i < nr_irqs; i++)
		gic_irq_domain_map(domain, virq + i, hwirq + i);

	return 0;
}
```

gic\_irq\_domain\_xlate()函数己在前又中介绍，最后解析出**硬件中断号存放在hwirq中**，gic\_irq\_domain\_map()函数做**映射**工作。

```c
[drivers/irqchip/irq-gic.c]
static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq,
				irq_hw_number_t hw)
{
	if (hw < 32) {
	    //位置1
		irq_set_percpu_devid(irq);
		irq_domain_set_info(d, irq, hw, &gic_chip, d->host_data,
				    handle_percpu_devid_irq, NULL, NULL);
		set_irq_flags(irq, IRQF_VALID | IRQF_NOAUTOEN);
	} else {
	    // 位置2
		irq_domain_set_info(d, irq, hw, &gic_chip, d->host_data,
				    handle_fasteoi_irq, NULL, NULL);
		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);

		gic_routable_irq_domain_ops->map(d, irq, hw);
	}
	return 0;
}
```

参数hw指硬件中断号，位置1的if中代码是处理系统预留给SGI和 PPI中断类型，位置2的else中代码是处理SPI类型的外设中断。irq\_domain\_set\_info()函数会设置一些很重要的参数到中断描述符中。

```c
[kernel/irq/irqdomain.c]
void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
			 irq_hw_number_t hwirq, struct irq_chip *chip,
			 void *chip_data, irq_flow_handler_t handler,
			 void *handler_data, const char *handler_name)
{
	irq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);
	__irq_set_handler(virq, handler, 0, handler_name);
	irq_set_handler_data(virq, handler_data);
}
```

先看irq\_domain\_set\_hwirq\_and\_chip()函数

```c
[kernel/irq/irqdomain.c]
int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,
				  irq_hw_number_t hwirq, struct irq_chip *chip,
				  void *chip_data)
{
	struct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);

	if (!irq_data)
		return -ENOENT;

	irq_data->hwirq = hwirq;
	irq_data->chip = chip ? chip : &no_irq_chip;
	irq_data->chip_data = chip_data;

	return 0;
}
```

通过**IRQ中断号**获取**struct irq\_data数据结构**，然后把**硬件中断号hwirq**设置到struct irq\_data数据结构中的**hwirq成员**中，这样就完成了**硬件中断号**到**软件中断号的映射**。**参数chip**指**硬件中断控制器**的**struct irq\_chip**中定义的**与中断控制器底层**操作相关的**方法集合**。

```c
[include/linux/irq.h]
struct irq_chip {
	const char	*name;
	unsigned int	(*irq_startup)(struct irq_data *data);
	void		(*irq_shutdown)(struct irq_data *data);
	void		(*irq_enable)(struct irq_data *data);
	void		(*irq_disable)(struct irq_data *data);

	void		(*irq_ack)(struct irq_data *data);
	void		(*irq_mask)(struct irq_data *data);
	void		(*irq_mask_ack)(struct irq_data *data);
	void		(*irq_unmask)(struct irq_data *data);
	void		(*irq_eoi)(struct irq_data *data);

	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
	int		(*irq_retrigger)(struct irq_data *data);
	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type);
	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);

	void		(*irq_bus_lock)(struct irq_data *data);
	void		(*irq_bus_sync_unlock)(struct irq_data *data);

	void		(*irq_cpu_online)(struct irq_data *data);
	void		(*irq_cpu_offline)(struct irq_data *data);

	void		(*irq_suspend)(struct irq_data *data);
	void		(*irq_resume)(struct irq_data *data);
	void		(*irq_pm_shutdown)(struct irq_data *data);

	void		(*irq_calc_mask)(struct irq_data *data);

	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
	int		(*irq_request_resources)(struct irq_data *data);
	void		(*irq_release_resources)(struct irq_data *data);

	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);

	unsigned long	flags;
};
```

其中，比较常用的方法如下。

- irq\_startup: **初始化**一个中断。
- irq\_shutdown: **结束**一个中断。
- irq\_enable: 使能一个中断。
- irq\_disable: 关闭一个中断。
- irq\_ack: 应答一个中断。
- irq\_mask: 屏蔽一个中断源。
- irq\_mask\_ack: 应答并屏蔽该中断源。
- irq\_unmask: 解除一个中断源的屏蔽操作。
- irq\_eoi: 发送EOI信号给中断控制器，表示硬件中断处理己经完成。
- irq\_set\_affinity: 绑定一个中断到某个CPU上。
- irq\_retrigger: 重新发送中断到CPU上。
- irq\_set\_type: 设置中断触发类型。
- irq\_Set\_wake: 使能/关闭该中断在电源管理中的唤醒功能。
- irq\_bus\_lock: 函数指针，用于实现保护访问慢速设备的锁。

并**不是每个中断控制器**都需要实现struct irq\_chip中定义的**所有的方法集**，对于**GIC\-V2中断控制器**来说，实现的方法集如下：

```c
[drivers/irqchip/irq-gic.c]
static struct irq_chip gic_chip = {
	.name			= "GIC",
	.irq_mask		= gic_mask_irq,
	.irq_unmask		= gic_unmask_irq,
	.irq_eoi		= gic_eoi_irq,
	.irq_set_type		= gic_set_type,
	.irq_retrigger		= gic_retrigger,
#ifdef CONFIG_SMP
	.irq_set_affinity	= gic_set_affinity,
#endif
	.irq_set_wake		= gic_set_wake,
};
```

回到**irq\_domain\_set\_info**()函数中，**其中\_\_irq\_set\_handler**()用于设置**中断描述符desc->hander\_irq**的**回调函数**，对于**SPI类型**的外设中断来说，回调函数是**handle\_fasteoi\_irq**()。

如图5.3所示是**硬件中断号**和**软件中断号的整个映射过程**。

![config](./images/2.png)

# 3 注册中断

当一个外设中断发生后，内核会执行一个函数来响应该中断，这个函数通常被称为中断处理程序（interrupt handler) 或中断服务例程。**中断处理程序**是**内核用于响应中断(内核态运行！！！中断处理程序包括硬件中断处理程序和其下半部处理机制，包括中断线程化、软中断和workqueue等，这里特指硬件中断处理程序**)的,并且它运行在**中断上下文**中（**和进程上下文不同**）。

中断处理程序最基本的工作是**通知硬件设备**中断**己经被接收**，**不同的硬件设备**的**中断处理程序是不同**的，有的常常需要做很多的处理工作，这也是Linux内核把中断处理程序分成**上半部**和**下半部**的原因。

中断处理程序要求**快速完成**并且**退出中断**，但是如果中断处理程序需要完成的**任务比较繁重**，这两个需求就会有冲突，因此**上下半部机制**就诞生了。

在**编写外设驱动**时通常**需要注册中断**，注册中断的API如下：

```c
[include/linux/interrupt.h]
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
```

request\_irq()是比较旧的API接口，在Linux2.6.30中新增了**线程化的中断注册函数request\_threaded\_irq()**。中断线程化是实时Linux项目开发的一个新特性，目的是**降低中断处理对系统实时延迟的影响**。Linux内核已经把中断处理分成了上下半部，为什么还需要引入中断线程化机制呢？

在 Linux内核里，**中断具有最高的优先级**，只要有中断发生，内核会暂停手头的工作转向中断处理，等到**所有挂起等待（pending)的中断和软中断处理完毕后(所有中断处理完成后！！！**)才会执行**进程调度**，因此这个过程会**造成实时任务得不到及时处理(！！！**)。**中断上下文总是抢占进程上下文(！！！**)，**中断上下文**不仅是**中断处理程序**,还包括**Softirq软中断**、**tasklet等**，中断上下文成了优化Linux实时性的最大挑战之一。

假设一个**高优先级任务**和一个**中断同时发生**，那么内核首先执行中断处理程序，中断处理程序完成之后有可能触发软中断，也可能有一些tasklet任务要执行或有新的中断发生，这样高优先级任务的延迟变得不可预测。中断线程化的目的是把中断处理中一些繁重的任务作为内核线程来运行，实时进程可以有比中断线程更高的优先级。这样高优先级的实时进程可以得到优先处理，实时进程的延迟粒度变得小得多，当然并不是所有的中断都可以线程化，例如时钟中断。

```c
[kernel/irq/manage.c]
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id)
```

- irq: I R Q 中断号，注意这里使用的是软件中断号，而不是硬件中断号。
- handler: 指 primary handler, 有些类似于旧版本API函数request\_irq()的中断处理函数handler。中断发生时会优先执行primary handler。如果primary handler为NULL且 thread\_fn 不为 NULL, 那么会执行系统默认的 primary handler: irq\_default\_primary\_handler()函数。
- thread\_fh: 中断线程化的处理程序。如果thread\_fn不为NULL, 那么会创建一个内核线程。primary handler和 thread_fn不能同时为NULL 。
- irqflags: 中断标志位，如表5.2所示。
- devname: 该中断名称。
- dev id: 传递给中断处理程序的参数。

![config](./images/3.png)