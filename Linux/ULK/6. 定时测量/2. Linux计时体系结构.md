Linux必定执行与定时相关的操作。

Linux的计时体系结构（timekeeping architecture）是一组与时间流相关的内核数据结构和函数。实际上，80x86多处理器机器所具有的计时体系结构与单处理器有所不同。

- 单处理器系统，所有计时活动由全局定时器（可编程间隔定时器或高精度事件定时器）产生的中断触发。

- 多处理器系统，所有普通活动（像软定时器的处理）都是由全局定时器产生的中断触发，而具体的CPU活动（监控当前运行进程的执行时间）由本地APIC定时器产生的中断触发。
 
Linux的计时体系结构还依赖于时间戳计数器（TSC）、ACPI电源管理定时器、高精度事件定时器（HPET）的可用性。内核使用两个基本的计时函数：一个保持当前最新的时间，一个计算在当前秒内走过的纳秒数。

## 计时体系结构的数据结构

### 定时器对象

为使用一种统一的方法来处理可能存在的定时器资源，内核使用了“定时器对象”，它是timer_opts类型的一个描述符。

### jiffies变量

jiffies变量是一个计数器，用来记录自系统启动以来产生的节拍总数。每次时钟中断发生（每个节拍）便加1。

### xtime变量

存放当前时间和日期，是一个timespace类型的数据结构.

xtime变量通常每个节拍更新一次。用户程序从xtime变量获得当前时间和日期。内核也经常引用它。

## 单处理系统上的计时体系结构

单处理器系统上，所有与定时器有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断出发。同样，Linux中，某些活动尽可能在中断产生后立即执行，而其余的活动延迟。

### 初始化阶段

内核初始化期间，time_init()来建立计时体系结构，通常操作：

（1） 初始化xtime变量

（2） 初始化wall_to_monotonic变量

（3） 如果内核支持HPET，它将调用hpet_enable()函数来确认ACPI固件是否探测到了该芯片并将它的寄存器映射到内存地址空间中。若是，hpet_enable()将对HPET芯片的第一个定时器编程使其以每秒1000次频率引发IRQ 0处的中断。否则，内核使用 PIT：该芯片已经被init_IRQ()函数编程，使得以每秒1000次的频率引发IRQ 0 处的中断。

（4） 调用select_timer()来挑选系统中可利用的最好的定时器资源，并设置cur_timer变量指向该定时器资源对应的定时器对象的地址

（5） 调用setup_irq(0, &irq0)来创建于IRQ0相应的中断门，IRQ0引脚连接着系统时钟中断源（PIT或HPET）。irq0变量被静态定义如下：

```
struct irqaction irq0 = {
    timer_interrupt, 
    SA_INTERRUPT, 
    0,
    "timer",
    NULL,
    NULL
}
```

从现在起，timer_interrupt()函数将会在每个节拍到来时被调用，而中断被禁止，因为IRQ0主描述符的状态字段中的SA_INTERRUPT标志被置位。

### 时钟中断处理程序

