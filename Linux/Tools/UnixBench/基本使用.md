
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 介绍](#1-介绍)
- [2 官网地址](#2-官网地址)
- [3 安装](#3-安装)
- [4 使用](#4-使用)
- [5 测试得分项说明](#5-测试得分项说明)
  - [5.1 Dhrystone 2 using register variables](#51-dhrystone-2-using-register-variables)
  - [5.2 Double\-Precision Whetstone](#52-double-precision-whetstone)
  - [5.3 Execl Throughput](#53-execl-throughput)
  - [5.4 File copy: 文件copy](#54-file-copy-文件copy)
  - [5.5 Pipe Throughput: 一个进程管道写读回](#55-pipe-throughput-一个进程管道写读回)
  - [5.6 Pipe\-based Context Switching: 两个进程双向管道传输](#56-pipe-based-context-switching-两个进程双向管道传输)
  - [5.7 Process Creation](#57-process-creation)
  - [5.8 System Call Overhead](#58-system-call-overhead)
  - [5.9 Shell Scripts](#59-shell-scripts)

<!-- /code_chunk_output -->

# 1 介绍

UnixBench是一个类unix系（Unix，BSD，Linux）统下的性能测试工具，一个开源工具，被广泛用与测试linux系统主机的性能。

Unixbench的主要测试项目有：**系统调用**、**读写**、**进程**、**图形化测试**、**2D**、**3D**、**管道**、**运算**、**C库**等系统基准性能提供测试数据。

最新版本UnixBench5.1.3，包含**system**和**graphic**测试，如果你需要测试graphic，则需要修改Makefile, 不要注释掉”GRAPHIC\_TESTS = defined”，同时需要系统提供x11perf命令gl\_glibs库。

下面的脚本使用了最新版UnixBench5.1.3来测试，注释了关于graphic的测试项（大多数VPS都是没有显卡或者是集显，所以图像性能无需测试），运行10-30分钟后（根据CPU内核数量，运算时间不等）得出分数，**越高越好**。

# 2 官网地址

https://github.com/kdlucas/byte-unixbench

# 3 安装

下载

```
wget https://s3.amazonaws.com/cloudbench/software/UnixBench5.1.3.tgz
wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/byte-unixbench/UnixBench5.1.3.tgz
```

解压, 编译

```
tar -xvf UnixBench5.1.3.tgz
cd UnixBench/
make all
```

如果你不需要测试图形性能的话，可以在编译之前把Makefile中的GRAPHIC_TESTS = defined注释掉

# 4 使用

```
[root@02master01 UnixBench]# ./Run
make all
make[1]: Entering directory `/root/unixbench/UnixBench'
Checking distribution of files
./pgms  exists
./src  exists
./testdir  exists
./tmp  exists
./results  exists
make[1]: Leaving directory `/root/unixbench/UnixBench'
sh: 3dinfo: command not found

   #    #  #    #  #  #    #          #####   ######  #    #   ####   #    #
   #    #  ##   #  #   #  #           #    #  #       ##   #  #    #  #    #
   #    #  # #  #  #    ##            #####   #####   # #  #  #       ######
   #    #  #  # #  #    ##            #    #  #       #  # #  #       #    #
   #    #  #   ##  #   #  #           #    #  #       #   ##  #    #  #    #
    ####   #    #  #  #    #          #####   ######  #    #   ####   #    #

   Version 5.1.3                      Based on the Byte Magazine Unix Benchmark

   Multi-CPU version                  Version 5 revisions by Ian Smith,
                                      Sunnyvale, CA, USA
   January 13, 2011                   johantheghost at yahoo period com


1 x Dhrystone 2 using register variables  1 2 3 4 5 6 7 8 9 10

1 x Double-Precision Whetstone  1 2 3 4 5 6 7 8 9 10

1 x Execl Throughput  1 2 3

1 x File Copy 1024 bufsize 2000 maxblocks  1
```

注: 执行`Run`就会自动编译, 所以其实也不需要先`make all`

执行命令./Run即可。脚本会先进行编译，然后再执行测试

如果就执行`Run`就是做一个**系统测试**，如果执行`Run graphics`就是执行**图形测试**，执行`Run gindex`就是**两个测试都执行**，测试时间是相当漫长的。

# 5 测试得分项说明

## 5.1 Dhrystone 2 using register variables

此项用于测试 **string handling**，因为没有浮点操作，所以深受软件和硬件设计（hardware and software design）、编译和链接（compiler and linker options）、代码优化（code optimazaton）、对内存的cache（cache memory）、等待状态（wait states）、整数数据类型（integer data types）的影响。

## 5.2 Double\-Precision Whetstone

这一项测试**浮点数操作**的速度和效率。这一测试包括几个模块，每个模块都包括一组用于科学计算的操作。覆盖面很广的一系列 c 函数：sin，cos，sqrt，exp，log 被用于整数和浮点数的数学运算、数组访问、条件分支（conditional branch）和程序调用。此测试同时测试了整数和浮点数算术运算。

## 5.3 Execl Throughput

此测试考察每秒钟可以执行的 **execl 系统调用**的次数。 execl 系统调用是 exec 函数族的一员。它和其他一些与之相似的命令一样是 execve（） 函数的前端。

## 5.4 File copy: 文件copy

测试从**一个文件**向**另外一个文件传输数据**的速率。每次测试使用**不同大小的缓冲区**。这一**针对文件** **read**、**write**、**copy** 操作的测试统计**规定时间（默认是 10s**）内的文件 read、write、copy **操作次数**。

## 5.5 Pipe Throughput: 一个进程管道写读回

**管道（pipe**）是**进程间交流**的最简单方式，这里的 Pipe throughtput 指的是**一秒钟**内**一个进程**可以**向一个管道写 512 字节数据**然后**再读回**的**次数**。

需要注意的是，pipe throughtput 在实际编程中**没有对应的真实存在**。

## 5.6 Pipe\-based Context Switching: 两个进程双向管道传输

这个测试**两个进程（每秒钟**）通过**一个管道交换一个不断增长的整数的次数**。这一点很像现实编程中的一些应用，这个测试程序首先**创建一个子进程**，再和这个子进程进行**双向的管道传输**。

## 5.7 Process Creation

测试每秒钟一个进程可以创建子进程然后收回子进程的次数（子进程一定立即退出）。process creation 的关注点是新进程进程控制块（process control block）的创建和内存分配，即一针见血地关注内存带宽。一般说来，这个测试被用于对操作系统进程创建这一系统调用的不同实现的比较。

## 5.8 System Call Overhead

测试进入和离开操作系统内核的代价，即一次系统调用的代价。它利用一个反复地调用 getpid 函数的小程序达到此目的。

## 5.9 Shell Scripts

测试一秒钟内一个进程可以并发地开始一个 shell 脚本的 n 个拷贝的次数，n 一般取值 1，2，4，8。（我在测试时取 1， 8）。这个脚本对一个数据文件进行一系列的变形操作（transformation）。


