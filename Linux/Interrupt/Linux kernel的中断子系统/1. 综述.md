[TOC]

# 1 前言

一个合格的linux驱动工程师需要对kernel中的中断子系统有深刻的理解，只有这样，在写具体driver的时候才能：

1、**正确的使用linux kernel提供的的API**，例如最著名的**request\_threaded\_irq**（**request\_irq**）接口

2、正确使用**同步机制**保护驱动代码中的**临界区**

3、正确的使用kernel提供的**softirq、tasklet、workqueue等机制**来完成具体的中断处理

基于上面的原因，我希望能够通过一系列的文档来描述清楚linux kernel中的中断子系统方方面面的知识。一方面是整理自己的思绪，另外一方面，希望能够对其他的驱动工程师（或者想从事linux驱动工作的工程师）有所帮助。

# 2 中断系统相关硬件描述

中断硬件系统主要有**三种器件参与**，各个**外设**、**中断控制器**和**CPU**。各个**外设**提供**irq request line**，在**发生中断事件**的时候，通过irq request line上的**电气信号**向CPU系统请求处理。**外设的irq request line太多**，CPU需要一个小伙伴帮他，这就是**Interrupt controller**。Interrupt Controller是**连接外设中断系统**和**CPU系统的桥梁**。根据外设irq request line的多少，Interrupt Controller可以级联。**CPU**的主要功能是**运算**，因此**CPU并不处理中断优先级**，那是Interrupt controller的事情。

对于CPU而言，一般有**两种中断请求**，例如：对于ARM，是IRQ和FIQ信号线，分别让ARM进入IRQ mode和FIQ mode。对于X86，有可屏蔽中断和不可屏蔽中断。

本章节不是描述具体的硬件，而是使用了HW block这样的概念。例如CPU HW block是只ARM core或者X86这样的实际硬件block的一个逻辑描述，实际中，可能是任何可能的CPU block。

## 2.1 HW中断系统的逻辑block图

![config](./images/1.gif)

系统中有**若干个CPU block**用来**接收中断事件并进行处理**，**若干个Interrupt controller**形成**树状的结构**，**汇集**系统中**所有外设的irq request line**，并将**中断事件分发**给**某一个CPU block**进行处理。从**接口层面**看，主要有**两类接口**，一种是**中断接口**。有的实现中，具体中断接口的形态就是**一个硬件的信号线**，通过**电平信号**传递**中断事件**（ARM以及GIC组成的中断系统就是这么设计的）。有些系统采用了其他的方法来传递中断事件，比如x86＋APIC（Advanced Programmable Interrupt Controller）组成的系统，每个x86的核有一个Local APIC，这些Local APIC们通过ICC（Interrupt Controller Communication）bus连接到IO APIC上。IO APIC收集各个外设的中断，并翻译成总线上的message，传递给某个CPU上的Local APIC。因此，上面的红色线条也是逻辑层面的中断信号，可能是实际的PCB上的铜线（或者SOC内部的铜线），也可能是一个message而已。除了中断接口，CPU和Interrupt Controller之间还需要有控制信息的交流。Interrupt Controller会开放一些寄存器让CPU访问、控制。