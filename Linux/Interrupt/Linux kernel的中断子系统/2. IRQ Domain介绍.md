- 1 概述
- 2 历史
- 3 接口
    - 3.1 向系统注册irq domain
    - 3.2 为irq domain创建映射
- 4 数据结构描述
    - 4.1 irq domain的callback接口
    - 4.2 irq domain
- 5 中断相关的Device Tree知识回顾
- 6 Mapping DB的建立
    - 6.1 概述
    - 6.2 interrupt controller初始化的过程中，注册irq domain
    - 6.3 在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系
- 7 将HW interrupt ID转成IRQ number
    - 7.1 GIC driver初始化
    - 7.2 具体如何在中断处理过程中，将HW interrupt ID转成IRQ number

# 1 概述

在linux kernel中，我们使用下面**两个ID**来**标识一个来自外设的中断**：

1、**IRQ number**。**CPU**需要为**每一个外设中断编号**，我们称之IRQ Number。这个IRQ number是一个**虚拟的interrupt ID，和硬件无关(！！！**)，仅仅是被CPU用来标识一个外设中断。

2、**HW interrupt ID**。对于**interrupt controller**而言，它收集了**多个外设的interrupt request line并向上传递**，因此，**interrupt controller**需要**对外设中断进行编码(！！！**)。Interrupt controller用HW interrupt ID来标识外设的中断。在**interrupt controller级联**的情况下，仅仅用**HW interrupt ID已经不能唯一标识一个外设中断(！！！**)，还需要知道该**HW interrupt ID所属的interrupt controller（HW interrupt ID在不同的Interrupt controller上是会重复编码的**）。

这样，CPU和interrupt controller在标识中断上就有了一些不同的概念，但是，对于**驱动工程师**而言，我们和CPU视角是一样的，我们**只希望得到一个IRQ number**，而不关系具体是哪个interrupt controller上的哪个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将**HW interrupt ID映射到IRQ number上来的机制**，这就是本文主要的内容。

# 2 历史

关于**HW interrupt ID**映射到**IRQ number**上这事，在**过去**系统只有**一个interrupt controller**的时候还是很简单的，**中断控制器**上**实际的HW interrupt line的编号**可以**直接变成IRQ number**。例如我们大家都熟悉的SOC内嵌的interrupt controller，这种controller多半有中断状态寄存器，这个寄存器可能有64个bit（也可能更多），**每个bit**就是**一个IRQ number**，可以**直接进行映射**。这时候，GPIO的中断在中断控制器的状态寄存器中只有一个bit，因此所有的GPIO中断只有一个IRQ number，在该通用GPIO中断的irq handler中进行deduplex，将各个具体的GPIO中断映射到其相应的IRQ number上。如果你是一个足够老的工程师，应该是经历过这个阶段的。

随着linux kernel的发展，将**interrupt controller抽象成irqchip**这个概念越来越流行，甚至**GPIO controller**也可以被看出一个**interrupt controller chip**，这样，系统中至少有**两个中断控制器**了，一个传统意义的中断控制器，一个是**GPIO controller type的中断控制器**。随着系统复杂度加大，外设中断数据增加，实际上系统可以需要多个中断控制器进行级联，面对这样的趋势，linux kernel工程师如何应对？答案就是**irq domain**这个概念。

我们听说过很多的domain，power domain，clock domain等等，所谓domain，就是**领域，范围**的意思，也就是说，任何的定义出了这个范围就没有意义了。系统中**所有的interrupt controller**会形成**树状结构**，对于**每个interrupt controller**都可以**连接若干个外设的中断请求**（我们称之**interrupt source**），interrupt controller会对连接其上的**interrupt source**（根据其在Interrupt controller中**物理特性**）进行**编号（也就是HW interrupt ID**了）。但这个编号**仅仅限制在本interrupt controller范围**内。

# 3 接口

## 3.1 向系统注册irq domain

具体**如何进行映射**是interrupt controller自己的事情，不过，有软件架构思想的工程师更愿意对形形色色的interrupt controller进行抽象，对如何进行HW interrupt ID到IRQ number映射关系上进行进一步的抽象。因此，**通用中断处理模块**中有一个**irq domain的子模块**，该模块将这种**映射关系**分成了三类：

（1）**线性映射**。其实就是一个**lookup table**，**HW interrupt ID**作为**index**，通过查表可以获取**对应的IRQ number**。对于Linear map而言，interrupt controller对其HW interrupt ID进行编码的时候要满足一定的条件：hw ID不能过大，而且ID排列最好是紧密的。对于线性映射，其接口API如下：

```c
static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node, 
                     unsigned int size,－－－－－－－－－该interrupt domain支持多少IRQ 
                     const struct irq_domain_ops *ops,－－－callback函数 
                     void *host_data)－－－－－driver私有数据 
{ 
    return __irq_domain_add(of_node, size, size, 0, ops, host_data); 
}
```

（2）**Radix Tree map**。建立一个**Radix Tree**来维护HW interrupt ID到IRQ number映射关系。HW interrupt ID作为lookup key，在Radix Tree检索到IRQ number。如果的确不能满足线性映射的条件，可以考虑Radix Tree map。实际上，内核中使用**Radix Tree map**的只有**powerPC和MIPS**的硬件平台。对于Radix Tree map，其接口API如下：

```c
static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node, 
                     const struct irq_domain_ops *ops, 
                     void *host_data) 
{ 
    return __irq_domain_add(of_node, 0, ~0, 0, ops, host_data); 
}
```

（3）**no map**。有些**中断控制器**很强，可以通过寄存器配置HW interrupt ID而不是由物理连接决定的。例如PowerPC 系统使用的MPIC (Multi\-Processor Interrupt Controller)。在这种情况下，不需要进行映射，我们**直接把IRQ number写入HW interrupt ID配置寄存器**就OK了，这时候，生成的HW interrupt ID就是IRQ number，也就**不需要进行mapping**了。对于这种类型的映射，其接口API如下：

```c
static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node, 
                     unsigned int max_irq, 
                     const struct irq_domain_ops *ops, 
                     void *host_data) 
{ 
    return __irq_domain_add(of_node, 0, max_irq, max_irq, ops, host_data); 
}
```

这类接口的逻辑很简单，根据自己的**映射类型**，初始化struct irq\_domain中的各个成员，调用\_\_irq\_domain\_add将**该irq domain挂入irq\_domain\_list的全局列表**。

## 3.2 为irq domain创建映射

上节的内容主要是**向系统注册一个irq domain**，具体HW interrupt ID和IRQ number的映射关系都是空的，因此，具体各个irq domain如何管理映射所需要的database还是需要建立的。例如：对于线性映射的irq domain，我们需要建立线性映射的lookup table，对于Radix Tree map，我们要把那个反应IRQ number和HW interrupt ID的Radix tree建立起来。创建映射有四个接口函数：

（1）调用irq\_create\_mapping函数建立HW interrupt ID和IRQ number的映射关系。该接口函数以irq domain和HW interrupt ID为参数，返回IRQ number（这个IRQ number是动态分配的）。该函数的原型定义如下：

```c
extern unsigned int irq_create_mapping(struct irq_domain *host, 
                       irq_hw_number_t hwirq);
```

驱动调用该函数的时候必须提供HW interrupt ID，也就是意味着driver知道自己使用的HW interrupt ID，而一般情况下，HW interrupt ID其实对具体的driver应该是不可见的，不过有些场景比较特殊，例如GPIO类型的中断，它的HW interrupt ID和GPIO有着特定的关系，driver知道自己使用那个GPIO，也就是知道使用哪一个HW interrupt ID了。

（2）irq\_create\_strict\_mappings。这个接口函数用来为一组HW interrupt ID建立映射。具体函数的原型定义如下：

```c
extern int irq_create_strict_mappings(struct irq_domain *domain, 
                      unsigned int irq_base, 
                      irq_hw_number_t hwirq_base, int count);
```

（3）irq\_create\_of\_mapping。看到函数名字中的of（open firmware），我想你也可以猜到了几分，这个接口当然是利用device tree进行映射关系的建立。具体函数的原型定义如下：

```c
extern unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data);
```

通常，一个普通设备的device tree node已经描述了足够的中断信息，在这种情况下，该设备的驱动在初始化的时候可以调用irq\_of\_parse\_and\_map这个接口函数进行该device node中和中断相关的内容（interrupts和interrupt-parent属性）进行分析，并建立映射关系，具体代码如下：

```c
unsigned int irq_of_parse_and_map(struct device_node *dev, int index) 
{ 
    struct of_phandle_args oirq;

    if (of_irq_parse_one(dev, index, &oirq))－－－－分析device node中的interrupt相关属性 
        return 0;

    return irq_create_of_mapping(&oirq);－－－－－创建映射，并返回对应的IRQ number 
}
```

对于一个使用Device tree的普通驱动程序（我们推荐这样做），基本上初始化需要调用irq\_of\_parse\_and\_map获取IRQ number，然后调用request\_threaded\_irq申请中断handler。

（4）irq\_create\_direct\_mapping。这是给no map那种类型的interrupt controller使用的，这里不再赘述。

# 4 数据结构描述

## 4.1 irq domain的callback接口

struct irq\_domain\_ops抽象了一个irq domain的callback函数，定义如下：

```c
struct irq_domain_ops { 
    int (*match)(struct irq_domain *d, struct device_node *node); 
    int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw); 
    void (*unmap)(struct irq_domain *d, unsigned int virq); 
    int (*xlate)(struct irq_domain *d, struct device_node *node, 
             const u32 *intspec, unsigned int intsize, 
             unsigned long *out_hwirq, unsigned int *out_type); 
};
```

我们先看xlate函数，语义是翻译（translate）的意思，那么到底翻译什么呢？在DTS文件中，各个使用中断的device node会通过一些属性（例如interrupts和interrupt-parent属性）来提供中断信息给kernel以便kernel可以正确的进行driver的初始化动作。这里，interrupts属性所表示的interrupt specifier只能由具体的interrupt controller（也就是irq domain）来解析。而xlate函数就是将指定的设备（node参数）上若干个（intsize参数）中断属性（intspec参数）翻译成HW interrupt ID（out\_hwirq参数）和trigger类型（out\_type）。

match是判断一个指定的interrupt controller（node参数）是否和一个irq domain匹配（d参数），如果匹配的话，返回1。实际上，内核中很少定义这个callback函数，实际上struct irq\_domain中有一个of\_node指向了对应的interrupt controller的device node，因此，如果不提供该函数，那么default的匹配函数其实就是判断irq domain的of\_node成员是否等于传入的node参数。

map和unmap是操作相反的函数，我们描述其中之一就OK了。调用map函数的时机是在创建（或者更新）HW interrupt ID（hw参数）和IRQ number（virq参数）关系的时候。其实，从发生一个中断到调用该中断的handler仅仅调用一个request\_threaded\_irq是不够的，还需要针对该irq number设定：

（1）设定该IRQ number对应的中断描述符（struct irq_desc）的irq chip

（2）设定该IRQ number对应的中断描述符的highlevel irq-events handler

（3）设定该IRQ number对应的中断描述符的 irq chip data

这些设定不适合由具体的硬件驱动来设定，因此在Interrupt controller，也就是irq domain的callback函数中设定。

## 4.2 irq domain

在内核中，irq domain的概念由struct irq\_domain表示：

```c
struct irq_domain { 
    struct list_head link; 
    const char *name; 
    const struct irq_domain_ops *ops; －－－－callback函数 
    void *host_data;

    /* Optional data */ 
    struct device_node *of_node; －－－－该interrupt domain对应的interrupt controller的device node 
    struct irq_domain_chip_generic *gc; －－－generic irq chip的概念，本文暂不描述

    /* reverse map data. The linear map gets appended to the irq_domain */ 
    irq_hw_number_t hwirq_max; －－－－该domain中最大的那个HW interrupt ID 
    unsigned int revmap_direct_max_irq; －－－－ 
    unsigned int revmap_size; －－－线性映射的size，for Radix Tree map和no map，该值等于0 
    struct radix_tree_root revmap_tree; －－－－Radix Tree map使用到的radix tree root node 
    unsigned int linear_revmap[]; －－－－－线性映射使用的lookup table 
};
```

linux内核中，所有的irq domain被挂入一个全局链表，链表头定义如下：

```c
static LIST\_HEAD(irq_domain_list);
```

struct irq\_domain中的link成员就是挂入这个队列的节点。通过irq\_domain\_list这个指针，可以获取整个系统中HW interrupt ID和IRQ number的mapping DB。host\_data定义了底层interrupt controller使用的私有数据，和具体的interrupt controller相关（对于GIC，该指针指向一个struct gic\_chip\_data数据结构）。

对于线性映射：

（1）linear\_revmap保存了一个线性的lookup table，index是HW interrupt ID，table中保存了IRQ number值

（2）revmap\_size等于线性的lookup table的size。

（3）hwirq\_max保存了最大的HW interrupt ID

（4）revmap\_direct\_max\_irq没有用，设定为0。revmap\_tree没有用。

对于Radix Tree map：

（1）linear\_revmap没有用，revmap\_size等于0。

（2）hwirq_max没有用，设定为一个最大值。

（3）revmap\_direct\_max\_irq没有用，设定为0。

（4）revmap\_tree指向Radix tree的root node。

# 5 中断相关的Device Tree知识回顾

想要进行映射，首先要了解interrupt controller的拓扑结构。系统中的interrupt controller的拓扑结构以及其interrupt request line的分配情况（分配给哪一个具体的外设）都在Device Tree Source文件中通过下面的属性给出了描述。这些内容在Device Tree的三份文档中给出了一些描述，这里简单总结一下：

对于那些产生中断的外设，我们需要定义interrupt\-parent和interrupts属性：

（1）interrupt\-parent。表明该外设的interrupt request line物理的连接到了哪一个中断控制器上

（2）interrupts。这个属性描述了具体该外设产生的interrupt的细节信息（也就是传说中的interrupt specifier）。例如：HW interrupt ID（由该外设的device node中的interrupt\-parent指向的interrupt controller解析）、interrupt触发类型等。

对于Interrupt controller，我们需要定义interrupt-controller和#interrupt-cells的属性：

（1）interrupt\-controller。表明该device node就是一个中断控制器

（2）#interrupt\-cells。该中断控制器用多少个cell（一个cell就是一个32-bit的单元）描述一个外设的interrupt request line。？具体每个cell表示什么样的含义由interrupt controller自己定义。

（3）interrupts和interrupt\-parent。对于那些不是root 的interrupt controller，其本身也是作为一个产生中断的外设连接到其他的interrupt controller上，因此也需要定义interrupts和interrupt\-parent的属性。

# 6 Mapping DB的建立

## 6.1 概述

系统中HW interrupt ID和IRQ number的mapping DB是在整个系统初始化的过程中建立起来的，过程如下：

（1）DTS文件描述了系统中的interrupt controller以及外设IRQ的拓扑结构，在linux kernel启动的时候，由bootloader传递给kernel（实际传递的是DTB）。

（2）在Device Tree初始化的时候，形成了系统内所有的device node的树状结构，当然其中包括所有和中断拓扑相关的数据结构（所有的interrupt controller的node和使用中断的外设node）

（3）在machine driver初始化的时候会调用of\_irq\_init函数，在该函数中会扫描所有interrupt controller的节点，并调用适合的interrupt controller driver进行初始化。毫无疑问，初始化需要注意顺序，首先初始化root，然后first level，second level，最好是leaf node。在初始化的过程中，一般会调用上节中的接口函数向系统增加irq domain。有些interrupt controller会在其driver初始化的过程中创建映射

（4）在各个driver初始化的过程中，创建映射

## 6.2 interrupt controller初始化的过程中，注册irq domain

我们以GIC的代码为例。具体代码在gic\_of\_init->gic\_init\_bases中，如下：

```c
void __init gic_init_bases(unsigned int gic_nr, int irq_start, 
               void __iomem *dist_base, void __iomem *cpu_base, 
               u32 percpu_offset, struct device_node *node) 
{ 
    irq_hw_number_t hwirq_base; 
    struct gic_chip_data *gic; 
    int gic_irqs, irq_base, i;

…… 
对于root GIC 
        hwirq_base = 16; 
        gic_irqs = 系统支持的所有的中断数目－16。之所以减去16主要是因为root GIC的0～15号HW interrupt 是for IPI的，因此要去掉。也正因为如此hwirq_base从16开始


    irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());申请gic_irqs个IRQ资源，从16号开始搜索IRQ number。由于是root GIC，申请的IRQ基本上会从16号开始


    gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base, 
                    hwirq_base, &gic_irq_domain_ops, gic);－－－向系统注册irq domain并创建映射

…… 
}
```

很遗憾，在GIC的代码中没有调用标准的注册irq domain的接口函数。要了解其背后的原因，我们需要回到过去。在旧的linux kernel中，ARM体系结构的代码不甚理想。在arch/arm目录充斥了很多board specific的代码，其中定义了很多具体设备相关的静态表格，这些表格规定了各个device使用的资源，当然，其中包括IRQ资源。在这种情况下，各个外设的IRQ是固定的（如果作为驱动程序员的你足够老的话，应该记得很长篇幅的针对IRQ number的宏定义），也就是说，HW interrupt ID和IRQ number的关系是固定的。一旦关系固定，我们就可以在interupt controller的代码中创建这些映射关系。具体代码如下：

```c
struct irq_domain *irq_domain_add_legacy(struct device_node *of_node, 
                     unsigned int size, 
                     unsigned int first_irq, 
                     irq_hw_number_t first_hwirq, 
                     const struct irq_domain_ops *ops, 
                     void *host_data) 
{ 
    struct irq_domain *domain;

    domain = __irq_domain_add(of_node, first_hwirq + size,－－－－注册irq domain 
                  first_hwirq + size, 0, ops, host_data); 
    if (!domain) 
        return NULL;

    irq_domain_associate_many(domain, first_irq, first_hwirq, size); －－－创建映射

    return domain; 
}
```

这时候，对于这个版本的GIC driver而言，初始化之后，HW interrupt ID和IRQ number的映射关系已经建立，保存在线性lookup table中，size等于GIC支持的中断数目，具体如下：

index 0～15对应的IRQ无效

16号IRQ  <------------------>16号HW interrupt ID

17号IRQ  <------------------>17号HW interrupt ID

……

如果想充分发挥Device Tree的威力，3.14版本中的GIC 代码需要修改。

## 6.3 在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系

我们上面的描述过程中，已经提及：设备的驱动在初始化的时候可以调用irq\_of\_parse\_and\_map这个接口函数进行该device node中和中断相关的内容（interrupts和interrupt-parent属性）进行分析，并建立映射关系，具体代码如下：

```c
unsigned int irq_of_parse_and_map(struct device_node *dev, int index) 
{ 
    struct of_phandle_args oirq;

    if (of_irq_parse_one(dev, index, &oirq))－－－－分析device node中的interrupt相关属性 
        return 0;

    return irq_create_of_mapping(&oirq);－－－－－创建映射 
}
```

我们再来看看irq\_create\_of\_mapping函数如何创建映射：

```c
unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data) 
{ 
    struct irq_domain *domain; 
    irq_hw_number_t hwirq; 
    unsigned int type = IRQ_TYPE_NONE; 
    unsigned int virq;

    domain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain;－－A 
    if (!domain) { 
        return 0; 
    }


    if (domain->ops->xlate == NULL)－－－－－－－－－－－－－－B 
        hwirq = irq_data->args[0]; 
    else { 
        if (domain->ops->xlate(domain, irq_data->np, irq_data->args,－－－－C 
                    irq_data->args_count, &hwirq, &type)) 
            return 0; 
    }

    /* Create mapping */ 
    virq = irq_create_mapping(domain, hwirq);－－－－－－－－D 
    if (!virq) 
        return virq;

    /* Set type if specified and different than the current one */ 
    if (type != IRQ_TYPE_NONE && 
        type != irq_get_trigger_type(virq)) 
        irq_set_irq_type(virq, type);－－－－－－－－－E 
    return virq; 
}
```

A：这里的代码主要是找到irq domain。这是根据传递进来的参数irq_data的np成员来寻找的，具体定义如下：

```c
struct of_phandle_args { 
    struct device_node *np;－－－指向了外设对应的interrupt controller的device node 
    int args_count;－－－－－－－该外设定义的interrupt相关属性的个数 
    uint32_t args[MAX_PHANDLE_ARGS];－－－－具体的interrupt相当属性的定义 
};
```

B：如果没有定义xlate函数，那么取interrupts属性的第一个cell作为HW interrupt ID。

C：解铃还需系铃人，interrupts属性最好由interrupt controller（也就是irq domain）解释。如果xlate函数能够完成属性解析，那么将输出参数hwirq和type，分别表示HW interrupt ID和interupt type（触发方式等）。

D：解析完了，最终还是要调用irq\_create\_mapping函数来创建HW interrupt ID和IRQ number的映射关系。

E：如果有需要，调用irq\_set\_irq\_type函数设定trigger type

irq\_create\_mapping函数建立HW interrupt ID和IRQ number的映射关系。该接口函数以irq domain和HW interrupt ID为参数，返回IRQ number。具体的代码如下：

```c
unsigned int irq_create_mapping(struct irq_domain *domain, 
                irq_hw_number_t hwirq) 
{ 
    unsigned int hint; 
    int virq;

如果映射已经存在，那么不需要映射，直接返回 
    virq = irq_find_mapping(domain, hwirq); 
    if (virq) { 
        return virq; 
    }


    hint = hwirq % nr_irqs;－－－－－－－分配一个IRQ 描述符以及对应的irq number 
    if (hint == 0) 
        hint++; 
    virq = irq_alloc_desc_from(hint, of_node_to_nid(domain->of_node)); 
    if (virq <= 0) 
        virq = irq_alloc_desc_from(1, of_node_to_nid(domain->of_node)); 
    if (virq <= 0) { 
        pr_debug("-> virq allocation failed\n"); 
        return 0; 
    }

    if (irq_domain_associate(domain, virq, hwirq)) {－－－建立mapping 
        irq_free_desc(virq); 
        return 0; 
    }

    return virq; 
}
```

对于分配中断描述符这段代码，后续的文章会详细描述。这里简单略过，反正，指向完这段代码，我们就可以或者一个IRQ number以及其对应的中断描述符了。程序注释中没有使用IRQ number而是使用了virtual interrupt number这个术语。virtual interrupt number还是重点理解“virtual”这个词，所谓virtual，其实就是说和具体的硬件连接没有关系了，仅仅是一个number而已。具体建立映射的函数是irq\_domain\_associate函数，代码如下：

```c
int irq_domain_associate(struct irq_domain *domain, unsigned int virq, 
             irq_hw_number_t hwirq) 
{ 
    struct irq_data *irq_data = irq_get_irq_data(virq); 
    int ret;

    mutex_lock(&irq_domain_mutex); 
    irq_data->hwirq = hwirq; 
    irq_data->domain = domain; 
    if (domain->ops->map) { 
        ret = domain->ops->map(domain, virq, hwirq);－－－调用irq domain的map callback函数 
    }

    if (hwirq < domain->revmap_size) { 
        domain->linear_revmap[hwirq] = virq;－－－－填写线性映射lookup table的数据 
    } else { 
        mutex_lock(&revmap_trees_mutex); 
        radix_tree_insert(&domain->revmap_tree, hwirq, irq_data);－－向radix tree插入一个node 
        mutex_unlock(&revmap_trees_mutex); 
    } 
    mutex_unlock(&irq_domain_mutex);

    irq_clear_status_flags(virq, IRQ_NOREQUEST); －－－该IRQ已经可以申请了，因此clear相关flag

    return 0; 
}
```

# 7 将HW interrupt ID转成IRQ number

创建了庞大的HW interrupt ID到IRQ number的mapping DB，最终还是要使用。具体的使用场景是在CPU相关的处理函数中，程序会读取硬件interrupt ID，并转成IRQ number，调用对应的irq event handler。在本章中，我们以一个级联的GIC系统为例，描述转换过程

## 7.1 GIC driver初始化

上面已经描述了root GIC的的初始化，我们再来看看second GIC的初始化。具体代码在gic\_of\_init->gic\_init\_bases中，如下：

```c
void __init gic_init_bases(unsigned int gic_nr, int irq_start, 
               void __iomem *dist_base, void __iomem *cpu_base, 
               u32 percpu_offset, struct device_node *node) 
{ 
    irq_hw_number_t hwirq_base; 
    struct gic_chip_data *gic; 
    int gic_irqs, irq_base, i;

…… 
对于second GIC 
        hwirq_base = 32;  
        gic_irqs = 系统支持的所有的中断数目－32。之所以减去32主要是因为对于second GIC，其0～15号HW interrupt 是for IPI的，因此要去掉。而16～31号HW interrupt 是for PPI的，也要去掉。也正因为如此hwirq_base从32开始


    irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());申请gic_irqs个IRQ资源，从16号开始搜索IRQ number。由于是second GIC，申请的IRQ基本上会从root GIC申请的最后一个IRQ号＋1开始


    gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base, 
                    hwirq_base, &gic_irq_domain_ops, gic);－－－向系统注册irq domain并创建映射

…… 
}
```

second GIC初始化之后，该irq domain的HW interrupt ID和IRQ number的映射关系已经建立，保存在线性lookup table中，size等于GIC支持的中断数目，具体如下：

index 0～32对应的IRQ无效

root GIC申请的最后一个IRQ号＋1  <------------------>32号HW interrupt ID

root GIC申请的最后一个IRQ号＋2  <------------------>33号HW interrupt ID

……

OK，我们回到gic的初始化函数，对于second GIC，还有其他部分的初始化内容：

```c
int __init gic_of_init(struct device_node *node, struct device_node *parent) 
{

……

    if (parent) { 
        irq = irq_of_parse_and_map(node, 0);－－解析second GIC的interrupts属性，并进行mapping，返回IRQ number 
        gic_cascade_irq(gic_cnt, irq);－－－设置handler 
    } 
…… 
}
```

上面的初始化函数去掉和级联无关的代码。对于root GIC，其传入的parent是NULL，因此不会执行级联部分的代码。对于second GIC，它是作为其parent（root GIC）的一个普通的irq source，因此，也需要注册该IRQ的handler。由此可见，非root的GIC的初始化分成了两个部分：一部分是作为一个interrupt controller，执行和root GIC一样的初始化代码。另外一方面，GIC又作为一个普通的interrupt generating device，需要象一个普通的设备驱动一样，注册其中断handler。

irq\_of\_parse\_and\_map函数相信大家已经熟悉了，这里不再描述。gic\_cascade\_irq函数如下：

```c
void __init gic_cascade_irq(unsigned int gic_nr, unsigned int irq) 
{ 
    if (irq_set_handler_data(irq, &gic_data[gic_nr]) != 0)－－－设置handler data 
        BUG(); 
    irq_set_chained_handler(irq, gic_handle_cascade_irq);－－－设置handler 
}
```

## 7.2 具体如何在中断处理过程中，将HW interrupt ID转成IRQ number

在系统的启动过程中，经过了各个interrupt controller以及各个外设驱动的努力，整个interrupt系统的database（将HW interrupt ID转成IRQ number的数据库，这里的数据库不是指SQL lite或者oracle这样通用数据库软件）已经建立。一旦发生硬件中断，经过CPU architecture相关的中断代码之后，会调用irq handler，该函数的一般过程如下：

（1）首先找到root interrupt controller对应的irq domain。

（2）根据HW 寄存器信息和irq domain信息获取HW interrupt ID

（3）调用irq\_find\_mapping找到HW interrupt ID对应的irq number

（4）调用handle\_IRQ（对于ARM平台）来处理该irq number

对于级联的情况，过程类似上面的描述，但是需要注意的是在步骤4中不是直接调用该IRQ的hander来处理该irq number因为，这个irq需要各个interrupt controller level上的解析。举一个简单的二阶级联情况：假设系统中有两个interrupt controller，A和B，A是root interrupt controller，B连接到A的13号HW interrupt ID上。在B interrupt controller初始化的时候，除了初始化它作为interrupt controller的那部分内容，还有初始化它作为root interrupt controller A上的一个普通外设这部分的内容。最重要的是调用irq\_set\_chained\_handler设定handler。这样，在上面的步骤4的时候，就会调用13号HW interrupt ID对应的handler（也就是B的handler），在该handler中，会重复上面的（1）～（4）。