- 1 概述
- 2 历史
- 3 接口
    - 3.1 向系统注册irq domain
    - 3.2 为irq domain创建映射
- 4 数据结构描述
    - 4.1 irq domain的callback接口
    - 4.2 irq domain
- 5 中断相关的Device Tree知识回顾
- 6 Mapping DB的建立
    - 6.1 概述
    - 6.2 interrupt controller初始化的过程中，注册irq domain
    - 6.3 在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系
- 7 将HW interrupt ID转成IRQ number
    - 7.1 GIC driver初始化
    - 7.2 具体如何在中断处理过程中，将HW interrupt ID转成IRQ number

# 1 概述

General Purpose Input Output （通用输入/输出）简称为GPIO，通用IO口, 或总线扩展器，人们利用工业标准I2C、SMBus或SPI接口简化了I/O口的扩展。

在linux kernel中，我们使用下面**两个ID**来**标识一个来自外设的中断**：

1、**IRQ number**。**CPU**需要为**每一个外设中断编号**，我们称之IRQ Number。这个IRQ number是一个**虚拟的interrupt ID，和硬件无关(！！！**)，仅仅是被CPU用来标识一个外设中断。

2、**HW interrupt ID**。对于**interrupt controller**而言，它收集了**多个外设的interrupt request line并向上传递**，因此，**interrupt controller**需要**对外设中断进行编码(！！！**)。Interrupt controller用HW interrupt ID来标识外设的中断。在**interrupt controller级联**的情况下，仅仅用**HW interrupt ID已经不能唯一标识一个外设中断(！！！**)，还需要知道该**HW interrupt ID所属的interrupt controller（HW interrupt ID在不同的Interrupt controller上是会重复编码的**）。

这样，CPU和interrupt controller在标识中断上就有了一些不同的概念，但是，对于**驱动工程师**而言，我们和CPU视角是一样的，我们**只希望得到一个IRQ number**，而不关系具体是哪个interrupt controller上的哪个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将**HW interrupt ID映射到IRQ number上来的机制**，这就是本文主要的内容。

Linux使用**IRQ domain**来描述一个**中断控制器（IRQ Controller**）所管理的**中断源**。换句话说，**每个中断控制器**都有自己的**domain**。我们可以将**IRQ Domain**看作是**IRQ Controller的软件抽象(！！！**)。

这里所说的“**中断控制器**”，不仅指**硬件上**实际存在的**中断控制器**，也可以是一个“**虚拟”的中断控制器**。例如，假设我们有**一块CPU**，它有**多个GPIO Pin**可以**作为外部中断源使用**（事实上**大多数嵌入式CPU**都有这样的GPIO）。我们还假定**所有的GPIO中断**都**复用**到**该CPU**的**同一个中断向量(！！！**)。在这样的情况下，这**多个GPIO中断**就可以**抽象成一个虚拟的中断控制器**，它连接到**CPU的某个中断向量(某一个！！！**)上。

这样做的好处在于，可以将“**对中断控制器(！！！**)的**中断响应**”和“**对产生中断**的**外部设备(！！！**)的**中断响应**”分离开来。

我们还是看**一个例子**，假定我们有**若干个GPIO**，分别接了**不同外设**（如**按键**、外部**以太网控制器**等），当这些**外设产生中断**的时候，CPU内部的**GPIO控制器**会置位相应的**中断标志位**，并**向CPU提交中断请求**。这样，对**每一个外设中断**，我们实际上要进行**两级中断服务(！！！**)：第一级中断服务判断是**哪个GPIO产生了中断**，并需要**清除GPIO控制器内部**某个寄存器中的某个标志位；第二级中断服务才是**服务产生中断的那个外设**的。显然，**第一级中断服务代码**对每个产生GPIO中断的**外设是类似的(！！！**)。有了IRQ Domain的帮助，**第一级**中断服务代码就**可以统一**，**设备驱动程序**只需要关心**第二级中断服务**就可以了。

# 2 历史

关于**HW interrupt ID**映射到**IRQ number**上这事，在**过去**系统只有**一个interrupt controller**的时候还是很简单的，**中断控制器**上**实际的HW interrupt line的编号**可以**直接变成IRQ number**。例如我们大家都熟悉的SOC内嵌的interrupt controller，这种controller多半有中断状态寄存器，这个寄存器可能有64个bit（也可能更多），**每个bit**就是**一个IRQ number**，可以**直接进行映射**。这时候，GPIO的中断在中断控制器的状态寄存器中只有一个bit，因此所有的GPIO中断只有一个IRQ number，在该通用GPIO中断的irq handler中进行deduplex，将各个具体的GPIO中断映射到其相应的IRQ number上。如果你是一个足够老的工程师，应该是经历过这个阶段的。

随着linux kernel的发展，将**interrupt controller**抽象成**irqchip**这个概念越来越流行，甚至**GPIO controller**也可以被看出一个**interrupt controller chip**，这样，系统中至少有**两个中断控制器**了，一个**传统意义的中断控制器**，一个是**GPIO controller type的中断控制器**。随着系统复杂度加大，外设中断数据增加，实际上系统可以需要**多个中断控制器进行级联**，面对这样的趋势，linux kernel工程师如何应对？答案就是**irq domain**这个概念。

我们听说过很多的domain，power domain，clock domain等等，所谓domain，就是**领域，范围**的意思，也就是说，任何的定义出了这个范围就没有意义了。系统中**所有的interrupt controller**会形成**树状结构**，对于**每个interrupt controller**都可以**连接若干个外设的中断请求**（我们称之**interrupt source**），interrupt controller会对连接其上的**interrupt source**（根据其在Interrupt controller中**物理特性**）进行**编号（也就是HW interrupt ID**了）。但这个编号**仅仅限制在本interrupt controller范围**内。

# 3 接口

## 3.1 向系统注册irq domain

**具体如何进行映射**是**interrupt controller自己**的事情，不过，有软件架构思想的工程师更愿意对形形色色的**interrupt controller进行抽象**，对如何进行**HW interrupt ID**到**IRQ number**映射关系上进行**进一步的抽象**。

一个**中断控制器**中HW interrupt ID到IRQ number的**具体映射是内部处理(！！！**), 但是相应的映射表或者映射树需要软件自己定义.

因此，**通用中断处理模块**中有一个**irq domain的子模块**，该模块将这种**映射关系**分成了**三类**：

（1）**线性映射**。其实就是一个**lookup table**，**HW interrupt ID**作为**index**，通过**查表**可以获取**对应的IRQ number**。对于Linear map而言，interrupt controller对其HW interrupt ID进行编码的时候要满足一定的条件：**hw ID不能过大**，而且ID排列最好是紧密的。对于线性映射，其接口API如下：

```c
static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node, 
                     unsigned int size, //该interrupt domain支持多少IRQ 
                     const struct irq_domain_ops *ops, //callback函数 
                     void *host_data) //driver私有数据 
{ 
    return __irq_domain_add(of_node, size, size, 0, ops, host_data); 
}
```

（2）**Radix Tree map**。建立一个**Radix Tree**来维护**HW interrupt ID到IRQ number映射**关系。**HW interrupt ID**作为**lookup key**，在Radix Tree检索到IRQ number。如果的确不能满足线性映射的条件，可以考虑Radix Tree map。实际上，内核中使用**Radix Tree map**的只有**powerPC和MIPS**的硬件平台。对于Radix Tree map，其接口API如下：

```c
static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node, 
                     const struct irq_domain_ops *ops, 
                     void *host_data) 
{ 
    return __irq_domain_add(of_node, 0, ~0, 0, ops, host_data); 
}
```

（3）**no map**。有些**中断控制器**很强，可以通过寄存器配置HW interrupt ID而不是由物理连接决定的。例如PowerPC 系统使用的MPIC (Multi\-Processor Interrupt Controller)。在这种情况下，不需要进行映射，我们**直接把IRQ number写入HW interrupt ID配置寄存器**就OK了，这时候，生成的HW interrupt ID就是IRQ number，也就**不需要进行mapping**了。对于这种类型的映射，其接口API如下：

```c
static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node, 
                     unsigned int max_irq, 
                     const struct irq_domain_ops *ops, 
                     void *host_data) 
{ 
    return __irq_domain_add(of_node, 0, max_irq, max_irq, ops, host_data); 
}
```

这类接口的逻辑很简单，根据自己的**映射类型**，注册一个**中断控制器(irq\_domain**), **初始化struct irq\_domain中的各个成员**，调用\_\_irq\_domain\_add将**该irq domain挂入irq\_domain\_list的全局列表(！！！**)。

**创建IRQ Domain**：irq\_domain\_add\_linear和irq\_domain\_add\_tree。对于大多数情况，前一个函数就够用了：它在**中断源**和**irq\_desc**之间建立**线性映射**。如果**硬件**提供的可用**中断源较多(>256**)，而**实际**用到的**很少**，就可以**用后者(R树！！！**)，**避免无用的表项**。

## 3.2 为irq domain创建映射

上节的内容主要是**向系统注册一个irq domain**，具体**HW interrupt ID和IRQ number的映射关系都是空的**，因此，具体各个irq domain如何管理映射所需要的database还是需要建立的。例如：对于**线性映射的irq domain**，我们**需要建立线性映射的lookup table**，对**于Radix Tree map**，我们要把那个反应IRQ number和HW interrupt ID的**Radix tree**建立起来。

**创建映射**有**四个接口函数**：

（1）调用**irq\_create\_mapping**函数建立HW interrupt ID和IRQ number的映射关系。该接口函数以**irq domain**和**HW interrupt ID为参数**，返回**IRQ number（这个IRQ number是动态分配的**）。该函数的原型定义如下：

```c
extern unsigned int irq_create_mapping(struct irq_domain *host, 
                       irq_hw_number_t hwirq);
```

**驱动**调用该函数的时候**必须提供HW interrupt ID**，也就是意味着**driver**知道自己使用的HW interrupt ID，而**一般情况**下，**HW interrupt ID**其实**对具体的driver应该是不可见(！！！**)的，不过有些场景比较特殊，例如**GPIO类型的中断**，它的**HW interrupt ID和GPIO有着特定的关系(！！！**)，driver知道自己使用那个GPIO，也就是知道使用哪一个HW interrupt ID了。

（2）irq\_create\_strict\_mappings。这个接口函数用来为**一组HW interrupt ID建立映射**。具体函数的原型定义如下：

```c
extern int irq_create_strict_mappings(struct irq_domain *domain, 
                      unsigned int irq_base, 
                      irq_hw_number_t hwirq_base, int count);
```

（3）irq\_create\_of\_mapping。看到函数名字中的**of（open firmware**），我想你也可以猜到了几分，这个接口当然是利用**device tree**进行映射关系的建立。具体函数的原型定义如下：

```c
extern unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data);
```

通常，**一个普通设备**的**device tree node**已经描述了**足够的中断信息**，在这种情况下，该设备的**驱动在初始化**的时候可以调用**irq\_of\_parse\_and\_map**这个接口函数进行**该device node**和**中断相关的内容**（interrupts和interrupt\-parent属性）进行**分析**，并建立**映射关系**，具体代码如下：

```c
unsigned int irq_of_parse_and_map(struct device_node *dev, int index) 
{ 
    struct of_phandle_args oirq;

    if (of_irq_parse_one(dev, index, &oirq)) //分析device node中的interrupt相关属性 
        return 0;

    return irq_create_of_mapping(&oirq);  //创建映射，并返回对应的IRQ number 
}
```

对于一个**使用Device tree**的**普通驱动程序**（我们推荐这样做），**基本上初始化**需要调用**irq\_of\_parse\_and\_map获取IRQ number(！！！**)，然后调用**request\_threaded\_irq申请**中断handler。

（4）irq\_create\_direct\_mapping。这是给no map那种类型的interrupt controller使用的，这里不再赘述。

# 4 数据结构描述

## 4.1 irq domain的callback接口

**struct irq\_domain\_ops**抽象了一个**irq domain的callback函数**，定义如下：

```c
[include/linux/irqdomain.h]
struct irq_domain_ops { 
    int (*match)(struct irq_domain *d, struct device_node *node); 
    int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw); 
    void (*unmap)(struct irq_domain *d, unsigned int virq); 
    int (*xlate)(struct irq_domain *d, struct device_node *node, 
             const u32 *intspec, unsigned int intsize, 
             unsigned long *out_hwirq, unsigned int *out_type); 
};
```

我们先看**xlate函数**，语义是**翻译（translate**）的意思，那么到底翻译什么呢？在**DTS文件(！！！**)中，各个**使用中断**的**device node**会通过**一些属性**（例如**interrupts和interrupt\-parent属性**）来**提供中断信息给kernel**, 以便**kernel**可以正确的进行**driver的初始化动作**。这里，**interrupts属性**所表示的**interrupt specifier**只能由**具体的interrupt controller（也就是irq domain）来解析**。而**xlate函数**就是将**指定的设备（node参数**）上**若干(！！！**)个（int size参数）**中断属性**（intspec参数）翻译成**HW interrupt ID（out\_hwirq参数**）和**trigger类型（！！！out\_type**）。

**match**是**判断**一个**指定的interrupt controller（node参数**）**是否**和一个**irq domain匹配（d参数**），如果**匹配**的话，**返回1**。实际上，内核中**很少定义这个callback函数(！！！**)，实际上**struct irq\_domain**中有一个**of\_node**指向了**对应的interrupt controller**的**device node**，因此，如果**不提供该函数**，那么**default的匹配函数**其实就是**判断irq domain**的**of\_node成员**是否等于传入的**node参数**。

**map和unmap**是**操作相反**的函数，我们描述其中之一就OK了。**调用map**函数的时机是在**创建（或者更新）HW interrupt ID（hw参数）和IRQ number（virq参数）关系的时候**。其实，从**发生一个中断**到**调用该中断的handler**仅仅调用一个**request\_threaded\_irq**是不够的，还需要针对**该irq number**设定：

（1）设定该**IRQ number**对应的**中断描述符**（struct irq\_desc）的**irq chip**

（2）设定该IRQ number对应的**中断描述符**的**highlevel irq\-events handler**

（3）设定该IRQ number对应的中断描述符的**irq chip data**

这些设定**不适合由具体的硬件驱动**来设定，因此在**Interrupt controller**，也就是**irq domain的callback函数中设定(！！！**)。

## 4.2 irq domain

在内核中，irq domain的概念由struct irq\_domain表示：

```c
struct irq_domain { 
    struct list_head link; 
    const char *name; 
    const struct irq_domain_ops *ops; //callback函数 
    void *host_data;

    /* Optional data */ 
    struct device_node *of_node; //该interrupt domain对应的interrupt controller的device node 
    struct irq_domain_chip_generic *gc; //generic irq chip的概念，本文暂不描述

    /* reverse map data. The linear map gets appended to the irq_domain */
    irq_hw_number_t hwirq_max; //该domain中最大的那个HW interrupt ID 
    unsigned int revmap_direct_max_irq; －－－－ 
    unsigned int revmap_size; //线性映射的size，对于Radix Tree map和no map，该值等于0 
    struct radix_tree_root revmap_tree; //Radix Tree map使用到的radix tree root node 
    unsigned int linear_revmap[]; //线性映射使用的lookup table 
};
```

linux内核中，**所有的irq domain**被挂入**一个全局链表(！！！**)，链表头**定义**如下：

```c
static LIST\_HEAD(irq_domain_list);
```

struct irq\_domain中的**link成员**就是挂入这个队列的节点。通过**irq\_domain\_list这个指针(！！！**)，可以获取**整个系统**中**HW interrupt ID**和**IRQ number的mapping DB**。

**host\_data**定义了**底层interrupt controller**使用的**私有数据**，和**具体的interrupt controller**相关（对于**GIC**，该指针指向一个**struct gic\_chip\_data**数据结构）。

**irq\_domain**是**统一的IRQ Controller的软件抽象**, 所以需要将**各种类型映射的相关数据**都放在这**一个数据结构**中.

对于**线性映射**：

（1）**linear\_revmap**保存了一个**线性的lookup table**，**index**是**HW interrupt ID**，**table**中保存了**IRQ number(！！！**)值

（2）**revmap\_size**等于线性的lookup table的**size**。

（3）**hwirq\_max**保存了**最大的HW interrupt ID**

（4）revmap\_direct\_max\_irq没有用，设定为0。revmap\_tree没有用。

对于**Radix Tree map**：

（1）linear\_revmap没有用，revmap\_size等于0。

（2）hwirq\_max没有用，设定为一个最大值。

（3）revmap\_direct\_max\_irq没有用，设定为0。

（4）**revmap\_tree**指向**Radix tree**的**root node**。

# 5 中断相关的Device Tree知识回顾

想要进行**映射**，首先要了解**interrupt controller的拓扑结构**。系统中的**interrupt controller的拓扑结构(！！！**)以及**其interrupt request line的分配(！！！**)情况（分配给哪一个具体的外设）都在**Device Tree Source文件**中通过下面的**属性**给出了描述。这些内容在Device Tree的三份文档中给出了一些描述，这里简单总结一下：

对于那些**产生中断的外设**，我们需要定义**interrupt\-parent**和**interrupts属性**：

（1）**interrupt\-parent**。表明**该外设**的**interrupt request line物理**的连接到了**哪一个中断控制器**上

（2）**interrupts**。这个属性描述了具体**该外设**产生的**interrupt的细节信息（也就是传说中的interrupt specifier**）。例如：**HW interrupt ID**（由**该外设**的**device node**中的**interrupt\-parent**指向的**interrupt controller解析**）、**interrupt触发类型**等。

对于**Interrupt controller**，我们需要定义**interrupt\-controller**和\#**interrupt\-cells**的属性：

（1）interrupt\-controller。表明该device node就是一个**中断控制器**

（2）\#interrupt\-cells。该中断控制器用**多少个cell**（**一个cell**就是一个**32\-bit的单元**）描述一个外设的**interrupt request line**。具体**每个cell**表示什么样的含义由interrupt controller**自己定义**。

（3）**interrupts**和**interrupt\-parent**。对于那些**不是root**的interrupt controller，其本身也是作为一个产生中断的外设连接到其他的interrupt controller上，因此**也需要定义interrupts和interrupt\-parent的属性**。

# 6 Mapping DB的建立

## 6.1 概述

系统中HW interrupt ID和IRQ number的**mapping DB**是在**整个系统初始化**的过程中建立起来的，过程如下：

（1）**DTS文件**描述了系统中的**interrupt controller**以及**外设IRQ的拓扑结构(！！！**)，在linux kernel**启动**的时候，由**bootloader传递给kernel**（实际传递的是**！！！DTB！！！**）。

（2）在**Device Tree初始化**的时候，形成了系统内**所有的device node的树状结构(！！！**)，当然其中包括所有和中断拓扑相关的数据结构（所有的interrupt controller的node和使用中断的外设node）

（3）在**machine driver初始化**的时候会调用**of\_irq\_init函数**，在该函数中会**扫描所有interrupt controller的节点**，并调用**适合的interrupt controller driver进行初始化**。毫无疑问，**初始化需要注意顺序(！！！**)，首先**初始化root**，然后**first level**，second level，最后是**leaf node**。在初始化的过程中，一般会调用上节中的接口函数向系统**增加irq domain**。**有些**interrupt controller会在其driver初始化的过程中创建映射

（4）在各个**driver初始化**的过程中，**创建映射**

## 6.2 interrupt controller初始化的过程中，注册irq domain

我们**以GIC的代码为例**。具体代码在gic\_of\_init->gic\_init\_bases中，如下：

```c
void __init gic_init_bases(unsigned int gic_nr, int irq_start, 
               void __iomem *dist_base, void __iomem *cpu_base, 
               u32 percpu_offset, struct device_node *node) 
{ 
    irq_hw_number_t hwirq_base; 
    struct gic_chip_data *gic; 
    int gic_irqs, irq_base, i;

…… 
对于root GIC 
        hwirq_base = 16; 
        gic_irqs = 系统支持的所有的中断数目－16。之所以减去16主要是因为root GIC的0～15号HW interrupt 是for IPI的，因此要去掉。也正因为如此hwirq_base从16开始

    // 申请gic_irqs个IRQ资源，从16号开始搜索IRQ number。由于是root GIC，申请的IRQ基本上会从16号开始
    irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());

    // 向系统注册irq domain并创建映射
    gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base, 
                    hwirq_base, &gic_irq_domain_ops, gic);

…… 
}
```

很遗憾，在**GIC**的代码中**没有调用标准的注册irq domain**的接口函数。要了解其背后的原因，我们需要回到过去。在**旧的linux kernel**中，**ARM**体系结构的**代码不甚理想**。在arch/arm目录充斥了很多**board specific**的代码，其中定义了很多**具体设备相关的静态表格**，这些表格规定了各个device使用的资源，当然，其中包括**IRQ资源**。在这种情况下，**各个外设的IRQ是固定**的（如果作为驱动程序员的你足够老的话，应该记得很长篇幅的针对IRQ number的宏定义），也就是说，**HW interrupt ID和IRQ number的关系是固定的**。一旦关系固定，我们就可以在interupt controller的代码中创建这些映射关系。具体代码如下：

```c
struct irq_domain *irq_domain_add_legacy(struct device_node *of_node, 
                     unsigned int size, 
                     unsigned int first_irq, 
                     irq_hw_number_t first_hwirq, 
                     const struct irq_domain_ops *ops, 
                     void *host_data) 
{ 
    struct irq_domain *domain;

    domain = __irq_domain_add(of_node, first_hwirq + size,－－－－注册irq domain 
                  first_hwirq + size, 0, ops, host_data); 
    if (!domain) 
        return NULL;

    irq_domain_associate_many(domain, first_irq, first_hwirq, size); －－－创建映射

    return domain; 
}
```

这时候，对于**这个版本**的**GIC driver**而言，初始化之后，HW interrupt ID和IRQ number的映射关系已经建立，保存在线性lookup table中，size等于GIC支持的中断数目，具体如下：

index 0～15对应的IRQ无效

16号IRQ  <------------------>16号HW interrupt ID

17号IRQ  <------------------>17号HW interrupt ID

……

如果想充分发挥Device Tree的威力，3.14版本中的GIC代码需要修改。

## 6.3 在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系

我们上面的描述过程中，已经提及：设备的**驱动在初始化**的时候可以调用**irq\_of\_parse\_and\_map**这个接口函数进行**该device node**中和**中断相关的内容**（interrupts和interrupt\-parent属性）进行**分析**，并**建立映射关系**，具体代码如下：

```c
unsigned int irq_of_parse_and_map(struct device_node *dev, int index) 
{ 
    struct of_phandle_args oirq;
    // 分析device node中的interrupt相关属性
    if (of_irq_parse_one(dev, index, &oirq)) 
        return 0;
    // 创建映射
    return irq_create_of_mapping(&oirq); 
}
```

我们再来看看**irq\_create\_of\_mapping**函数如何**创建映射**：

```c
unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data) 
{ 
    struct irq_domain *domain; 
    irq_hw_number_t hwirq; 
    unsigned int type = IRQ_TYPE_NONE; 
    unsigned int virq;

    domain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain;－－A 
    if (!domain) { 
        return 0; 
    }


    if (domain->ops->xlate == NULL)－－B 
        hwirq = irq_data->args[0]; 
    else { 
        if (domain->ops->xlate(domain, irq_data->np, irq_data->args,－－C 
                    irq_data->args_count, &hwirq, &type)) 
            return 0; 
    }

    /* Create mapping */ 
    virq = irq_create_mapping(domain, hwirq);－－D 
    if (!virq) 
        return virq;

    /* Set type if specified and different than the current one */ 
    if (type != IRQ_TYPE_NONE && 
        type != irq_get_trigger_type(virq)) 
        irq_set_irq_type(virq, type);－－E 
    return virq; 
}
```

A：这里的代码主要是**找到irq domain**。这是根据传递进来的参数**irq\_data**的np成员来**寻找**的，具体定义如下：

```c
struct of_phandle_args { 
    struct device_node *np;//指向了外设对应的interrupt controller的device node 
    int args_count;//该外设定义的interrupt相关属性的个数 
    uint32_t args[MAX_PHANDLE_ARGS];//具体的interrupt相当属性的定义 
};
```

B：如果**没有定义xlate函数**，那么取**interrupts属性**的**第一个cell**作为**HW interrupt ID**。

C：解铃还需系铃人，**interrupts属性**最好由interrupt controller（也就是**irq domain）解释**。如果**xlate**函数能够**完成属性解析**，那么将**输出参数hwirq和type**，分别表示HW interrupt ID和interupt type（触发方式等）。

D：解析完了，最终还是要调用**irq\_create\_mapping函数**来创建HW interrupt ID和IRQ number的**映射关系**。

E：如果**有需要**，调用**irq\_set\_irq\_type函数**设定**trigger type**

irq\_create\_mapping函数建立HW interrupt ID和IRQ number的**映射关系**。该接口函数以**irq domain**和**HW interrupt ID为参数**，返回**IRQ number**。具体的代码如下：

```c
unsigned int irq_create_mapping(struct irq_domain *domain, 
                irq_hw_number_t hwirq) 
{ 
    unsigned int hint; 
    int virq;

    // 如果映射已经存在，那么不需要映射，直接返回 
    virq = irq_find_mapping(domain, hwirq); 
    if (virq) { 
        return virq; 
    }

    // 分配一个IRQ描述符以及对应的irq number
    hint = hwirq % nr_irqs;
    if (hint == 0) 
        hint++; 
    virq = irq_alloc_desc_from(hint, of_node_to_nid(domain->of_node)); 
    if (virq <= 0) 
        virq = irq_alloc_desc_from(1, of_node_to_nid(domain->of_node)); 
    if (virq <= 0) { 
        pr_debug("-> virq allocation failed\n"); 
        return 0; 
    }
    // 建立mapping
    if (irq_domain_associate(domain, virq, hwirq)) { 
        irq_free_desc(virq); 
        return 0; 
    }

    return virq; 
}
```

对于**分配中断描述符**这段代码，后续的文章会详细描述。这里简单略过，反正，指向完这段代码，我们就可以或者一个IRQ number以及其对应的中断描述符了。程序**注释**中**没有使用IRQ number**而是使用了**virtual interrupt number**这个术语。virtual interrupt number还是重点理解“virtual”这个词，所谓virtual，其实就是说和具体的硬件连接没有关系了，仅仅是一个number而已。**具体建立映射**的函数是irq\_domain\_associate函数，代码如下：

```c
int irq_domain_associate(struct irq_domain *domain, unsigned int virq, 
             irq_hw_number_t hwirq) 
{ 
    struct irq_data *irq_data = irq_get_irq_data(virq); 
    int ret;

    mutex_lock(&irq_domain_mutex); 
    irq_data->hwirq = hwirq; 
    irq_data->domain = domain; 
    if (domain->ops->map) { 
        ret = domain->ops->map(domain, virq, hwirq);－－－调用irq domain的map callback函数 
    }

    if (hwirq < domain->revmap_size) { 
        domain->linear_revmap[hwirq] = virq;－－－－填写线性映射lookup table的数据 
    } else { 
        mutex_lock(&revmap_trees_mutex); 
        radix_tree_insert(&domain->revmap_tree, hwirq, irq_data);－－向radix tree插入一个node 
        mutex_unlock(&revmap_trees_mutex); 
    } 
    mutex_unlock(&irq_domain_mutex);

    irq_clear_status_flags(virq, IRQ_NOREQUEST); －－－该IRQ已经可以申请了，因此clear相关flag

    return 0; 
}
```

# 7 将HW interrupt ID转成IRQ number

创建了庞大的HW interrupt ID到IRQ number的mapping DB，最终还是要使用。具体的**使用场景**是在**CPU相关的处理函数**中，程序会**读取硬件interrupt ID**，并**转成IRQ number**，调用对应的irq event handler。在本章中，我们以一个级联的GIC系统为例，描述转换过程

## 7.1 GIC driver初始化

上面已经描述了**root GIC的的初始化**，我们再来看看**second GIC的初始化**。具体代码在gic\_of\_init->gic\_init\_bases中，如下：

```c
void __init gic_init_bases(unsigned int gic_nr, int irq_start, 
               void __iomem *dist_base, void __iomem *cpu_base, 
               u32 percpu_offset, struct device_node *node) 
{ 
    irq_hw_number_t hwirq_base; 
    struct gic_chip_data *gic; 
    int gic_irqs, irq_base, i;

…… 
对于second GIC 
        hwirq_base = 32;  
        gic_irqs = 系统支持的所有的中断数目－32。之所以减去32主要是因为对于second GIC，其0～15号HW interrupt 是for IPI的，因此要去掉。而16～31号HW interrupt 是for PPI的，也要去掉。也正因为如此hwirq_base从32开始

    // 申请gic_irqs个IRQ资源，从16号开始搜索IRQ number。由于是second GIC，申请的IRQ基本上会从root GIC申请的最后一个IRQ号＋1开始
    irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());

    // 向系统注册irq domain并创建映射
    gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base, 
                    hwirq_base, &gic_irq_domain_ops, gic);

…… 
}
```

**second GIC初始化**之后，该irq domain的HW interrupt ID和IRQ number的映射关系已经建立，保存在**线性lookup table**中，size等于GIC支持的中断数目，具体如下：

index 0～32对应的IRQ无效

**root GIC申请的最后一个IRQ号**＋1  <--------->**32号HW interrupt ID**

root GIC申请的最后一个IRQ号＋2  <------>33号HW interrupt ID

……

OK，我们回到gic的初始化函数，对于second GIC，还有其他部分的初始化内容：

```c
int __init gic_of_init(struct device_node *node, struct device_node *parent) 
{

……

    if (parent) { 
        irq = irq_of_parse_and_map(node, 0);－－解析second GIC的interrupts属性，并进行mapping，返回IRQ number 
        gic_cascade_irq(gic_cnt, irq);－－－设置handler 
    } 
…… 
}
```

上面的初始化函数**去掉和级联无关的代码**。对于**root GIC**，其传入的**parent是NULL**，因此**不会执行级联**部分的代码。对于**second GIC**，它是作为**其parent（root GIC**）的一个**普通的irq source**，因此，也需要**注册该IRQ的handler**。由此可见，**非root的GIC**的**初始化**分成了**两个部分**：一部分是**作为一个interrupt controller**，执行**和root GIC一样的初始化代码**。另外一方面，GIC又作为一个**普通的interrupt generating device**，需要象一个**普通的设备驱动一样**，**注册其中断handler**。

irq\_of\_parse\_and\_map函数相信大家已经熟悉了，这里不再描述。gic\_cascade\_irq函数如下：

```c
void __init gic_cascade_irq(unsigned int gic_nr, unsigned int irq) 
{ 
    if (irq_set_handler_data(irq, &gic_data[gic_nr]) != 0)－－－设置handler data 
        BUG(); 
    irq_set_chained_handler(irq, gic_handle_cascade_irq);－－－设置handler 
}
```

## 7.2 具体如何在中断处理过程中，将HW interrupt ID转成IRQ number

在系统的**启动**过程中，经过了各个**interrupt controller**以及**各个外设驱动**的努力，整个interrupt系统的database（将HW interrupt ID转成IRQ number的数据库，这里的数据库不是指SQL lite或者oracle这样通用数据库软件）已经建立。一旦发生**硬件中断**，经过CPU architecture相关的中断代码之后，会调用irq handler，该函数的一般过程如下：

（1）首先找到**root interrupt controller(！！！**)对应的**irq domain(！！！**)。

（2）根据**HW寄存器信息**和**irq domain信息**获取**HW interrupt ID**

（3）调用**irq\_find\_mapping**找到**HW interrupt ID**对应的**irq number**

（4）调用**handle\_IRQ（！！！对于ARM平台**）来处理该irq number

对于**级联的情况**，过程类似上面的描述，但是需要注意的是在**步骤4**中**不是直接调用该IRQ的hander**来处理该**irq number**。 因为，**这个irq**需要各个**interrupt controller level**上的解析。

举一个**简单的二阶级联**情况：假设系统中有**两个interrupt controller**，A和B，**A是root interrupt controller**，B连接到A的**13号HW interrupt ID**上。在**B interrupt controller初始化**的时候，除了初始化它作为**interrupt controller的那部分内容**，还有初始化它作为root interrupt controller A上的一个**普通外设**这部分的内容。最重要的是**调用irq\_set\_chained\_handler设定handler**。这样，在上面的步骤4的时候，就会**调用13号HW interrupt ID对应的handler（也就是B的handler**），在**该handler(！！！**)中，会重复上面的（1）～（4）。