
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [0 概述](#0-概述)

<!-- /code_chunk_output -->

# 0 概述

大部分概念如**Node**、**Pod**、**Replication Controller**、**Service**等都可以被看作一种**资源对象**，几乎所有资源对象都可以通过Kubernetes提供的**kubectl工具**（或者**API编程调用**）执行增、删、改、查等操作并将其保存在**etcd**中持久化存储。

声明一个**Kubernetes资源对象**, 注意一个**关键属性**：**apiVersion**。以下面的Pod声明为例，可以看到Pod这种资源对象归属于v1这个核心API。

![2019-08-13-08-29-55.png](./images/2019-08-13-08-29-55.png)

Kubernetes采用了"核心\+外围扩展"的设计思路, 核心稳定\+持续演进升级. 

大部分常见的核心资源对象都归属于v1这个核心API，比如Node、Pod、Service、Endpoints、Namespace、RC、PersistentVolume等。

可以采用**YAML**或**JSON格式**声明（定义或创建）一个**Kubernetes资源对象**，每个资源对象都有自己的特定语法格式（可以理解为数据库中一个特定的表）. 一些资源对象会**不断引入新的属性**. 为不影响当前功能情况下引入对新特性的支持, 两种典型方法.

⓵ 设计数据库表的时候，在每个表中都增加一个很长的备注字段，之后扩展的数据以某种格式（如XML、JSON、简单字符串拼接等）放入备注字段。

⓶ 直接修改数据库表，增加一个或多个新的列，此时程序的改动范围较大，风险更大

更加优雅的做法是:

先采用方法1实现这个新特性，经过几个版本的迭代，等新特性变得稳定成熟了以后，可以在后续版本中采用方法2升级到正式版。

为此，Kubernetes为**每个资源对象**都增加了类似数据库表里**备注字段**的通用属性**Annotations**，以实现方法1的升级。

比如Kubernetes 1.3版本引入的Pod的Init Container新特性

![2019-08-13-10-38-10.png](./images/2019-08-13-10-38-10.png)

在1.8版本后, 其定义被放入Pod的spec.initContainers

![2019-08-13-10-39-05.png](./images/2019-08-13-10-39-05.png)

