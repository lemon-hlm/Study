
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [ABAC授权模式详解](#abac授权模式详解)
- [Webhook授权模式详解](#webhook授权模式详解)

<!-- /code_chunk_output -->

当客户端发起API Server调用时，API Server内部要**先**进行**用户认证**，然后执行**用户授权流程**，即通过**授权策略**来决定一个**API调用是否合法**。

**对合法用户进行授权**并且随后在**用户访问时进行鉴权**，是权限与安全系统的重要一环。简单地说，授权就是授予不同的用户不同的访问权限。API Server目前支持以下几种授权策略（通过API Server的启动参数“--authorization-mode”设置）。

◎　AlwaysDeny：表示拒绝所有请求，一般用于测试。
◎　AlwaysAllow：允许接收所有请求，如果集群不需要授权流程，则可以采用该策略，这也是Kubernetes的默认配置。
◎　ABAC（Attribute-Based Access Control）：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制。
◎　Webhook：通过调用外部REST服务对用户进行授权。
◎　RBAC：Role-Based Access Control，基于角色的访问控制。
◎　Node：是一种专用模式，用于对kubelet发出的请求进行访问控制。

API Server在接收到请求后，会读取该请求中的数据，生成一个访问策略对象，如果在该请求中不带某些属性（如Namespace），则这些属性的值将根据属性类型的不同，设置不同的默认值（例如，为字符串类型的属性设置一个空字符串；为布尔类型的属性设置false；为数值类型的属性设置0）。然后将这个访问策略对象和授权策略文件中的所有访问策略对象逐条匹配，如果至少有一个策略对象被匹配，则该请求被鉴权通过，否则终止API调用流程，并返回客户端的错误调用码。

# ABAC授权模式详解

在API Server启用ABAC模式时，需要指定授权策略文件的路径和名称（--authorization- policy-file=SOME_FILENAME），授权策略文件里的每一行都以一个Map类型的JSON对象进行设置，这被称为“访问策略对象”。通过设置访问策略对象中的apiVersion、kind、spec属性来确定具体的授权策略，其中，apiVersion当前版本为abac.authorization.kubernetes.io/v1beta1；kind被设置为Policy；spec指详细的策略设置，包括主题属性、资源属性、非资源属性这三个字段，如下所述。

（1）主体属性

◎　user（用户名）：字符串类型，该字符串类型的用户名来源于Token文件（--token-auth-file参数设置的文件）或基本认证文件中用户名称段的值。
◎　group（用户组）：在被设置为“system:authenticated”时表示匹配所有已认证的请求，在被设置为“system:unauthenticated”时表示匹配所有未认证的请求。

（2）资源属性

◎　apiGroup（API组）：字符串类型，表明匹配哪些API Group，例如extensions或*（表示匹配所有API Group）。
◎　namespace（命名空间）：字符串类型，表明该策略允许访问某个Namespace的资源，例如kube-system或*（表示匹配所有Namespace）。
◎　resource（资源）：字符串类型，API资源对象，例如pods或*（表示匹配所有资源对象）。

（3）非资源属性

◎　nonResourcePath（非资源对象类路径）：非资源对象类的URL路径，例如/version或/apis，\*表示匹配所有非资源对象类的请求路径，也可以设置为子路径，/foo/\*表示匹配所有/foo路径下的所有子路径。
◎　readonly（只读标识）：布尔类型，当它的值为true时，表明仅允许GET请求通过。

下面对ABAC授权算法、使用kubectl时的授权机制、常见ABAC授权示例、以及如何对Service Account进行授权进行说明。

1.ABAC授权算法

API Server进行ABAC授权的算法为：在API Server收到请求之后，首先识别出请求携带的策略对象的属性，然后根据在策略文件中定义的策略对这些属性进行逐条匹配，以判定是否允许授权。如果有至少一条匹配成功，那么这个请求就通过了授权（不过还是可能在后续其他授权校验中失败）。常见的策略配置如下。

◎　要允许所有认证用户做某件事，可以写一个策略，将group属性设置为system:authenticated。
◎　要允许所有未认证用户做某件事，可以把策略的group属性设置为system:unauthenticated。
◎　要允许一个用户做任何事，将策略的apiGroup、namespace、resource和nonResourcePath属性设置为“*”即可。

2.使用kubectl时的授权机制

kubectl使用API Server的/api和/apis端点来获取版本信息。要验证kubectl create/update命令发送给服务器的对象，kubectl需要向OpenAPI进行查询，对应的URL路径为/openapi/v2。

当使用ABAC授权模式时，下列特殊资源必须显式地通过nonResourcePath属性进行设置。

◎　API版本协商过程中的/api、/api/\*、/apis、和/apis/\*。
◎　使用kubectl version命令从服务器获取版本时的/version。
◎　create/update操作过程中的/swaggerapi/\*。

在使用kubectl操作时，如果需要查看发送到API Server的HTTP请求，则可以将日志级别设置为8，例如：

```
# kubectl --v=8 version
```

3.常见的ABAC授权示例

下面通过几个授权策略文件（JSON格式）示例说明ABAC的访问控制用法。

（1）允许用户alice对所有资源做任何操作：

![2019-09-01-22-48-52.png](./images/2019-09-01-22-48-52.png)

（2）kubelet可以读取任意Pod：

![2019-09-01-22-49-06.png](./images/2019-09-01-22-49-06.png)

（3）kubelet可以读写Event对象：

![2019-09-01-22-49-19.png](./images/2019-09-01-22-49-19.png)

（4）用户bob只能读取projectCaribou中的Pod：

![2019-09-01-22-49-31.png](./images/2019-09-01-22-49-31.png)

（5）任何用户都可以对非资源类路径进行只读请求：

![2019-09-01-23-00-33.png](./images/2019-09-01-23-00-33.png)

如果添加了新的ABAC策略，则需要重启API Server以使其生效。

4.对Service Account进行授权

Service Account会自动生成一个ABAC用户名（username），用户名按照以下命名规则生成：

```
system:serviceaccount:<namespace>:<serviceaccountname>
```

创建新的命名空间时，会产生一个如下名称的Service Account：

```
system:serviceaccount:<mamespace>:default
```

如果希望kube-system命名空间中的Service Account“default”具有全部权限，就要在策略文件中加入如下内容：

![2019-09-02-08-53-12.png](./images/2019-09-02-08-53-12.png)

# Webhook授权模式详解

Webhook定义了一个HTTP回调接口，实现Webhook的应用会在指定事件发生时，向一个URL地址发送（POST）通知信息。启用Webhook授权模式后，Kubernetes会调用外部REST服务对用户进行授权。

Webhook模式用参数--authorization-webhook-config-file=SOME_FILENAME来设置远端授权服务的信息。

配置文件使用的是kubeconfig文件的格式。文件里user一节的内容指的是API Server。相对于远程授权服务来说，API Server是客户端，也就是用户；cluster一节的内容指的是远程授权服务器的配置。下面的例子为设置一个使用HTTPS客户端认证的配置：

![2019-09-02-09-46-19.png](./images/2019-09-02-09-46-19.png)

![2019-09-02-09-46-25.png](./images/2019-09-02-09-46-25.png)

在授权开始时，API Server会生成一个api.authorization.v1beta1.SubjectAccessReview对象，用于描述操作信息，在进行JSON序列化之后POST出来。在这个对象中包含用户尝试访问资源的请求动作的描述，以及被访问资源的属性。

Webhook API对象和其他API对象一样，遵循同样的版本兼容性规则，在实现时要注意apiVersion字段的版本，以实现正确的反序列化操作。另外，API Server必须启用authorization.k8s.io/v1beta1 API扩展（--runtime-config=authorization.k8s.io/v1beta1=true）。

下面是一个希望获取Pod列表的请求报文示例：

![2019-09-02-09-48-15.png](./images/2019-09-02-09-48-15.png)

远端服务需要填充请求中的SubjectAccessReviewStatus字段，并返回允许或不允许访问的结果。应答报文中的spec字段是无效的，也可以省略。

一个返回“运行访问”的应答报文示例如下：

![2019-09-02-09-48-40.png](./images/2019-09-02-09-48-40.png)

一个返回“不允许访问”的应答报文示例如下：

非资源的访问请求路径包括/api、/apis、/metrics、/resetMetrics、/logs、/debug、/healthz、/swagger-ui/、/swaggerapi/、/ui和/version。通常可以对/api、/api/\*、/apis、/apis/\*和/version对于客户端发现服务器提供的资源和版本信息给予“允许”授权，对于其他非资源的访问一般可以禁止，以限制客户端对API Server进行没有必要的查询。
查询/debug的请求报文示例如下：
