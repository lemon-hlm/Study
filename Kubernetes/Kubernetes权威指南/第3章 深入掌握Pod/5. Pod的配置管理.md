 
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 ConfigMap概述](#1-configmap概述)
- [2 创建ConfigMap资源对象](#2-创建configmap资源对象)
  - [2.1 通过YAML配置文件方式创建](#21-通过yaml配置文件方式创建)
    - [2.1.1 变量定义为ConfigMap](#211-变量定义为configmap)
    - [2.1.2 两个配置文件定义为ConfigMap](#212-两个配置文件定义为configmap)
  - [2.2 通过kubectl命令行方式创建](#22-通过kubectl命令行方式创建)
- [3 在Pod中使用ConfigMap](#3-在pod中使用configmap)
  - [3.1 通过环境变量方式使用ConfigMap](#31-通过环境变量方式使用configmap)
  - [3.2 通过volumeMount使用ConfigMap](#32-通过volumemount使用configmap)

<!-- /code_chunk_output -->

**应用部署**的一个**最佳实践**是将**应用所需的配置信息！！！** 与**程序！！！** 进行**分离**，这样可以使**应用程序被更好地复用**，通过不同的配置也能实现更灵活的功能。

将**应用打包为容器镜像**后，可以通过**环境变量**或者**外挂文件的方式**在**创建容器时**进行**配置注入**，但在大规模容器集群的环境中，对**多个容器**进行**不同的配置**将变得非常复杂。

从Kubernetes 1.2开始提供了一种统一的应用配置管理方案—ConfigMap。

# 1 ConfigMap概述

ConfigMap供容器使用的典型用法如下.

（1）生成为**容器内的环境变量**。

（2）设置**容器启动命令的启动参数**（需设置为**环境变量**）。

（3）以Volume的形式**挂载为容器内部的文件或目录**。

ConfigMap以一个或多个**key:value**的形式保存在Kubernetes系统中供应用使用，

- 既可以用于表示一个变量的值（例如apploglevel=info），
- 也可以用于表示一个完整配置文件的内容（例如`server.xml=<?xml...>...`）

可以通过**YAML配置文件**或者**直接使用kubectl create configmap命令行**的方式来创建ConfigMap。

# 2 创建ConfigMap资源对象

## 2.1 通过YAML配置文件方式创建

### 2.1.1 变量定义为ConfigMap

下面的例子cm\-appvars.yaml描述了将几个应用**所需的变量**定义为ConfigMap的用法：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-appvars
data:
  apploglevel: info
  appdatadir: /var/data
```

执行kubectl create命令创建该ConfigMap：

```
# kubectl create -f cm-appvars.yaml
configmap "cm-appvars" created
```

查看创建好的ConfigMap:

```
# kubectl get configmap
NAME        DATA    AGE
cm-appvars  2       3s

# kubectl describe configmap cm-appvars
Name:           cm-appvars
Namespace:      default
Labels:         <none>
Annotations:    <none>

Data
====
appdatadir:     9 bytes # 注意
apploglevel:    4 bytes # 注意

# kubectl get configmap cm-appvars -o yaml
apiVersion: v1
data:
  appdatadir: /var/data
  apploglevel: info
kind: ConfigMap
metadata:
  creationTimestamp: 2019-08-23T19:32:16Z
  name: cm-appvars
  namespace: default
  resourceVersion: "78709"
  selfLink: /api/v1/namespaces/defaule/configmaps/cm-appvars
  uid: 55f316d8-2d6b-49a8-bdfe-e4b77d15574d
```

### 2.1.2 两个配置文件定义为ConfigMap

下面的例子cm\-appconfigfiles.yaml描述了将**两个配置文件**server.xml和logging.properties定义为**ConfigMap**的用法，

设置**key**为**配置文件的别名**，**value**则是配置文件的**全部文本内容**：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-appconfigfiles
data:
  key-serverxml: |
    <?xml version='1.0' encoding='utf-8'?>
    <Server port="8005" shutdown="SHUTDOWN">
      <Listener className="org.apache.catalina.startup.VersionLoggerListener" />
      <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
      <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
      <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
      <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />
      <GlobalNamingResources>
        <Resource name="UserDatabase" auth="Container"
                  type="org.apache.catalina.UserDatabase"
                  description="User database that can be updated and saved"
                  factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
                  pathname="conf/tomcat-users.xml" />
      </GlobalNamingResources>
      <Service name="Catalina">
        <Connector port="8080" protocol="HTTP/1.1"
                   connectionTimeout="20000"
                   redirectPort="8443" />
        <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
        <Engine name="Catalina" defaultHost="localhost">
          <Realm className="org.apache.catalina.realm.LockOutRealm">
            <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
                   resourceName="UserDatabase"/>
          </Realm>
          <Host name="localhost"  appBase="webapps"
                unpackWARs="true" autoDeploy="true">
            <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
                   prefix="localhost_access_log" suffix=".txt"
                   pattern="%h %l %u %t &quot;%r&quot; %s %b" />
          </Host>
        </Engine>
      </Service>
    </Server>
  key-loggingproperties: "handlers
    = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler,
    3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler,
    java.util.logging.ConsoleHandler\r\n\r\n.handlers = 1catalina.org.apache.juli.FileHandler,
    java.util.logging.ConsoleHandler\r\n\r\n1catalina.org.apache.juli.FileHandler.level
    = FINE\r\n1catalina.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\r\n1catalina.org.apache.juli.FileHandler.prefix
    = catalina.\r\n\r\n2localhost.org.apache.juli.FileHandler.level = FINE\r\n2localhost.org.apache.juli.FileHandler.directory
    = ${catalina.base}/logs\r\n2localhost.org.apache.juli.FileHandler.prefix = localhost.\r\n\r\n3manager.org.apache.juli.FileHandler.level
    = FINE\r\n3manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\r\n3manager.org.apache.juli.FileHandler.prefix
    = manager.\r\n\r\n4host-manager.org.apache.juli.FileHandler.level = FINE\r\n4host-manager.org.apache.juli.FileHandler.directory
    = ${catalina.base}/logs\r\n4host-manager.org.apache.juli.FileHandler.prefix =
    host-manager.\r\n\r\njava.util.logging.ConsoleHandler.level = FINE\r\njava.util.logging.ConsoleHandler.formatter
    = java.util.logging.SimpleFormatter\r\n\r\n\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].level
    = INFO\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers
    = 2localhost.org.apache.juli.FileHandler\r\n\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level
    = INFO\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers
    = 3manager.org.apache.juli.FileHandler\r\n\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level
    = INFO\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers
    = 4host-manager.org.apache.juli.FileHandler\r\n\r\n"
```

创建该ConfigMap:

```
# kubectl create -f appconfigfiles.yaml
```

查看创建好的ConfigMap:

```
# kubectl get configmap cm-appconfigfiles
NAME                DATA    AGE
cm-appconfigfiles   2       14s

# kubectl describe configmap cm-appconfigfiles
Name:           cm-appconfigfiles
Namespace:      default
Labels:         <none>
Annotations:    <none>

Data
====
key-loggingproperties:  1809 bytes
key-serverxml:          1686 bytes
```

查看创建的ConfigMap的详细内容, 可看到两个配置文件的全文:

```
# kubectl get configmap cm-appconfigfiles -o yaml
apiVersion: v1
data:
  key-loggingproperties: "handlers
    = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler,
    3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler,
    java.util.logging.ConsoleHandler\r\n\r\n.handlers = 1catalina.org.apache.juli.FileHandler,
    java.util.logging.ConsoleHandler\r\n\r\n1catalina.org.apache.juli.FileHandler.level
    = FINE\r\n1catalina.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\r\n1catalina.org.apache.juli.FileHandler.prefix
    = catalina.\r\n\r\n2localhost.org.apache.juli.FileHandler.level = FINE\r\n2localhost.org.apache.juli.FileHandler.directory
    = ${catalina.base}/logs\r\n2localhost.org.apache.juli.FileHandler.prefix = localhost.\r\n\r\n3manager.org.apache.juli.FileHandler.level
    = FINE\r\n3manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\r\n3manager.org.apache.juli.FileHandler.prefix
    = manager.\r\n\r\n4host-manager.org.apache.juli.FileHandler.level = FINE\r\n4host-manager.org.apache.juli.FileHandler.directory
    = ${catalina.base}/logs\r\n4host-manager.org.apache.juli.FileHandler.prefix =
    host-manager.\r\n\r\njava.util.logging.ConsoleHandler.level = FINE\r\njava.util.logging.ConsoleHandler.formatter
    = java.util.logging.SimpleFormatter\r\n\r\n\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].level
    = INFO\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers
    = 2localhost.org.apache.juli.FileHandler\r\n\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level
    = INFO\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers
    = 3manager.org.apache.juli.FileHandler\r\n\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level
    = INFO\r\norg.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers
    = 4host-manager.org.apache.juli.FileHandler\r\n\r\n"
  key-serverxml: |
    <?xml version='1.0' encoding='utf-8'?>
    <Server port="8005" shutdown="SHUTDOWN">
      <Listener className="org.apache.catalina.startup.VersionLoggerListener" />
      <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
      <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
      <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
      <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />
      <GlobalNamingResources>
        <Resource name="UserDatabase" auth="Container"
                  type="org.apache.catalina.UserDatabase"
                  description="User database that can be updated and saved"
                  factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
                  pathname="conf/tomcat-users.xml" />
      </GlobalNamingResources>
      <Service name="Catalina">
        <Connector port="8080" protocol="HTTP/1.1"
                   connectionTimeout="20000"
                   redirectPort="8443" />
        <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
        <Engine name="Catalina" defaultHost="localhost">
          <Realm className="org.apache.catalina.realm.LockOutRealm">
            <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
                   resourceName="UserDatabase"/>
          </Realm>
          <Host name="localhost"  appBase="webapps"
                unpackWARs="true" autoDeploy="true">
            <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
                   prefix="localhost_access_log" suffix=".txt"
                   pattern="%h %l %u %t &quot;%r&quot; %s %b" />
          </Host>
        </Engine>
      </Service>
    </Server>
kind: ConfigMap
metadata:
  creationTimestamp: 2019-08-23T19:50:13Z
  name: cm-appconfigfiles
  namespace: default
  resourceVersion: "85054"
  selfLink: /api/v1/namespaces/defaule/configmaps/cm-appconfigfiles
  uid: 69b9abf5-65c7-42f2-9ff2-cfeec865fc97
```

## 2.2 通过kubectl命令行方式创建

不使用YAML文件，直接通过kubectl create configmap也可以创建ConfigMap，可以使用参数\-\-from\-file或\-\-from\-literal指定内容，并且可以在一行命令中指定多个参数。

(1) 通过\-\-from\-file参数从**文件**中进行创建，可以**指定key的名称**，也可以在一个命令行中创建包含多个key的ConfigMap，语法为：

```
# kubectl create configmap NAME --from-file=[key=]source
```

```
--from-file=[key=]source
```

（2）通过\-\-from\-file参数从**目录**中进行创建，该目录下的**每个配置文件名**都被设置为**key**，**文件的内容**被设置为**value**，语法为：

```
# kubectl create configmap NAME --from-file=config-files-dir
```

（3）使用\-\-from\-literal时会从**文本**中进行创建，直接将指定的key\#=value\#创建为ConfigMap的内容，语法为：

```
# kubectl create configmap NAME --from-literal=key1=value1 --from-literal=key2=value2
```

下面对这几种用法举例说明.

例如，在当前目录下含有配置文件server.xml，可以创建一个包含该文件内容的ConfigMap：

```
# kubectl create configmap cm-server.xml --from-file=server.xml
configmap "cm-server.xml" created

# kubectl describe configmap cm-server.xml
Name:           cm-server.xml
Namespace:      default
Labels:         <none>
Annotations:    <none>

Data
====
server.xml:  6458 bytes
```

假设在configfiles目录下包含两个配置文件server.xml和logging.properties，创建一个包含这两个文件内容的ConfigMap：

```
# kubectl create configmap cm-appconf --from-file=configfiles
configmap "cm-appconf" created

# kubectl describe configmap cm-appconf
Name:           cm-appconf
Namespace:      default
Labels:         <none>
Annotations:    <none>

Data
====
logging.properties: 3354 bytes
server.xml:         6458 bytes
```

使用\-\-from\-literal参数进行创建的示例如下：

```
# kubectl create configmap cm-appenv --from-literal=loglevel=info --from-literal=appdatadir=/var/data
configmap "cm-appenv" created

# kubectl describe configmap cm-appenv
Name:           cm-appenv
Namespace:      default
Labels:         <none>
Annotations:    <none>

Data
====
appdatadir:     9 bytes
loglevel:       4 bytes
```

# 3 在Pod中使用ConfigMap

**容器应用**对**ConfigMap的使用**有以下两种方法。

（1）通过**环境变量**获取ConfigMap中的内容。

（2）通过**Volume挂载**的方式将ConfigMap中的内容挂载为**容器内部的文件或目录**。

## 3.1 通过环境变量方式使用ConfigMap

以前面的ConfigMap "cm\-appvars"为例:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-appvars
data:
  apploglevel: info
  appdatadir: /var/data
```

在Pod “cm\-test\-pod”的定义中，将ConfigMap “cm\-appvars”中的内容以**环境变量**（**APPLOGLEVEL**和**APPDATADIR**）方式设置为**容器内部的环境变量**，容器的启动命令将显示这两个环境变量的值（"env | grep APP"）：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cm-test-pod
spec:
  containers:
  - name: cm-test
    image: busybox
    command: [ "/bin/sh", "-c", "env | grep APP" ]
    env:
    - name: APPLOGLEVEL         # 定义环境变量的名称
      valueFrom:                # key "apploglevel" 对应的值
        configMapKeyRef:
          name: cm-appvars      # 环境变量的值取自cm-appvars:
          key: apploglevel      # key为apploglevel
    - name: APPDATADIR          # 定义环境变量的名称
      valueFrom:                # key "appdatadir" 对应的值
        configMapKeyRef:
          name: cm-appvars      # 环境变量的值取自 cm-appvars
          key: appdatadir       # key为appdatadir
  restartPolicy: Never          # 不被系统自动重启
```

使用kubectl create \-f命令**创建该Pod**，由于是测试Pod，所以该Pod在**执行完启动命令**后将会**退出**，并且**不会被系统自动重启**（restartPolicy=Never）：

```
# kubectl create -f cm-test-pod.yaml
pod "cm-test-pod" created
```

查看已经停止的Pod:

```
# kubectl get pods --show-all
NAME        READY       STATUS      RESTARTS    AGE
cm-test-pod 0/1         Completed   0           8s
```

查看该Pod的日志，可以看到启动命令“env | grep APP”的执行结果如下：

```
# kubectl logs cm-test-pod
APPDATADIR=/var/data
APPLOGLEVEL=info
```

从1.6版本开始，引入了一个新的字段**envFrom**，实现了在**Pod环境**中将**ConfigMap**（也可用于**Secret资源对象**）中**所有定义的key=value**自动生成为**环境变量**：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cm-test-pod
spec:
  containers:
  - name: cm-test
    image: busybox
    command: [ "/bin/sh", "-c", "env" ]
    envFrom:
    - configMapRef
       name: cm-appvars     # 根据cm-appvars中的key=value自动生成环境变量
  restartPolicy: Never
```

通过这个定义, 在容器内部将会生成如下环境变量:

```
apploglevel=info
appdatadir=/var/data
```

环境变量的名称受POSIX命名规范（\[a\-zA\-Z\_]\[a\-zA\-Z0\-9\_]\*）约束，不能以数字开头。如果包含非法字符，则系统将跳过该条环境变量的创建，并记录一个Event来提示环境变量无法生成，但并不阻止Pod的启动。

## 3.2 通过volumeMount使用ConfigMap

