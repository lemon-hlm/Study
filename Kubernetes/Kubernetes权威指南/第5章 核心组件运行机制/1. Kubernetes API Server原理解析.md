
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 Kubernetes API Server概述](#1-kubernetes-api-server概述)

<!-- /code_chunk_output -->

总体来看，Kubernetes **API Server**的**核心功能**是提供Kubernetes**各类资源对象**（如Pod、RC、Service等）的增、删、改、查及Watch等**HTTP Rest接口**，成为集群内各个功能模块之间数据交互和通信的中心枢纽，是整个系统的**数据总线**和**数据中心**。

除此之外，它还有以下一些功能特性。

(1) 集群管理的API入口

(2) 资源配额控制的入口

(3) 提供了完备的集群安全机制

# 1 Kubernetes API Server概述

Kubernetes API Server通过一个名为**kube\-apiserver**的**进程**提供服务，该进程运行在**Master**上。

在**默认情况**下，kube\-apiserver进程在**本机的8080端口**（对应参数\-\-insecure\-port）提供REST服务。

可以同时**启动HTTPS安全端口**（\-\-secure\-port=6443）来启动安全机制，加强REST API访问的安全性。

通常可以通过**命令行工具kubectl**来与Kubernetes API Server交互，它们之间的接口是**RESTful API**。

为了测试和学习Kubernetes API Server所提供的接口，我们也可以使用**curl命令行工具**进行快速验证。

比如, 登录Master并运行下面的curl命令, 得到以JSON方式返回的Kubernetes API的版本信息

```
# curl localhost:8080/api
{
    "kind": "APIVersions",
    "verdions": [
        "v1"
    ],
    "serverAddressByClientCIDRs": [
        {
            "clientCIDR": "0.0.0.0/0",
            "serverAddress": "192.168.18.131:6443"
        }
    ]
}
```

可以运行下面命令查看Kubernetes API Server目前支持的资源对象的种类:

```
# curl localhost:8080/api/v1
```

根据以上命令的输出，我们可以运行下面的curl命令，分别返回集群中的Pod列表、Service列表、RC列表等：

```
# curl localhost:8080/api/v1/pods
# curl localhost:8080/api/v1/services
# curl localhost:8080/api/v1/replicationcontrollers
```

如果只想对外暴露部分REST服务, 则可以在Mater或其他节点上运行kubectl proxy进程启动一个内部代理来实现.

运行下面命令, 在8001端口启动代理, 并且拒绝客户端访问RC的API:

```
# kubectl proxy --reject-paths="^/api/v1/replicationcontrollers" --port=8001 --v=2
Starting to server on 127.0.0.1:8001
```

运行下面命令进行验证:

```
# curl localhost:8001/api/v1/replicationcontrollers
<h3>Unauthorized</h3>
```

kubectl proxy具有很多特性，最实用的一个特性是提供简单有效的安全机制，比如在采用白名单限制非法客户端访问时，只需增加下面这个参数即可：

```
--accept-hosts="^localhost$,^127\\.0\\.0\\.1$,^\\[::1\\]$"
```

最后一种方式就是通过编程方式调用kubernetes API Server. 具体场景又细分为以下两种.

第1种使用场景：运行在**Pod里的用户进程**调用Kubernetes API，通常用来实现**分布式集群搭建**的目标。

比如下面这段来自谷歌官方的Elasticsearch集群例子中的代码，Pod在启动的过程中通过访问Endpoints的API，找到属于elasticsearch\-logging这个Service的所有Pod副本的IP地址，用来构建集群，如图5.1所示。

图5.1 应用程序编程访问API Server:

![2019-08-23-14-16-51.png](./images/2019-08-23-14-16-51.png)

在上述使用场景中，**Pod中的进程**如何知道**API Server的访问地址**呢？答案很简单：Kubernetes **API Server**本身也是一个**Service**，它的名称就是**kubernetes**，并且它的**Cluster IP地址**是**Cluster IP地址池**里的**第1个地址**！另外，它所服务的端口是HTTPS端口443，通过kubectl get service命令可以确认这一点：

```
# kubectl get service
NAME        CLUSTER-IP          EXTERNAL-IP         PORT(S)     AGE
kubernetes  169.169.0.1         <none>              443/TCP     30d
```

第2种使用场景：开发基于Kubernetes的管理平台。

比如调用Kubernetes API来完成Pod、Service、RC等资源对象的图形化创建和管理界面，此时可以使用Kubernetes及各开源社区为开发人员提供的**各种语言版本**的 **Client Library**。后面会介绍通过编程方式访问API Server的一些细节技术。

由于**API Server**是Kubernetes集群数据的**唯一访问入口！！！**，因此安全性与高性能就成为API Server设计和实现的两大核心目标。通过采用HTTPS安全传输通道与CA签名数字证书强制双向认证的方式，API Server的安全性得以保障。此外，为了更细粒度地控制用户或应用对Kubernetes资源对象的访问权限，Kubernetes启用了RBAC访问控制策略，之后会深入讲解这一安全策略。