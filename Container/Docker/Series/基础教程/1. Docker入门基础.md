https://zhuanlan.zhihu.com/p/23599229

http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html

# 1 环境配置的难题

软件开发最大的麻烦, 就是环境配置. 用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？

用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。

环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。

# 2 虚拟机

虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。

虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。

（1）资源占用多

虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。

（2）冗余步骤多

虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。

（3）启动慢

启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。

# 3 Linux容器

由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。

Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

由于容器是进程级别的，相比虚拟机有很多优势。

（1）启动快

容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。

（2）资源占用少

容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。

（3）体积小

容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。

# 4 Docker是什么

官方文档: https://docs.docker.com/

Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。

总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

## 4.1 Docker的三个概念

镜像（Image）：类似于**虚拟机中的镜像**，是一个**包含有文件系统的面向Docker引擎的只读模板(！！！只读的！！！**)。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如**一个Ubuntu镜像**就是一个**包含Ubuntu操作系统环境的模板**，同理**在该镜像上装上Apache软件**，就可以称为**Apache镜像**。

容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个**极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等！！！**），以及**运行在其中的应用程序(！！！**)。**Docker引擎**利用**容器**来**运行、隔离各个应用！！！**。**容器**是**镜像创建的应用实例**，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：**镜像本身是只读的**，容器从镜像启动时，Docker在**镜像的上层(！！！**)创建一个**可写层(！！！**)，**镜像本身不变**。

仓库（Repository）：类似于代码仓库，这里是**镜像仓库**，是Docker用来**集中存放镜像文件的地方**。注意与**注册服务器（Registry**）的区别：**注册服务器**是**存放仓库的地方**，一般会有**多个仓库**；而**仓库**是**存放镜像的地方**，一般**每个仓库**存放**一类镜像！！！**，**每个镜像**利用**tag进行区分！！！**，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。

# 5 Docker的用途

Docker 的主要用途，目前有三大类。

（1）提供**一次性的环境**。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

（2）提供**弹性的云服务**。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

（3）组建**微服务架构**。通过**多个容器**，一台机器可以跑**多个服务**，因此在本机就可以模拟出微服务架构。

# 6 Docker的安装和卸载

Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档[Install Docker](https://docs.docker.com/install/)。也可以查看国内镜像源的安装方式, 比如[清华镜像源](https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/)


安装完成之后，可以查看Docker的版本信息：

```
[root@xxx ~]# docker version
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:
 OS/Arch:      linux/amd64

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:
 OS/Arch:      linux/amd64
```

查看Docker的帮助信息：# docker --help。

Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（ [官方文档](https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user) ）。

```
sudo usermod -aG docker $USER
```

Docker 是**服务器----客户端**架构。命令行运行**docker命令**的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（[官方文档](https://docs.docker.com/config/daemon/systemd/)）。

```
# service 命令的用法
$ sudo service docker start

# systemctl 命令的用法
$ sudo systemctl start docker
```

# 7 image 文件

Docker 把**应用程序及其依赖！！！**，打包在 image 文件里面。只有**通过这个文件**，才能**生成 Docker 容器**。**image 文件**可以看作是**容器的模板**。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。

**image 是二进制文件**。实际开发中，**一个 image** 文件往往通过**继承另一个 image！！！** 文件，加上一些个性化设置而生成。举例来说，你可以在 **Ubuntu 的 image 基础**上，往里面**加入 Apache 服务器**，形成你的 image。

安装完Docker引擎之后，就可以对镜像进行基本的操作了。

我们从**官方注册服务器**（[https://hub.docker.com](https://hub.docker.com)）的仓库中**pull下CentOS的镜像**，前边说过，**每个仓库**会有**多个镜像**，用**tag标示**，如果**不加tag**，**默认使用latest镜像**：

>注: 除非您修改了 Docker 守护进程的 `--registry-mirror` 参数 (见[官方链接](https://www.docker-cn.com/registry-mirror)), 否则您将需要完整地指定官方镜像的名称。例如，library/ubuntu、library/redis、library/nginx。不过library是默认组, 可以不加.

可以将**默认仓库**改成**国内的镜像网站**，具体的修改方法见[官方链接](https://www.docker-cn.com/registry-mirror)。

```
[root@xxx ~]# docker search centos    # 查看centos镜像是否存在
[root@xxx ~]# docker pull library/centos    # 利用pull命令获取镜像
Using default tag: latest
latest: Pulling from library/centos
08d48e6f1cff: Pull complete
Digest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
Status: Downloaded newer image for centos:latest

[root@xxx ~]# docker images    # 查看当前系统中的images信息
REPOSITORY      TAG            IMAGE ID       CREATED        SIZE
centos          latest         0584b3d2cf6d   9 days ago     196.5 MB

# 列出本机的所有 image 文件。
$ docker image ls

# 删除 image 文件
$ docker image rm [imageName]
```

image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。

为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 [Docker Hub](https://hub.docker.com/) 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。

# 8 示例: hello\-world

下面，我们通过最简单的 image 文件"[hello world](https://hub.docker.com/r/library/hello-world/)"，感受一下 Docker。

首先，运行下面的命令，将 image 文件从仓库抓取到本地。

```
$ docker image pull library/hello-world
```

上面代码中，**docker image pull**是抓取 image 文件的命令。**library/hello-world**是 image 文件在**仓库里面的位置**，其中**library**是 **image 文件所在的组！！！**，**hello\-world**是 image 文件的**名字**。

由于 **Docker 官方提供的 image 文件**，都放在**library组**里面，所以它的是**默认组**，可以省略。因此，上面的命令可以写成下面这样。

```
$ docker image pull hello-world
```

抓取成功以后，就可以在本机看到这个 image 文件了。

```
$ docker image ls
```

现在，运行这个 image 文件。

```
$ docker container run hello-world
```

**docker container run命令**会从 image 文件，生成一个正在运行的**容器实例**。

注意，**docker container run命令**具有**自动抓取 image 文件的功能**。如果发现本地没有指定的 image 文件，就会**从仓库自动抓取**。因此，前面的docker image pull命令并不是必需的步骤。

如果运行成功，你会在屏幕上读到下面的输出。

```
[root@localhost ~]# docker container run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
```

输出这段提示以后，**hello world就会停止运行**，**容器自动终止**。

**有些容器**不会自动终止，因为提供的是服务。比如，安装运行 **Ubuntu 的 image**，就可以在命令行体验 Ubuntu 系统。

```
$ docker container run -it ubuntu bash
```

对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。

```
$ docker container kill [containID]
```

# 9 容器文件

image文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。

