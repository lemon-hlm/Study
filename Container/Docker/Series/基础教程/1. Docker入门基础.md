https://zhuanlan.zhihu.com/p/23599229

http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html

# 1 环境配置的难题

软件开发最大的麻烦, 就是环境配置. 用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？

用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。

环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。

# 2 虚拟机

虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。

虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。

（1）资源占用多

虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。

（2）冗余步骤多

虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。

（3）启动慢

启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。

# 3 Linux容器

由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。

Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

由于容器是进程级别的，相比虚拟机有很多优势。

（1）启动快

容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。

（2）资源占用少

容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。

（3）体积小

容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。

# 4 Docker是什么

官方文档: https://docs.docker.com/

Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。

总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

## 4.1 Docker的三个概念

镜像（Image）：类似于**虚拟机中的镜像**，是一个**包含有文件系统的面向Docker引擎的只读模板(！！！只读的！！！**)。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如**一个Ubuntu镜像**就是一个**包含Ubuntu操作系统环境的模板**，同理**在该镜像上装上Apache软件**，就可以称为**Apache镜像**。

容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个**极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等！！！**），以及**运行在其中的应用程序(！！！**)。**Docker引擎**利用**容器**来**运行、隔离各个应用！！！**。**容器**是**镜像创建的应用实例**，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：**镜像本身是只读的**，容器从镜像启动时，Docker在**镜像的上层(！！！**)创建一个**可写层(！！！**)，**镜像本身不变**。

仓库（Repository）：类似于代码仓库，这里是**镜像仓库**，是Docker用来**集中存放镜像文件的地方**。注意与**注册服务器（Registry**）的区别：**注册服务器**是**存放仓库的地方**，一般会有**多个仓库**；而**仓库**是**存放镜像的地方**，一般**每个仓库**存放**一类镜像！！！**，**每个镜像**利用**tag进行区分！！！**，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。

# 5 Docker的用途

Docker 的主要用途，目前有三大类。

（1）提供**一次性的环境**。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

（2）提供**弹性的云服务**。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

（3）组建**微服务架构**。通过**多个容器**，一台机器可以跑**多个服务**，因此在本机就可以模拟出微服务架构。

# 6 Docker的安装和卸载

Docker可以安装在Windows、Linux、Mac等各个平台上。具体可以查看文档[Install Docker](https://docs.docker.com/install/)。安装完成之后，可以查看Docker的版本信息：

```
[root@xxx ~]# docker version
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:
 OS/Arch:      linux/amd64

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:
 OS/Arch:      linux/amd64
```

查看Docker的帮助信息：# docker --help。

Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（ [官方文档](https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user) ）。

```
sudo usermod -aG docker $USER
```

Docker 是**服务器----客户端**架构。命令行运行**docker命令**的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（[官方文档](https://docs.docker.com/config/daemon/systemd/)）。

```
# service 命令的用法
$ sudo service docker start

# systemctl 命令的用法
$ sudo systemctl start docker
```

# 7 image 文件

Docker 把**应用程序及其依赖！！！**，打包在 image 文件里面。只有**通过这个文件**，才能**生成 Docker 容器**。**image 文件**可以看作是**容器的模板**。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。

**image 是二进制文件**。实际开发中，**一个 image** 文件往往通过**继承另一个 image！！！** 文件，加上一些个性化设置而生成。举例来说，你可以在 **Ubuntu 的 image 基础**上，往里面**加入 Apache 服务器**，形成你的 image。

安装完Docker引擎之后，就可以对镜像进行基本的操作了。

我们从**官方注册服务器**（[https://hub.docker.com](https://hub.docker.com)）的仓库中**pull下CentOS的镜像**，前边说过，**每个仓库**会有**多个镜像**，用**tag标示**，如果**不加tag**，**默认使用latest镜像**：

```
[root@xxx ~]# docker search centos    # 查看centos镜像是否存在
[root@xxx ~]# docker pull centos    # 利用pull命令获取镜像
Using default tag: latest
latest: Pulling from library/centos
08d48e6f1cff: Pull complete
Digest: sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
Status: Downloaded newer image for centos:latest

[root@xxx ~]# docker images    # 查看当前系统中的images信息
REPOSITORY      TAG            IMAGE ID       CREATED        SIZE
centos          latest         0584b3d2cf6d   9 days ago     196.5 MB

# 列出本机的所有 image 文件。
$ docker image ls

# 删除 image 文件
$ docker image rm [imageName]
```

image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。

为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。``

