
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 相关配置参数](#1-相关配置参数)
* [2 与内存相关的数据结构](#2-与内存相关的数据结构)
	* [2.1 PCDIMMDevice和 HostMemoryBackend](#21-pcdimmdevice和-hostmemorybackend)

<!-- /code_chunk_output -->

QEMU在虚拟机启动的初始化阶段，为客户机分配了物理内存，那么客户机的物理内存如何工作呢？

本篇文档，为大家介绍客户机物理内存的工作原理、相关数据结构，但不会涉及其实现细节，客户机物理内存的实现细节，会在后面的代码分析中讲述。

# 1 相关配置参数

QEMU的命令行中有参数：

```
-m [size=]megs[,slots=n,maxmem=size] 
```

用于指定客户机初始运行时的内存大小以及客户机最大内存大小，以及内存芯片槽的数量（DIMM）。

之所以QEMU可以指定最大内存、槽等参数，是因为QEMU可以模拟DIMM的热插拔，客户机操作系统可以和在真实的系统上一样，检测新内存被插入或者拔出。也就是说，内存热插拔的粒度是DIMM槽（或者说DIMM集合），而不是最小的byte。

# 2 与内存相关的数据结构

![](./images/2019-06-05-18-53-12.png)

## 2.1 PCDIMMDevice和 HostMemoryBackend

**PCDIMMDevice**和**HostMemoryBackend对象**都是在QEMU中**用户可见**的**客户机内存**。它们能通过**QEMU命令行**或者**QMP监控器接口**来管理。

**PCDIMMDevice数据结构**是使用QEMU中的面向对象编程模型**QOM定义**的，对应的对象和类的数据结构如下。通过在QEMU进程中创建一个新的PCDIMMDevice对象，就可以实现内存的热插拔。

值得注意的是，客户机启动时的初始化内存，可能不会被模拟成PCDIMMDevice设备，也就是说，这部分初始化内存不能进行热插拔。PCDIMMDevice的定义在include/hw/mem/pc\-dimm.h中。


参考

https://blog.csdn.net/u011364612/article/details/51345110