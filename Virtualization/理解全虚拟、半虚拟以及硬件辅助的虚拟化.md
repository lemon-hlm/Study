https://blog.csdn.net/x_i_y_u_e/article/details/50854603

# 1 x86虚拟化概观

“虚拟化”这个术语本身就极大地表明了服务请求和底层物理交付的分离。对于x86虚拟化，在**硬件**和**操作系统**之间，添加了一个**虚拟化层**，如图。

![config](./images/1.png)

这个虚拟化层使得多个操作系统实例可以并行地运行在一台计算机上，并动态地瓜分和共享诸如CPU、存储、内存和I/O设备等物理资源。

对于业界**标准的x86系统**，**虚拟化**采取**hosted**或者**hypervisor架构**。

- **hosted架构**将**虚拟化层**以一个**应用程序的方式**安装运行于**操作系统之上**，支持最为广泛的各种硬件配置。

- **hypervisor(裸金属**)架构将**虚拟化层**直接安装到干净的**x86系统**上，由于它**不需要通过操作系统而直接访问硬件**，hypervisor架构相对于hosted架构**效率更高**，且具有**更好的可扩展性、健壮性和性能**。

VMware Player, ACE, Workstation和Server使用了hosted架构的便捷性，而ESX server针对已认证的硬件采用hypervisor架构以达到数据中心级别的性能。

了解各个组件的大概背景，有助于更好的理解**x86虚拟化技术**。**虚拟化层**是负责**运行和管理所有虚拟机的软件**，操作系统运行于**虚拟机监控器(VMM**s)上。

如图所示，**虚拟化层！！！**是**直接运行在硬件上的hypervisor！！！**，基于**不同架构**和**实现方法的hypervisor**所具有的**功能有很大不同**。

运行于**hypervisor**上的**每个VMM！！！**实现了**虚拟机的硬件抽象！！！**并负责**运行虚拟机系统！！！**，**每个VMM！！！**需要通过分割和共享CPU、内存和I/O设备来完成系统的虚拟化。

![config](./images/2.png)

# 2 CPU虚拟化

## 2.1 x86硬件虚拟化的挑战

**x86操作系统**被设计成**直接运行在硬件**上，自然这些**系统会认为它们拥有硬件的全部控制权(！！！**)。如图所示，**x86架构**为操作系统和应用程序提供了四个不同级别的权限来管理对硬件的访问，分别为ring 0，1，2和3。**用户程序**一般运行在**ring 3**，**操作系统**需要直**接访问内存和硬件！！！**，因此需要在**ring 0**执行它的**特权指令**。

**x86架构**的**虚拟化**需要在**操作系统(运行于最高权限的ring 0)之下**放置一个提供**共享资源的虚拟化层**来创建和管理虚拟机。比较糟的是，**有些敏感指令**在**非ring 0**下执行时具有不同的语义，因此不能很好地将其虚拟化。在**运行时陷入并翻译这些敏感指令和特权指令**是一个艰难的挑战，这使得x86架构的虚拟化起初看起来是不可完成的任务。

![config](./images/3.png)

**VMware**在1998年就攻克了这个挑战，开发了**二进制翻译技术！！！**使得**VMM运行在ring 0**以达到隔离和性能的要求，而将**操作系统**转移到比**应用程序所在ring 3权限高**和比**虚拟机监控器所在ring 0权限低**的用户级。基于VMware 20000多客户的安装使用情况以及所形成的广大合作伙伴生态系统，**VMware**使用**二进制翻译的全虚拟化方案**已经成为**事实上的标准**，总的来说业界还没有一个开放的标准来定义和管理虚拟化。每个开发虚拟化解决方案的公司可以用不同的方式应对这个技术上的挑战，提供的解决方案良莠不齐。

正如以下阐述的，目前有**三种技术**来实现**x86架构CPU敏感指令**和**特权指令的虚拟化**，分别为：

- 使用**二进制翻译**的**全虚拟化**；

- **操作系统辅助或半虚拟化**；

- **硬件辅助的虚拟化**(第一代)；

### 2.1.1 使用二进制翻译的全虚拟化

使用**二进制翻译**和**直接指令执行相结合**的技术，VMware可以**虚拟化任何基于x86的操作系统**。这种方法如图所示，将**内核代码翻译！！！**，以便使用一系列**作用于虚拟化硬件**可达到所需效果的**新指令序列！！！**替换那些**不可虚拟化的指令！！！**。同时，**用户级的代码直接运行在物理处理器！！！**上保证虚拟化的高性能。**虚拟机监控器(！！！VMM！！！**)为**每个虚拟机(！！！虚拟机和VMM一一对应！！！**)提供类似于**真实物理系统所具有的服务**，如**一个虚拟的BIOS**，**虚拟化设备**和**虚拟化的内存管理**。

![config](./images/4.png)

注: 图中很清晰, Guest OS用户态命令直接在host的物理硬件上直接运行, Guest OS的敏感指令和特权指令会陷入到VMM, 然后被二进制翻译成新的指令序列, 最后在物理硬件上运行.

**二进制翻译**和**直接指令执行**相结合的**全虚拟化！！！**使得**虚拟机系统**和**底下的物理硬件彻底解耦**。**虚拟机系统没有意识到它是被虚拟化**的，因此**不需要虚拟机系统(客户操作系统！！！)做任何的修改**。**全虚拟化**是**不需要硬件辅助！！！**或**操作系统辅助！！！**来**虚拟化敏感指令和特权指令的唯一方案！！！**。**hypervisor**将**操作系统的指令翻译并将结果缓存供之后使用**，而**用户级指令无需修改就运行**，具有和物理机一样的执行速度。

全虚拟化为虚拟机提供最佳的隔离和安全性，使移植变得简单，因为同样的虚拟机系统可运行于虚拟化环境或真实物理硬件上。VMware的虚拟化产品和微软的Virtual Server是全虚拟化的例子。

### 2.1.2 操作系统辅助虚拟化或半虚拟化

"Para"是源于希腊的英文词缀，意为“beside”、“with”、“alongside”。就以“alongside virtualization”来说，**半虚拟化**指的是**虚拟机系统**和**hypervisor**通过**交互来改善性能和效率**。如图所示，**半虚拟化**涉及到**修改操作系统内核(客户机操作系统！！！**)来将**不可虚拟化的指令**替换为**直接与虚拟化层交互！！！的超级调用(hypercalls**)。hypervisor同样为**其他关键的系统操作**如**内存管理**、**中断处理**、**计时**等提供了**超级调用接口**。

![config](./images/5.png)

注: Guest OS用户态指令直接在host的物理硬件上直接运行, 修改Guest OS, 将不可虚拟化的指令替换成发给hypervisor的超级调用, 然后VMM和物理硬件交互.

**半虚拟化**和**全虚拟化不一样**，**全虚拟化**时**未经修改的虚拟机系统不知道自身被虚拟化**，**系统敏感的调用陷入**后再进行**二进制翻译**。**半虚拟化的价值**在于**更低的虚拟化代价**，但是半虚拟化相对全虚拟化的**性能优势根据不同的工作负载有很大差别**。半虚拟化不支持未经修改的操作系统(如Windows 2000/XP)，因此它的兼容性和可移植性较差。由于半虚拟化需要系统内核的深度修改，在生产环境中，半虚拟化在技术支持和维护上会有很大的问题。**开源的Xen项目**是**半虚拟化的一个例子**，它使用一个**经过修改的Linux内核来虚拟化处理器！！！**，而用**另外一个定制的虚拟机系统**的**设备驱动来虚拟化I/O！！！**。

使用**二进制翻译**来实现虚拟化**更复杂更困难**，相对来说**修改虚拟机系统较容易**。这些年来，VMware在自己的产品线中，以**VMware tools**和**经优化的虚拟设备驱动**的方式使用了半虚拟化某些方面的技术。VMware tools为VMM hypervisor进行时间同步、日志服务、和关闭虚拟机等服务提供了一个后门。Vmxnet是一个半虚拟化的I/O设备驱动，它和hypervisor共享一些数据结构。它通过利用宿主机设备的能力来获得更好的吞吐量和更低的CPU的使用量。需要澄清的是，VMware tools服务和vmxnet设备驱动并不是CPU半虚拟化方案，它们是小型的，非入侵式地安装在虚拟机系统中，不需要系统内核作修改。从今往后，VMware也在帮助开发半虚拟化的Linux版本，以支持概念验证和产品开发。更多的信息见之后的页11。

### 2.1.3 硬件辅助虚拟化

**硬件厂商**迅速**拥抱虚拟化**并开发出新的**硬件特性来简化虚拟化技术**。

**第一代技术**包括**Intel虚拟化技术(VT\-x**)和**AMD的AMD\-V**，两者都针对**特权指令为CPU添加了一个执行模式**，**VMM**运行在ring 0，同时**在新增的根模式下**。如图所示，**特权和敏感调用自动陷入hypervisor**，**不再需要二进制翻译或半虚拟化！！！**。**虚拟机的状态**保存在**虚拟机控制结构(VMCS，VT\-x**)或**虚拟机控制块(VMCB，AMD\-V**)中。带有VT和AMD-V的处理器在2006年投入使用，因此**新的系统**才会带有这些硬件辅助特性。由于**hypervisor到虚拟机转换**的**高代价**和**僵化的编程模型**，目前VMware的二进制翻译技术在很多情况下会比第一代硬性辅助的实现表现更好。**第一代硬件辅助虚拟化**的实现中，**僵化的编程模型**使软件在管理hypervisor到虚拟机转换的频率和代价方面失去灵活性。出于此，VMware仅使用了第一代硬件辅助的少数特性，例如在Intel处理器上支持64位虚拟机。

![config](./images/6.png)

# 3 内存虚拟化

除了CPU虚拟化之外，下一个关键的组件是内存虚拟化。内存虚拟化涉及到对系统物理内存的共享和动态地为虚拟机分配内存。内存虚拟化和当代操作系统对虚拟内存的支持类似。应用程序看到的连续地址空间和底下真正的物理内存不一定是一一对应的。操作系统保存了虚拟页号到物理页号的映射。当前所有的x86 CPU包含了一个内存管理单元(MMU)和一个旁路缓冲(TBL)以优化虚拟内存的性能。

为了在一个系统上运行多个虚拟机，还需要另外一层的内存虚拟化。也就是说，MMU需要被虚拟化来支持虚拟机系统。虚拟机系统还是控制着虚拟地址到虚拟机内存物理地址的映射，但虚拟机系统不能直接访问真实的机器内存。VMM负责将虚拟机物理内存映射到真实的机器内存，并使用影子页表来加速映射过程。如图8种标红线之处所示，VMM使用硬件中的TLB来直接映射虚拟内存到机器内存以避免每次访问时需要两级转换。当虚拟机改变了虚拟内存到物理内存的映射时，VMM更新影子页表使得后续可以直接查找。对于所有的虚拟化方案来说，MMU虚拟化都会带来一定的代价，这也是第二代硬件辅助虚拟化方案会改进的地方。





