https://blog.csdn.net/x_i_y_u_e/article/details/50854603

# 1 x86虚拟化概观

“虚拟化”这个术语本身就极大地表明了服务请求和底层物理交付的分离。对于x86虚拟化，在**硬件**和**操作系统**之间，添加了一个**虚拟化层**，如图。

![config](./images/1.png)

这个虚拟化层使得多个操作系统实例可以并行地运行在一台计算机上，并动态地瓜分和共享诸如CPU、存储、内存和I/O设备等物理资源。

对于业界**标准的x86系统**，**虚拟化**采取**hosted**或者**hypervisor架构**。

- **hosted架构**将**虚拟化层**以一个**应用程序的方式**安装运行于**操作系统之上**，支持最为广泛的各种硬件配置。

- **hypervisor(裸金属**)架构将**虚拟化层**直接安装到干净的**x86系统**上，由于它**不需要通过操作系统而直接访问硬件**，hypervisor架构相对于hosted架构**效率更高**，且具有**更好的可扩展性、健壮性和性能**。

VMware Player, ACE, Workstation和Server使用了hosted架构的便捷性，而ESX server针对已认证的硬件采用hypervisor架构以达到数据中心级别的性能。

了解各个组件的大概背景，有助于更好的理解**x86虚拟化技术**。**虚拟化层**是负责**运行和管理所有虚拟机的软件**，操作系统运行于**虚拟机监控器(VMM**s)上。

如图所示，**虚拟化层！！！**是**直接运行在硬件上的hypervisor！！！**，基于**不同架构**和**实现方法的hypervisor**所具有的**功能有很大不同**。

运行于**hypervisor**上的**每个VMM！！！**实现了**虚拟机的硬件抽象！！！**并负责**运行虚拟机系统！！！**，**每个VMM！！！**需要通过分割和共享CPU、内存和I/O设备来完成系统的虚拟化。

![config](./images/2.png)

# 2 CPU虚拟化

## 2.1 x86硬件虚拟化的挑战

**x86操作系统**被设计成**直接运行在硬件**上，自然这些**系统会认为它们拥有硬件的全部控制权(！！！**)。如图所示，**x86架构**为操作系统和应用程序提供了四个不同级别的权限来管理对硬件的访问，分别为ring 0，1，2和3。**用户程序**一般运行在**ring 3**，**操作系统**需要直**接访问内存和硬件！！！**，因此需要在**ring 0**执行它的**特权指令**。

**x86架构**的**虚拟化**需要在**操作系统(运行于最高权限的ring 0)之下**放置一个提供**共享资源的虚拟化层**来创建和管理虚拟机。比较糟的是，**有些敏感指令**在**非ring 0**下执行时具有不同的语义，因此不能很好地将其虚拟化。在**运行时陷入并翻译这些敏感指令和特权指令**是一个艰难的挑战，这使得x86架构的虚拟化起初看起来是不可完成的任务。

![config](./images/3.png)

**VMware**在1998年就攻克了这个挑战，开发了**二进制翻译技术！！！**使得**VMM运行在ring 0**以达到隔离和性能的要求，而将**操作系统**转移到比**应用程序所在ring 3权限高**和比**虚拟机监控器所在ring 0权限低**的用户级。基于VMware 20000多客户的安装使用情况以及所形成的广大合作伙伴生态系统，**VMware**使用**二进制翻译的全虚拟化方案**已经成为**事实上的标准**，总的来说业界还没有一个开放的标准来定义和管理虚拟化。每个开发虚拟化解决方案的公司可以用不同的方式应对这个技术上的挑战，提供的解决方案良莠不齐。

正如以下阐述的，目前有**三种技术**来实现**x86架构CPU敏感指令**和**特权指令的虚拟化**，分别为：

- 使用**二进制翻译**的**全虚拟化**；

- **操作系统辅助或半虚拟化**；

- **硬件辅助的虚拟化**(第一代)；

### 2.1.1 使用二进制翻译的全虚拟化

使用**二进制翻译**和**直接指令执行相结合**的技术，VMware可以**虚拟化任何基于x86的操作系统**。这种方法如图所示，将**内核代码翻译！！！**，以便使用一系列**作用于虚拟化硬件**可达到所需效果的**新指令序列！！！**替换那些**不可虚拟化的指令！！！**。同时，**用户级的代码直接运行在物理处理器！！！**上保证虚拟化的高性能。**虚拟机监控器(！！！VMM！！！**)为**每个虚拟机(！！！虚拟机和VMM一一对应！！！**)提供类似于**真实物理系统所具有的服务**，如**一个虚拟的BIOS**，**虚拟化设备**和**虚拟化的内存管理**。

![config](./images/4.png)

注: 图中很清晰, Guest OS用户态命令直接在host的物理硬件上直接运行, Guest OS的敏感指令和特权指令被二进制翻译成新的指令序列然后在物理硬件上运行.

**二进制翻译**和**直接指令执行**相结合的**全虚拟化！！！**使得**虚拟机系统**和**底下的物理硬件彻底解耦**。**虚拟机系统没有意识到它是被虚拟化**的，因此**不需要虚拟机系统(客户操作系统！！！)做任何的修改**。**全虚拟化**是**不需要硬件辅助！！！**或**操作系统辅助！！！**来**虚拟化敏感指令和特权指令的唯一方案！！！**。**hypervisor**将**操作系统的指令翻译并将结果缓存供之后使用**，而**用户级指令无需修改就运行**，具有和物理机一样的执行速度。

全虚拟化为虚拟机提供最佳的隔离和安全性，使移植变得简单，因为同样的虚拟机系统可运行于虚拟化环境或真实物理硬件上。VMware的虚拟化产品和微软的Virtual Server是全虚拟化的例子。

### 2.1.2 操作系统辅助虚拟化或半虚拟化

"Para"是源于希腊的英文词缀，意为“beside”、“with”、“alongside”。就以“alongside virtualization”来说，**半虚拟化**指的是**虚拟机系统**和**hypervisor**通过**交互来改善性能和效率**。如图所示，**半虚拟化**涉及到**修改操作系统内核(客户机操作系统！！！**)来将**不可虚拟化的指令**替换为**直接与虚拟化层交互！！！的超级调用(hypercalls**)。hypervisor同样为**其他关键的系统操作**如**内存管理**、**中断处理**、**计时**等提供了**超级调用接口**。

![config](./images/5.png)

注: Guest OS用户态指令直接在host的物理硬件上直接运行, 修改Guest OS, 将不可虚拟化的指令替换成发给hypervisor的超级调用, 然后VMM和物理硬件交互.

半虚拟化和全虚拟化不一样，全虚拟化时未经修改的虚拟机系统不知道自身被虚拟化，系统敏感的调用陷入后再进行二进制翻译。半虚拟化的价值在于更低的虚拟化代价，但是半虚拟化相对全虚拟化的性能优势根据不同的工作负载有很大差别。半虚拟化不支持未经修改的操作系统(如Windows 2000/XP)，因此它的兼容性和可移植性较差。由于半虚拟化需要系统内核的深度修改，在生产环境中，半虚拟化在技术支持和维护上会有很大的问题。开源的Xen项目是半虚拟化的一个例子，它使用一个经过修改的Linux内核来虚拟化处理器，而用另外一个定制的虚拟机系统的设备驱动来虚拟化I/O。

使用二进制翻译来实现虚拟化更复杂更困难，相对来说修改虚拟机系统较容易。这些年来，VMware在自己的产品线中，以VMware tools和经优化的虚拟设备驱动的方式使用了半虚拟化某些方面的技术。VMware tools为VMM hypervisor进行时间同步、日志服务、和关闭虚拟机等服务提供了一个后门。Vmxnet是一个半虚拟化的I/O设备驱动，它和hypervisor共享一些数据结构。它通过利用宿主机设备的能力来获得更好的吞吐量和更低的CPU的使用量。需要澄清的是，VMware tools服务和vmxnet设备驱动并不是CPU半虚拟化方案，它们是小型的，非入侵式地安装在虚拟机系统中，不需要系统内核作修改。从今往后，VMware也在帮助开发半虚拟化的Linux版本，以支持概念验证和产品开发。更多的信息见之后的页11。

