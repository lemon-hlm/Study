
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 代码结构](#1-代码结构)
	* [1.1 开始执行: \/vl.c、\/cpus.c、\/exec\-all.c, \/exec.c和\/cpu\-exec.c](#11-开始执行-vlc-cpusc-exec-allc-execc和cpu-execc)
	* [1.2 硬件模拟: \/hw\/](#12-硬件模拟-hw)
	* [1.3 目标机器: \/target\/arch/, 将客户机代码转为TCG操作码](#13-目标机器-targetarch-将客户机代码转为tcg操作码)
	* [1.4 主机: \/tcg\/, 将TCG操作码转换成主机代码](#14-主机-tcg-将tcg操作码转换成主机代码)
	* [1.5 文件总结和补充：](#15-文件总结和补充)
* [2 TCG \- 动态翻译](#2-tcg-动态翻译)
* [3 TB链](#3-tb链)
* [4 QEMU的TCG代码分析](#4-qemu的tcg代码分析)
* [5 QEMU中的IOCTL](#5-qemu中的ioctl)
* [6 参考](#6-参考)

<!-- /code_chunk_output -->

# 1 代码结构

如我们所知，QEMU是一个模拟器，它能够动态模拟**特定架构的CPU指令**，如X86，PPC，ARM等等。

**QEMU模拟的架构**叫**目标架构**，

**运行QEMU**的**系统架构**叫**主机架构**，

QEMU中有一个**模块**叫做**微型代码生成器（TCG, Tiny Code Generator**），它用来将**目标代码翻译成主机代码**。如下图所示。

![](./images/2019-06-04-16-25-48.png)

将**运行在虚拟cpu**上的代码叫做**客户机代码**

**QEMU**的**主要功能**就是**不断提取客户机代码！！！** 并且**转化成主机指定架构的代码！！！**。

**整个翻译任务**分为**两个部分**：

- 第一个部分是将做**目标代码（TB**）转化成**TCG中间代码**，
- 然后再将**中间代码**转化成**主机代码**。

QEMU的代码结构非常清晰但是内容非常复杂，这里先简单分析一下总体的结构

## 1.1 开始执行: \/vl.c、\/cpus.c、\/exec\-all.c, \/exec.c和\/cpu\-exec.c

主要比较重要的c文件有：/vl.c, /cpus.c, /exec\-all.c, /exec.c, /cpu\-exec.c.

QEMU的**main函数**定义在/**vl.c**中，它也是**执行的起点**，这个函数的功能主要是**建立一个虚拟的硬件环境**。

它通过**参数的解析**，将**初始化内存**，需要的**模拟的设备初始化**，**CPU参数**，**初始化KVM**等等。

接着程序就跳转到**其他的执行分支文件**如：/cpus.c, /exec\-all.c, /exec.c, /cpu\-exec.c.

## 1.2 硬件模拟: \/hw\/

所有的**硬件设备**都在/**hw**/ 目录下面，**所有的设备**都有**独自的文件**，包括**总线**，**串口**，**网卡**，**鼠标**等等。它们通过**设备模块串在一起**，在**vl.c**中的**machine\_init**中初始化。

## 1.3 目标机器: \/target\/arch/, 将客户机代码转为TCG操作码

现在QEMU**模拟的CPU架构**有：Alpha, ARM, Cris, i386, M68K, PPC, Sparc, Mips, MicroBlaze, S390X and SH4.

我们在QEMU中使用./**configure** 可以**配置运行的架构**，这个脚本会**自动**读取**本机真实机器的CPU架构**，并且编译的时候就编译**对应架构的代码**。

对于不同的QEMU做的事情都不同，所以不同架构下的代码在不同的目录下面。

/**target/arch**/目录就对应了**相应架构的代码**，如/target/i386/就对应了x86系列的代码部分。

虽然**不同架构做法不同**，但是都是为了**实现**将**对应客户机CPU架构的TBs！！！** 转化成**TCG的中间代码**。

这个就是**TCG的前半部分**。

## 1.4 主机: \/tcg\/, 将TCG操作码转换成主机代码

这个部分就是**使用TCG代码生成主机的代码**，这部分代码在/tcg/里面，在这个目录里面也**对应了不同的架构**，分别在不同的子目录里面，如i386就在/tcg/i386中。

**整个生成主机代码的过程**也可以叫**TCG的后半部分**。

## 1.5 文件总结和补充：

/vl.c: 最主要的**模拟循环**，**虚拟机机器环境初始化**，和**CPU的执行**。

/**target/arch/translate.c**: 将**客户机代码**转化成**不同架构的TCG操作码**。

/tcg/tcg.c: **主要的TCG代码**。

/**tcg/arch/tcg\-target.c**: 将**TCG代码**转化生成**主机代码**

/**cpu\-exec.c**: 其中的**cpu\-exec**()函数主要**寻找下一个TB（翻译代码块**），如果没找到就**请求得到下一个TB**，并且操作生成的代码块。

# 2 TCG \- 动态翻译

QEMU在 0.9.1版本之前使用**DynGen翻译c代码**. 当我们**需要的时候**TCG会动态的转变代码，这个想法的目的是用**更多的时间**去**执行我们生成的代码**。当**新的代码**从**TB中生成**以后， 将会被**保存到一个cache**中，因为**很多相同的TB**会被**反复的进行操作**，所以这样类似于内存的cache，能够**提高使用效率**。而**cache的刷新使用LRU算法**。

![](./images/2019-06-04-18-42-54.png)

**编译器**在执行器会从**源代码**中**产生目标代码**，像**GCC**这种编译器，它为了产生像**函数调用**, 目标代码会产生一些**特殊的汇编目标代码**，他们能够让编译器需要知道在**调用函数**、**需要什么**以及**函数调用以后需要返回什么**，这些**特殊的汇编代码产生过程**就叫做函数的**Prologue和Epilogue**，这里就叫前端和后端吧。

我在其他文章中也分析过**汇编调用函数的过程**，至于汇编里面函数调用过程中寄存器是如何变化的，在本文中就不再描述了。

**函数的后端**会**恢复前端的状态**，主要做下面2点：

1. **恢复堆栈的指针**，包括**栈顶**和**基地址**。

2. 修改**cs**和**ip**，程序回到之前的**前端记录点**。

**TCG**就如编译器一样可以产生目标代码，代码会保存在缓冲区中，当进入前端和后端的时候就会将TCG生成的缓冲代码插入到目标代码中。

接下来我们就来看下如何翻译代码的：

>客户机代码

![](./images/2019-06-04-18-53-07.png)

>TCG中间代码

![](./images/2019-06-04-18-53-26.png)

>主机代码

![](./images/2019-06-04-18-53-39.png)

关于TCG的解释：TCG(Tiny Code Generator),QEMU的官方解释在http://wiki.qemu-project.org/Documentation/TCG。

TCG的作用就是将Target的指令通过TCG前端转换成TCG ops，进而通过TCG后端转换成Host上运行的指令。

需要将QEMU移植到一个新CPU上运行，需要关注TCG后端。需要基于QEMU模拟一个新CPU，需要关注TCG前端。

# 3 TB链

在QEMU中，从**代码cache**到**静态代码**再**回到代码cache**，这个过程比较耗时，所以在QEMU中涉及了**一个TB链**将**所有TB连在一起**，可以让**一个TB**执行完以后**直接跳到下一个TB**，而**不用每次都返回到静态代码**部分。具体过程如下图：

![](./images/2019-06-04-20-26-37.png)

# 4 QEMU的TCG代码分析

接下来来看看QEMU代码中中到底怎么来执行这个TCG的，看看它是如何生成主机代码的。

>main\_loop(...){/vl.c}:
>
>函数main\_loop 初始化qemu\_main\_loop\_start() 然后**进入无限循环**cpu\_exec\_all(), 这个是QEMU的一个主要循环，在里面会不断的**判断一些条件**，如**虚拟机的关机断电之类**的。


>qemu\_main\_loop\_start(...){/cpus.c} :
>
>函数设置**系统变量 qemu\_system\_ready = 1**并且**重启所有的线程**并且等待一个条件变量。 


>cpu\_exec\_all(...){/cpus.c} :
>
>它是cpu循环，QEMU能够启动256个cpu核，但是这些核将会分时运行，然后执行qemu\_cpu\_exec() 。


>struct CPUState{/target\-xyz/cpu.h} :
>
>它是CPU状态结构体，关于cpu的各种状态，不同架构下面还有不同。

 

>cpu\_exec(...){/cpu\-exec.c}:
>
>这个函数是主要的执行循环，这里第一次翻译之前说道德TB，TB被初始化为(TranslationBlock \*tb) ，然后不停的执行异常处理。其中嵌套了两个无限循环 find tb\_find\_fast() 和tcg\_qemu\_tb\_exec().
>cantb\_find\_fast()为客户机初始化查询下一个TB，并且生成主机代码。
>tcg\_qemu\_tb\_exec()执行生成的主机代码 


>struct TranslationBlock {/exec-all.h}:
>
>结构体TranslationBlock包含下面的成员：PC, CS_BASE, Flags （表明TB）, tc\_ptr (指向这个TB翻译代码的指针), tb\_next\_offset\[2], tb\_jmp\_offset\[2] (接下去的Tb), \*jmp_next\[2], \*jmp\_first (之前的TB).

 
>tb\_find\_fast(...){/cpu-exec.c} :
>
>函数通过调用获得程序指针计数器，然后传到一个哈希函数从 tb\_jmp\_cache\[]（一个哈希表）得到TB的所以，所以使用tb\_jmp\_cache可以找到下一个TB。如果没有找到下一个TB，则使用tb\_find\_slow。


>tb\_find\_slow(...){/cpu\-exec.c}:
>
>这个是在快速查找失败以后试图去访问物理内存，寻找TB。


>tb\_gen\_code(...){/exec.c}:
>
>开始分配一个新的TB，TB的PC是刚刚从CPUstate里面通过using get_page_addr_code()找到的

>phys_pc = get_page_addr_code(env, pc);
>
>tb = tb_alloc(pc);

>ph当调用cpu_gen_code() 以后，接着会调用tb_link_page() ，它将增加一个新的TB，并且指向它的物理页表。

>cpu_gen_code(...){translate-all.c}:

>函数初始化真正的代码生成，在这个函数里面有下面的函数调用：

>gen_intermediate_code(){/target-arch/translate.c}->gen_intermediate_code_internal(){/target-arch/translate.c }->disas_insn(){/target-arch/translate.c}

>disas_insn(){/target-arch/translate.c}

>函数disas_insn() 真正的实现将客户机代码翻译成TCG代码，它通过一长串的switch case，将不同的指令做不同的翻译，最后调用tcg_gen_code。

 

>tcg_gen_code(...){/tcg/tcg.c}:

>这个函数将TCG的代码转化成主机代码，这个就不细细说明了，和前面类似。

 

>\#define tcg_qemu_tb_exec(...){/tcg/tcg.g}:
>
>通过上面的步骤，当TB生成以后就通过这个函数进行执行.

>next_tb = tcg_qemu_tb_exec(tc_ptr) :

>extern uint8_t code_gen_prologue[];

>\#define tcg_qemu_tb_exec(tb_ptr) ((long REGPARM(*)(void *)) code_gen_prologue)(tb_ptr)

通过上面的步骤我们就解析了QEMU是如何将客户机代码翻译成主机代码的，了解了TCG的工作原理。接下来看看QEMU与KVM是怎么联系的。

# 5 QEMU中的IOCTL

在QEMU-KVM中，用户空间的QEMU是通过IOCTL与内核空间的KVM模块进行通讯的。

1. 创建KVM
在/vl.c中通过kvm_init()将会创建各种KVM的结构体变量，并且通过IOCTL与已经初始化好的KVM模块进行通讯，创建虚拟机。然后创建VCPU，等等。

2. KVM_RUN
这个IOCTL是使用最频繁的，整个KVM运行就不停在执行这个IOCTL，当KVM需要QEMU处理一些指令和IO等等的时候就会退出通过这个IOCTL退回到QEMU进行处理，不然就会一直在KVM中执行。

它的初始化过程：

vl.c中调用machine->init初始化硬件设备接着调用pc_init_pci，然后再调用pc_init1。

接着通过下面的调用初始化KVM的主循环，以及CPU循环。在CPU循环的过程中不断的执行KVM_RUN与KVM进行交互。

pc_init1->pc_cpus_init->pc_new_cpu->cpu_x86_init->qemu_init_vcpu->kvm_init_vcpu->ap_main_loop->kvm_main_loop_cpu->kvm_cpu_exec->kvm_run

3.KVM_IRQ_LINE
这个IOCTL和KVM_RUN是不同步的，它也是个频率非常高的调用，它就是一般中断设备的中断注入入口。当设备有中断就通过这个IOCTL最终调用KVM里面的kvm_set_irq将中断注入到虚拟的中断控制器。在kvm中会进一步判断属于什么中断类型，然后在合适的时机写入vmcs。当然在KVM_RUN中会不断的同步虚拟中断控制器，来获取需要注入的中断，这些中断包括QEMU和KVM本身的，并在重新进入客户机之前注入中断。

# 6 参考

- https://blog.csdn.net/yearn520/article/details/6602182 
- https://www.cnblogs.com/arnoldlu/p/6510626.html