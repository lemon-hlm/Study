
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 代码结构](#1-代码结构)
	* [1.1 开始执行](#11-开始执行)
	* [1.2 硬件模拟](#12-硬件模拟)
	* [1.3 目标机器](#13-目标机器)
	* [1.4 主机](#14-主机)

<!-- /code_chunk_output -->

# 1 代码结构

如我们所知，QEMU是一个模拟器，它能够动态模拟**特定架构的CPU指令**，如X86，PPC，ARM等等。

**QEMU模拟的架构**叫**目标架构**，

**运行QEMU**的**系统架构**叫**主机架构**，

QEMU中有一个**模块**叫做**微型代码生成器（TCG**），它用来将**目标代码翻译成主机代码**。如下图所示。

![](./images/2019-06-04-16-25-48.png)

将**运行在虚拟cpu**上的代码叫做**客户机代码**

**QEMU**的**主要功能**就是**不断提取客户机代码**并且**转化成主机指定架构的代码**。

整个翻译任务分为**两个部分**：

- 第一个部分是将做**目标代码（TB**）转化成**TCG中间代码**，
- 然后再将**中间代码**转化成**主机代码**。

QEMU的代码结构非常清晰但是内容非常复杂，这里先简单分析一下总体的结构

## 1.1 开始执行

主要比较重要的c文件有：/vl.c, /cpus.c, /exec\-all.c, /exec.c, /cpu\-exec.c.

QEMU的**main函数**定义在/**vl.c**中，它也是**执行的起点**，这个函数的功能主要是**建立一个虚拟的硬件环境**。

它通过**参数的解析**，将**初始化内存**，需要的**模拟的设备初始化**，**CPU参数**，**初始化KVM**等等。

接着程序就跳转到**其他的执行分支文件**如：/cpus.c, /exec\-all.c, /exec.c, /cpu\-exec.c.

## 1.2 硬件模拟

所有的**硬件设备**都在/**hw**/ 目录下面，**所有的设备**都有**独自的文件**，包括**总线**，**串口**，**网卡**，**鼠标**等等。它们通过**设备模块串在一起**，在**vl.c**中的**machine\_init**中初始化。

## 1.3 目标机器

现在QEMU模拟的CPU架构有：Alpha, ARM, Cris, i386, M68K, PPC, Sparc, Mips, MicroBlaze, S390X and SH4.

我们在QEMU中使用./**configure** 可以**配置运行的架构**，这个脚本会**自动**读取**本机真实机器的CPU架构**，并且编译的时候就编译**对应架构的代码**。

对于不同的QEMU做的事情都不同，所以不同架构下的代码在不同的目录下面。/**target/arch**/目录就对应了相应架构的代码，如/target/i386/就对应了x86系列的代码部分。虽然**不同架构做法不同**，但是都是为了**实现**将**对应客户机CPU架构的TBs**转化成**TCG的中间代码**。这个就是**TCG的前半部分**。

## 1.4 主机

这个部分就是使用TCG代码生成主机的代码，这部分代码在/tcg/里面，在这个目录里面也对应了不同的架构，分别在不同的子目录里面，如i386就在/tcg/i386中。整个生成主机代码的过程也可以教TCG的后半部分。

