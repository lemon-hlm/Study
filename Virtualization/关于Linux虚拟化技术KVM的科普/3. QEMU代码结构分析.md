
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 代码结构](#1-代码结构)
	* [1.1 开始执行: \/vl.c、\/cpus.c、\/exec\-all.c, \/exec.c和\/cpu\-exec.c](#11-开始执行-vlc-cpusc-exec-allc-execc和cpu-execc)
	* [1.2 硬件模拟: \/hw\/](#12-硬件模拟-hw)
	* [1.3 目标机器: \/target\/arch/](#13-目标机器-targetarch)
	* [1.4 主机: \/tcg\/](#14-主机-tcg)
	* [1.5 文件总结和补充：](#15-文件总结和补充)
* [2 TCG - 动态翻译](#2-tcg-动态翻译)
* [3 TB链](#3-tb链)
* [4 QEMU的TCG代码分析](#4-qemu的tcg代码分析)

<!-- /code_chunk_output -->

# 1 代码结构

如我们所知，QEMU是一个模拟器，它能够动态模拟**特定架构的CPU指令**，如X86，PPC，ARM等等。

**QEMU模拟的架构**叫**目标架构**，

**运行QEMU**的**系统架构**叫**主机架构**，

QEMU中有一个**模块**叫做**微型代码生成器（TCG**），它用来将**目标代码翻译成主机代码**。如下图所示。

![](./images/2019-06-04-16-25-48.png)

将**运行在虚拟cpu**上的代码叫做**客户机代码**

**QEMU**的**主要功能**就是**不断提取客户机代码！！！** 并且**转化成主机指定架构的代码！！！**。

**整个翻译任务**分为**两个部分**：

- 第一个部分是将做**目标代码（TB**）转化成**TCG中间代码**，
- 然后再将**中间代码**转化成**主机代码**。

QEMU的代码结构非常清晰但是内容非常复杂，这里先简单分析一下总体的结构

## 1.1 开始执行: \/vl.c、\/cpus.c、\/exec\-all.c, \/exec.c和\/cpu\-exec.c

主要比较重要的c文件有：/vl.c, /cpus.c, /exec\-all.c, /exec.c, /cpu\-exec.c.

QEMU的**main函数**定义在/**vl.c**中，它也是**执行的起点**，这个函数的功能主要是**建立一个虚拟的硬件环境**。

它通过**参数的解析**，将**初始化内存**，需要的**模拟的设备初始化**，**CPU参数**，**初始化KVM**等等。

接着程序就跳转到**其他的执行分支文件**如：/cpus.c, /exec\-all.c, /exec.c, /cpu\-exec.c.

## 1.2 硬件模拟: \/hw\/

所有的**硬件设备**都在/**hw**/ 目录下面，**所有的设备**都有**独自的文件**，包括**总线**，**串口**，**网卡**，**鼠标**等等。它们通过**设备模块串在一起**，在**vl.c**中的**machine\_init**中初始化。

## 1.3 目标机器: \/target\/arch/

现在QEMU模拟的CPU架构有：Alpha, ARM, Cris, i386, M68K, PPC, Sparc, Mips, MicroBlaze, S390X and SH4.

我们在QEMU中使用./**configure** 可以**配置运行的架构**，这个脚本会**自动**读取**本机真实机器的CPU架构**，并且编译的时候就编译**对应架构的代码**。

对于不同的QEMU做的事情都不同，所以不同架构下的代码在不同的目录下面。

/**target/arch**/目录就对应了**相应架构的代码**，如/target/i386/就对应了x86系列的代码部分。

虽然**不同架构做法不同**，但是都是为了**实现**将**对应客户机CPU架构的TBs**转化成**TCG的中间代码**。

这个就是**TCG的前半部分**。

## 1.4 主机: \/tcg\/

这个部分就是**使用TCG代码生成主机的代码**，这部分代码在/tcg/里面，在这个目录里面也**对应了不同的架构**，分别在不同的子目录里面，如i386就在/tcg/i386中。

**整个生成主机代码的过程**也可以叫**TCG的后半部分**。

## 1.5 文件总结和补充：

/vl.c: 最主要的**模拟循环**，**虚拟机机器环境初始化**，和**CPU的执行**。

/target/arch/translate.c: 将**客户机代码**转化成**不同架构的TCG操作码**。

/tcg/tcg.c: 主要的**TCG代码**。

/tcg/arch/tcg\-target.c: 将**TCG代码**转化生成**主机代码**

/cpu\-exec.c: 其中的**cpu\-exec**()函数主要**寻找下一个TB（翻译代码块**），如果没找到就**请求得到下一个TB**，并且操作生成的代码块。

# 2 TCG - 动态翻译

QEMU在 0.9.1版本之前使用**DynGen翻译c代码**. 当我们**需要的时候**TCG会动态的转变代码，这个想法的目的是用**更多的时间**去**执行我们生成的代码**。当**新的代码**从**TB中生成**以后， 将会被**保存到一个cache**中，因为**很多相同的TB**会被**反复的进行操作**，所以这样类似于内存的cache，能够**提高使用效率**。而**cache的刷新使用LRU算法**。

![](./images/2019-06-04-18-42-54.png)

**编译器**在执行器会从**源代码**中**产生目标代码**，像**GCC**这种编译器，它为了产生像**函数调用**, 目标代码会产生一些**特殊的汇编目标代码**，他们能够让编译器需要知道在**调用函数**、**需要什么**以及**函数调用以后需要返回什么**，这些**特殊的汇编代码产生过程**就叫做函数的**Prologue和Epilogue**，这里就叫前端和后端吧。

我在其他文章中也分析过**汇编调用函数的过程**，至于汇编里面函数调用过程中寄存器是如何变化的，在本文中就不再描述了。

**函数的后端**会**恢复前端的状态**，主要做下面2点：

1. **恢复堆栈的指针**，包括**栈顶**和**基地址**。

2. 修改**cs**和**ip**，程序回到之前的**前端记录点**。

TCG就如编译器一样可以产生目标代码，代码会保存在缓冲区中，当进入前端和后端的时候就会将TCG生成的缓冲代码插入到目标代码中。

接下来我们就来看下如何翻译代码的：

>客户机代码

![](./images/2019-06-04-18-53-07.png)

>TCG中间代码

![](./images/2019-06-04-18-53-26.png)

>主机代码

![](./images/2019-06-04-18-53-39.png)

# 3 TB链

在QEMU中，从**代码cache**到**静态代码**再**回到代码cache**，这个过程比较耗时，所以在QEMU中涉及了**一个TB链**将**所有TB连在一起**，可以让一个TB执行完以后直接跳到下一个TB，而不用每次都返回到静态代码部分。具体过程如下图：

![](./images/2019-06-04-20-26-37.png)

# 4 QEMU的TCG代码分析

接下来来看看QEMU代码中中到底怎么来执行这个TCG的，看看它是如何生成主机代码的。

main_loop(...){/vl.c} : 

函数main_loop 初始化qemu_main_loop_start() 然后进入无限循环cpu_exec_all() ， 这个是QEMU的一个主要循环，在里面会不断的判断一些条件，如虚拟机的关机断电之类的。

qemu_main_loop_start(...){/cpus.c} :

函数设置系统变量 qemu_system_ready = 1并且重启所有的线程并且等待一个条件变量。 

