https://blog.csdn.net/dongfei2033/article/details/82756634

# 1 全虚拟化

**不需要**对**GuestOS操作系统软件的源代码做任何的修改**，就可以运行在这样的VMM中

在**全虚拟化的虚拟平台**中，**GuestOS**并**不知道**自己是一台**虚拟机**，它会认为自己就是运行在计算机物理硬件设备上的HostOS。因为**全虚拟化的VMM！！！**会将一个**OS**所能够操作的**CPU**、**内存**、**外设**等物理设备**逻辑抽象**成为**虚拟CPU**、**虚拟内存**、**虚拟外设**等虚拟设备后，再交由**GuestOS来操作使用**。这样的GuestOS会将底层硬件平台视为自己所有的，但是实际上，这些都是VMM为GuestOS制造了这种假象。

全虚拟化又分为：软件辅助的全虚拟化 & 硬件辅助的全虚拟化。

## 1.1 软件辅助的全虚拟化

架构图

![config](./images/12.png)

在Intel等CPU厂商还没有发布**x86 CPU虚拟化技术之前**，**完全虚拟化**都是通过**软件辅助**的方式来实现的。

而**软件辅助的全虚拟化**主要是应用了**两种机制**：

1. **特权解除(优先级压缩**)：从上述的软件辅助全虚拟化架构图中可以看出，**VMM**、**GuestOS**、**GuestApplications**都是运行在**Ring 1-3用户态(！！！VMM也处于用户态！！！**)中的应用程序代码。当在**GuestOS**中执行**系统内核的特权指令**时，一般都会**触发异常！！！**。这是因为**用户态代码**不能直接运行在**核心态**中，而且**系统内核的特权指令**大多都**只能运行在Ring 0核心态**中。在**触发了异常**之后，这些**异常就会被VMM捕获**，再由**VMM！！！**将这些**特权指令！！！**进行**虚拟化**成为**只针对虚拟CPU起作用(！！！**)的**虚拟特权指令！！！**。其本质就是使用**若干能运行在用户态中的非特权指令(！！！**)来模拟出只针对GuestOS有效的虚拟特权指令，从而将特权指令的特权解除掉。
2. 
缺点：但是特权解除的问题在于当初设计标准x86架构CPU时，并没有考虑到要支持虚拟化技术，所以会存在一部分特权指令运行在Ring 1用户态上，而这些运行在Ring 1上的特权指令并不会触发异常然后再被VMM捕获。从而导致在GuestOS中执行的特权指令直接对HostOS造成了影响(GuestOS和HostOS没能做到完全隔离)。
针对这个问题，再引入了陷入模拟的机制。

2. 陷入模拟(二进制翻译)：就是VMM会对GuestOS中的二进制代码(运行在CPU中的代码)进行扫描，一旦发现GuestOS执行的二进制代码中包含有运行在用户态上的特权指令二进制代码时，就会将这些二进制代码翻译成虚拟特权指令二进制代码或者是翻译成运行在核心态中的特权指令二进制代码从而强制的触发异常。这样就能够很好的解决了运行在Ring 1用户态上的特权指令没有被VMM捕获的问题，更好的实现了GuestOS和HostOS的隔离。

简而言之，软件辅助虚拟化能够成功的将所有在GuestOS中执行的系统内核特权指令进行捕获、翻译，使之成为只能对GuestOS生效的虚拟特权指令。但是退一步来说，之所以需要这么做的前提是因为CPU并不能准确的去判断一个特权指令到底是由GuestOS发出的还是由HostOS发出的，这样也就无法针对一个正确的OS去将这一个特权指令执行。

直到后来CPU厂商们发布了能够判断特权指令归属的标准x86 CPU之后，迎来了硬件辅助全虚拟化。


