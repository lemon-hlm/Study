https://blog.csdn.net/dongfei2033/article/details/82756634

# 1 全虚拟化

**不需要**对**GuestOS操作系统软件的源代码做任何的修改**，就可以运行在这样的VMM中

在**全虚拟化的虚拟平台**中，**GuestOS**并**不知道**自己是一台**虚拟机**，它会认为自己就是运行在计算机物理硬件设备上的HostOS。因为**全虚拟化的VMM！！！**会将一个**OS**所能够操作的**CPU**、**内存**、**外设**等物理设备**逻辑抽象**成为**虚拟CPU**、**虚拟内存**、**虚拟外设**等虚拟设备后，再交由**GuestOS来操作使用**。这样的GuestOS会将底层硬件平台视为自己所有的，但是实际上，这些都是VMM为GuestOS制造了这种假象。

全虚拟化又分为：软件辅助的全虚拟化 & 硬件辅助的全虚拟化。

## 1.1 软件辅助的全虚拟化

架构图

![config](./images/12.png)

在Intel等CPU厂商还没有发布**x86 CPU虚拟化技术之前**，**完全虚拟化**都是通过**软件辅助**的方式来实现的。

而**软件辅助的全虚拟化**主要是应用了**两种机制**：

1. **特权解除(优先级压缩**)：从上述的软件辅助全虚拟化架构图中可以看出，**VMM**、**GuestOS**、**GuestApplications**都是运行在**Ring 1-3用户态(！！！VMM也处于用户态！！！**)中的应用程序代码。当在**GuestOS**中执行**系统内核的特权指令**时，一般都会**触发异常！！！**。这是因为**用户态代码**不能直接运行在**核心态**中，而且**系统内核的特权指令**大多都**只能运行在Ring 0核心态**中。在**触发了异常**之后，这些**异常就会被VMM捕获**，再由**VMM！！！**将这些**特权指令！！！**进行**虚拟化**成为**只针对虚拟CPU起作用(！！！**)的**虚拟特权指令！！！**。其本质就是使用**若干能运行在用户态中的非特权指令(！！！**)来**模拟**出**只针对GuestOS有效的虚拟特权指令**，从而将特权指令的特权解除掉。

缺点：但是特权解除的问题在于当初设计**标准x86架构CPU**时，并没有考虑到要支持虚拟化技术，所以会存在**一部分特权指令**运行在**Ring 1用户态**上，而这些运行在Ring 1上的特权指令并**不会触发异常然后再被VMM捕获(！！！有些特权指令不会被VMM捕获！！！**)。从而导致在**GuestOS**中执行的**特权指令直接对HostOS**造成了影响(GuestOS和HostOS没能做到**完全隔离**)。

针对这个问题，再引入了**陷入模拟的机制**。

2. **陷入模拟(二进制翻译**)：就是**VMM**会对**GuestOS**中的**二进制代码(运行在CPU中的代码！！！**)进行**扫描！！！**，一旦发现**GuestOS**执行的**二进制代码**中包含有**运行在用户态上的特权指令二进制代码**时，就会将这些二进制代码翻译成**虚拟特权指令二进制代码(！！！**)或者是**翻译成运行在核心态中的特权指令！！！二进制代码从而强制的触发异常！！！**。这样就能够很好的解决了运行在**Ring 1用户态上的特权指令没有被VMM捕获！！！**的问题，更好的实现了GuestOS和HostOS的隔离。

简而言之，**软件辅助虚拟化**能够成功的将所有在**GuestOS**中执行的**系统内核特权指令**进行**捕获、翻译**，使之成为只能对GuestOS生效的虚拟特权指令。但是退一步来说，之所以需要这么做的前提是因为**CPU**并不能准确的去判断**一个特权指令！！！**到底是由**GuestOS发出！！！**的还是由**HostOS发出！！！**的，这样也就**无法针对一个正确的OS**去**将这一个特权指令执行**。

直到后来CPU厂商们发布了能够**判断特权指令归属！！！**的**标准x86 CPU**之后，迎来了**硬件辅助全虚拟化**。

## 1.2 硬件辅助的全虚拟化

![config](./images/13.png)

硬件辅助全虚拟化主要使用了**支持虚拟化功能**的**CPU**进行支撑，**CPU**可以明确的**分辨出**来自**GuestOS的特权指令**，并**针对GuestOS进行特权操作(！！！**)，而**不会影响到HostOS**。

从更深入的层次来说，**虚拟化CPU**形成了**新的CPU执行状态** —— **Non\-Root Mode& Root Mode**。从上图中可以看见，**GuestOS(！！！**)运行在**Non\-Root Mode** 的**Ring 0核心态**中，这表明**GuestOS**能够**直接执行特却指令**而不再需要 **特权解除** 和 **陷入模拟** 机制。并且在**硬件层**上面紧接的就是**虚拟化层的VMM**，而**不需要HostOS！！！**。这是因为在**硬件辅助全虚拟化的VMM**会以一种更具协作性的方式来实现虚拟化 —— 将**虚拟化模块**加载到**HostOS的内核**中，例如：KVM，KVM通过在HostOS内核中加载KVM Kernel Module来将**HostOS转换成为一个VMM！！！**。所以此时**VMM可以看作是HostOS，反之亦然**。

这种虚拟化方式创建的**GuestOS知道**自己是正在**虚拟化模式**中运行的GuestOS，KVM就是这样的一种虚拟化实现解决方案。

# 2 半虚拟化

需要对**GuestOS的内核代码**做一定的修改，才能够将GuestOS运行在半虚拟化的VMM中。

**半虚拟化**通过在**GuestOS的源代码级别上修改特权指令**来回避上述的虚拟化漏洞。

**修改内核**后的**GuestOS**也**知道**自己就是一台**虚拟机**。所以能够很好的对**核心态指令**和**敏感指令**进行识别和处理，但缺点在于**GuestOS的镜像文件并不通用**。

具体的**x86架构CPU**解析，请参考[虚拟化的发展历程和实现方式](https://blog.csdn.net/jmilk/article/details/51031118)
