https://blog.csdn.net/dongfei2033/article/details/82756634

# 1 全虚拟化

**不需要**对**GuestOS操作系统软件的源代码做任何的修改**，就可以运行在这样的VMM中

在**全虚拟化的虚拟平台**中，**GuestOS**并**不知道**自己是一台**虚拟机**，它会认为自己就是运行在计算机物理硬件设备上的HostOS。因为**全虚拟化的VMM！！！**会将一个**OS**所能够操作的**CPU**、**内存**、**外设**等物理设备**逻辑抽象**成为**虚拟CPU**、**虚拟内存**、**虚拟外设**等虚拟设备后，再交由**GuestOS来操作使用**。这样的GuestOS会将底层硬件平台视为自己所有的，但是实际上，这些都是VMM为GuestOS制造了这种假象。

全虚拟化又分为：软件辅助的全虚拟化 & 硬件辅助的全虚拟化。

## 1.1 软件辅助的全虚拟化

架构图

![config](./images/12.png)

在Intel等CPU厂商还没有发布**x86 CPU虚拟化技术之前**，**完全虚拟化**都是通过**软件辅助**的方式来实现的。

而**软件辅助的全虚拟化**主要是应用了**两种机制**：

1. **特权解除(优先级压缩**)：从上述的软件辅助全虚拟化架构图中可以看出，**VMM**、**GuestOS**、**GuestApplications**都是运行在**Ring 1-3用户态(！！！VMM也处于用户态！！！**)中的应用程序代码。当在**GuestOS**中执行**系统内核的特权指令**时，一般都会**触发异常！！！**。这是因为**用户态代码**不能直接运行在**核心态**中，而且**系统内核的特权指令**大多都**只能运行在Ring 0核心态**中。在**触发了异常**之后，这些**异常就会被VMM捕获**，再由**VMM！！！**将这些**特权指令！！！**进行**虚拟化**成为**只针对虚拟CPU起作用(！！！**)的**虚拟特权指令！！！**。其本质就是使用**若干能运行在用户态中的非特权指令(！！！**)来**模拟**出**只针对GuestOS有效的虚拟特权指令**，从而将特权指令的特权解除掉。

缺点：但是特权解除的问题在于当初设计**标准x86架构CPU**时，并没有考虑到要支持虚拟化技术，所以会存在**一部分特权指令**运行在**Ring 1用户态**上，而这些运行在Ring 1上的特权指令并**不会触发异常然后再被VMM捕获(！！！有些特权指令不会被VMM捕获！！！**)。从而导致在**GuestOS**中执行的**特权指令直接对HostOS**造成了影响(GuestOS和HostOS没能做到**完全隔离**)。

针对这个问题，再引入了**陷入模拟的机制**。

2. **陷入模拟(二进制翻译**)：就是**VMM**会对**GuestOS**中的**二进制代码(运行在CPU中的代码！！！**)进行**扫描！！！**，一旦发现**GuestOS**执行的**二进制代码**中包含有**运行在用户态上的特权指令二进制代码**时，就会将这些二进制代码翻译成**虚拟特权指令二进制代码(！！！**)或者是**翻译成运行在核心态中的特权指令！！！二进制代码从而强制的触发异常！！！**。这样就能够很好的解决了运行在**Ring 1用户态上的特权指令没有被VMM捕获！！！**的问题，更好的实现了GuestOS和HostOS的隔离。

简而言之，**软件辅助虚拟化**能够成功的将所有在**GuestOS**中执行的**系统内核特权指令**进行**捕获、翻译**，使之成为只能对GuestOS生效的虚拟特权指令。但是退一步来说，之所以需要这么做的前提是因为**CPU**并不能准确的去判断**一个特权指令！！！**到底是由**GuestOS发出！！！**的还是由**HostOS发出！！！**的，这样也就**无法针对一个正确的OS**去**将这一个特权指令执行**。

直到后来CPU厂商们发布了能够**判断特权指令归属！！！**的**标准x86 CPU**之后，迎来了**硬件辅助全虚拟化**。

## 1.2 硬件辅助的全虚拟化



