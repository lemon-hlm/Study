
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 概述](#0-概述)
* [1 解释执行](#1-解释执行)

<!-- /code_chunk_output -->

# 0 概述

对于传统的虚拟化漏洞, 在硬件设计对此问题改进前, 一些模拟技术已经先被使用来弥补这个漏洞, 提供平台虚拟化的能力. 可以说, 基于软件的CPU完全虚拟化, 其本质就是软件模拟. 所有的虚拟化的形式都可以用模拟来实现, 模拟的强大之处在于, VMM可以将虚拟机的整个执行过程置于控制中, VMM执行每一条指令都有时机进行模拟, 进而不会漏过需要模拟的敏感指令.

模拟技术早在现代虚拟化诞生之前就存在. 使用模拟器, 人们可以在一种平台上运行另一种平台的应用程序或操作系统, 例如DEC开发的FX!32能在ALPHA平台运行x86平台编译的应用程序. 图4\-1就是一个模拟器架构图.

![](./images/2019-05-05-15-39-13.png)

模拟技术不仅能用于应用程序级模拟, 而且可以用于系统级模拟. 它既能用于不同硬件体系结构间的模拟, 更可以用于相同硬件体系结构的模拟, 只不过在相同硬件体系结构下情况更简单, 这使得产生一些改进技术以提高虚拟化的性能.

# 1 解释执行

在模拟技术中, 最简单最直接的模拟技术是解释执行, 即取一条指令, 模拟出这条指令执行的效果, 