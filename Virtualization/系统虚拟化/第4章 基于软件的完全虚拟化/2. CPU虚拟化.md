
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 概述](#0-概述)
* [1 解释执行](#1-解释执行)
* [2 改进技术一: 扫描与修补](#2-改进技术一-扫描与修补)

<!-- /code_chunk_output -->

# 0 概述

对于传统的虚拟化漏洞, 在硬件设计对此问题改进前, 一些模拟技术已经先被使用来弥补这个漏洞, 提供平台虚拟化的能力. 可以说, 基于软件的CPU完全虚拟化, 其本质就是软件模拟. 所有的虚拟化的形式都可以用模拟来实现, 模拟的强大之处在于, VMM可以将虚拟机的整个执行过程置于控制中, VMM执行每一条指令都有时机进行模拟, 进而不会漏过需要模拟的敏感指令.

模拟技术早在现代虚拟化诞生之前就存在. 使用模拟器, 人们可以在一种平台上运行另一种平台的应用程序或操作系统, 例如DEC开发的FX!32能在ALPHA平台运行x86平台编译的应用程序. 图4\-1就是一个模拟器架构图.

![](./images/2019-05-05-15-39-13.png)

模拟技术不仅能用于应用程序级模拟, 而且可以用于系统级模拟. 它既能用于不同硬件体系结构间的模拟, 更可以用于相同硬件体系结构的模拟, 只不过在相同硬件体系结构下情况更简单, 这使得产生一些改进技术以提高虚拟化的性能.

# 1 解释执行

在模拟技术中, 最简单最直接的模拟技术是解释执行, 即取一条指令, 模拟出这条指令执行的效果, 再继续取下一条指令, 周而复始. 由于是一条一条取指令而不会漏掉没一条指令, 在某种程度上即每条指令都"陷入"了, 所以解决了陷入再模拟的问题, 进而避免了虚拟化漏洞. 这种方法不仅适用于模拟与物理机相同体系结构的虚拟机, 而且也适用于模拟与物理机不同体系结构的虚拟机.

图4\-2(a)所示为代码以正常执行的方式运行, 图4\-2(b)为虚拟机的代码以解释执行的方式运行. 图中灰色部分表示会被载入物理CPU执行的代码, 白色部分表示不会被载入物理CPU执行的代码. 

- **正常执行**的方式就是最常见的直接在**物理CPU上运行编译好的代码**; 
- 而在**解释执行**中, **编译好的二进制代码**是不会被载入到物理CPU直接运行的, 而是由**解释器逐条解码**, 再**调用对应的函数**来**模拟对应指令的功能**.

![](./images/2019-05-05-16-18-00.png)

虽然这种方法保证了所有指令执行受到VMM的监视控制, 然而它对每条指令不会区分对待, 最大缺点就是性能太差. 由于这里所说的虚拟化前提是模拟与物理机相同体系结构的虚拟机, 那么至少有很多非敏感指令不用模拟而可以直接在物理CPU上运行, 这便诞生了以下两种改进技术.

# 2 改进技术一: 扫描与修补

由于解释执行有很大的性能损失, 加上虚拟机中模拟的CPU和物理CPU体系结构相同, 这样多数指令可以被映射到物理CPU上直接运行, 因此, CPU虚拟化过程中可以采用更优化的模拟技术来弥补虚拟化漏洞.

扫描和修补技术通过这样的方式, 让大多数指令直接运行在物理CPU上, 而把操作系统代码中的敏感指令替换为跳转指令或会陷入到VMM中去的指令, 使其一旦运行到敏感指令处控制流就会进入VMM中, 由VMM代为模拟执行.

扫描与修补技术的流程如下.

⓵ VMM会在虚拟机开始执行每段代码之前对其进行扫描, 解析每一条指令, 查找到特权指令和敏感指令.

⓶ 补丁代码会在VMM中动态生成, 通常每个需要修补的指令会对应一块补丁代码.

⓷ 敏感指令被替换成一个外跳转, 从虚拟机跳转到VMM的空间中, 在VMM中执行动态生成的补丁代码.

