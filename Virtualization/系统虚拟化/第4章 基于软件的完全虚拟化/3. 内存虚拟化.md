
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 内存虚拟化的目的](#0-内存虚拟化的目的)
* [1 概述](#1-概述)
* [2 影子页表](#2-影子页表)

<!-- /code_chunk_output -->

# 0 内存虚拟化的目的

内存虚拟化的目的有两个.

- 提供给虚拟机一个从零地址开始的连续物理内存空间.
- 在各虚拟机之间有效隔离、调度和共享内存资源.

# 1 概述

为了让客户机OS使用一个隔离的、从零开始且具有连续性的内存空间, VMM引入一层新的地址空间, 即客户机物理地址空间. 客户机物理地址空间是客户机操作系统所能"看见"和管理的物理地址空间, 这个地址空间不是真正的物理地址空间, 它和物理地址空间还有一个映射. 有了客户机物理地址空间, 就形成了从应用程序所在的客户机虚拟地址(Guest Virtual Address, GVA)到客户机物理地址(Guest Physical Address, GPA), 再从客户机物理地址GPA到宿主机物理地址(Host Physical Address, HPA)的两层地址转换. 前一个转换由客户机OS完成, 后一个转换由VMM负责.

为实现从客户机物理地址GPA到宿主机物理地址HPA的地址翻译, VMM为**每个虚拟机**动态地维护了一张从**客户机物理地址**到**宿主机物理地址**映射关系的**表**.

有了这张表之后, VMM截获**任何试图修改客户机页表**或**刷新TLB的指令**, 根据这张表, 将修改从客户机虚拟地址到客户机物理地址映射的操作, 变成修改客户机虚拟地址到相应的宿主机物理地址映射的操作.

自从有了这张表, 虽然宿主机物理地址只有一个零起始地址, 但在不同客户机物理地址空间里, 可以各有一个零起始地址, 而且客户机OS看来连续的客户机物理内存地址空间, 其对应的宿主机物理内存可能是不连续的, 而这增加了VMM为多个虚拟机分配宿主机物理内存时的灵活性, 提高了宿主机物理内存的利用率.

VMM还可以通过该表确保运行于同一宿主机上的不同客户机访问的是不同的物理内存, 即相同的客户机物理地址呗映射到了不同的宿主机物理地址上. 这样一来, 一个客户机只能访问VMM通过该表设置分配给它的宿主机物理内存, 而不能访问其他客户机拥有的宿主机物理内存.

有时, VMM使用页共享技术以写时复制(Copy On Write)的方式让不同的客户机可以共享包含相同数据的宿主机物理页, 删除多余的页备份. 这种页共享方式, 是通过将不同客户机的某些客户机物理地址映射到相同的宿主机物理地址上, 来实现共享这个宿主机物理地址对应的宿主机物理页.

除此以外, VMM可以在客户机完全不知情情况下, 将客户机所拥有的某一客户机物理页映射到另一张新的宿主机物理页上, 甚至可以将客户机所拥有的某一客户机物理页所对应的宿主机物理页换出到硬盘上, 而客户机仍然以为它访问的客户机物理页是普通的硬件内存资源. 只有当它被真正访问, VMM才将换出的页再次换入到宿主机内存中.

# 2 影子页表

客户机OS所维护的页表负责传统的从客户机虚拟地址GVA到客户机物理地址GPA的转换. 如果MMU直接装载客户机OS所维护的页表来进行内存访问, 那么由于页表中每项所记录的都是GPA, 硬件无法正确通过多级页表来进行地址翻译.

针对这一问题, **影子页表(Shadow Page Table**)是一个有效地解决方法. 如图4\-10, **一份影子页表**与**一份客户机OS系统的页表对应**, 其做的是由**GVA直接到HPA**的地址翻译.

![](./images/2019-05-06-14-23-07.png)

