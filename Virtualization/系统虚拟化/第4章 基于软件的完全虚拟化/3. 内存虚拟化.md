
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 内存虚拟化的目的](#0-内存虚拟化的目的)
* [1 概述](#1-概述)

<!-- /code_chunk_output -->

# 0 内存虚拟化的目的

内存虚拟化的目的有两个.

- 提供给虚拟机一个从零地址开始的连续物理内存空间.
- 在各虚拟机之间有效隔离、调度和共享内存资源.

# 1 概述

为了让客户机OS使用一个隔离的、从零开始且具有连续性的内存空间, VMM引入一层新的地址空间, 即客户机物理地址空间. 客户机物理地址空间是客户机操作系统所能"看见"和管理的物理地址空间, 这个地址空间不是真正的物理地址空间, 它和物理地址空间还有一个映射. 有了客户机物理地址空间, 就形成了从应用程序所在的客户机虚拟地址(Guest Virtual Address, GVA)到客户机物理地址(Guest Physical Address, GPA), 再从客户机物理地址GPA到宿主机物理地址(Host Physical Address, HPA)的两层地址转换. 前一个转换由客户机OS完成, 后一个转换由VMM负责.

为实现从客户机物理地址GPA到宿主机物理地址HPA的地址翻译, VMM为**每个虚拟机**动态地维护了一张从**客户机物理地址**到**宿主机物理地址**映射关系的**表**.

有了这张表之后, VMM截获**任何试图修改客户机页表**或**刷新TLB的指令**, 根据这张表, 将修改从客户机虚拟地址到客户机物理地址映射的操作, 变成修改客户机虚拟地址到相应的宿主机物理地址映射的操作.

自从有了这张表, 虽然宿主机物理地址只有一个零起始地址, 但在不同客户机物理地址空间里, 可以各有一个零起始地址, 而且客户机OS看来连续的客户机物理内存地址空间, 其对应的宿主机物理内存可能是不连续的, 而这增加了VMM为多个虚拟机分配宿主机物理内存时的灵活性, 提高了宿主机物理内存的利用率.

VMM还可以通过该表确保运行于同一宿主机上的不同客户机访问的是不同的物理内存, 即相同的客户机物理地址呗映射到了不同的宿主机物理地址上. 这样一来, 一个客户机只能访问VMM通过该表设置分配给它的宿主机物理地址上, 