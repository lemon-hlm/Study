
# 1 OS的时间概念

- 绝对时间(Wall Time): 又称墙上时间. 即OS启动后到目前为止的总运行时间, 它是一个单调递增的值

- 相对时间: 两个时间之间的间隔. 

硬件定时器如RTC、PIT或HPET等都能以某种频率触发时钟中断, 触发频率可以由软件编程控制. 通常, OS会将频率设定为一个给定的值(例如10ms), 从而可以知道两次时钟中断之间的时间差(本例中是10ms). 同时, 硬件定时器也会提供计数器(Counter)的功能, OS可知两次读取计数器之间的时间差, 从而得到相对时间概念.

OS在启动时候读取CMOS的实时时钟, 或通过NPT协议, 得到系统启动时的绝对时间. 同时, 系统通过维护相对时间, 可知系统总运行的事件, 从而OS可得到任意时刻点的绝对时间, 如下公式:

当前绝对时间 = 系统启动时的时间 + 系统启动后运行的时间

图5\-222描述OS的时钟概念. 系统在时间t0时候启动, 当实际时间到达t1的时候, 系统内部维护的运行时间为t1 \- t0, 而系统内部的绝对时间为t0+(t1-t0), 从而保证了内存时间与实际时间的一致性. 每次时钟中断发生时(t1、t2、t3等), OS都会更新内部的时间概念. 而在t1 \~ t2时间内, OS可通过读时间设备的计数器得到相对时间.

![config](./images/34.png)

# 2 客户机的时间概念

在**硬件辅助的虚拟环境**下, 客户机OS仍然需要维护正确地时间概念, 包括**相对时间**和**绝对时间**. 这意味着**VMM**需要为客户机提供**系统硬件时钟设备的仿真**, 包括**PIT**、**HPET**和**TSC**等. 

虚拟环境下, 不同客户机和VMM共享物理平台, 客户机只能得到部分处理器时间.

图5-23和图5\-24给定不同的客户机时间概念的实现. 假定客户机在t1时刻处于运行状态, t2的时候被调度进入睡眠状态, t3时候重新被调度执行, 直到t5时候被再次调度出去. 如果客户机内的某一个程序(操作系统内核或应用程序)希望得到t4和t1之间的相对时间, 那么返回值应该是多少?

显然, 不同情况, 返回值应该是不相同的, 考虑下面两种应用.

⓵ 进程记账: 主要用于统计某一个进程的执行时间. 就不能包含被调度出去的时间.

⓶ 网络速度检测程序: 网络速度检测程序通过计算发送数据包和收到应答包的时间. 

# 3 时钟设备仿真

x86系统中时间设备包括PIT、HPET、ACPI PM Timer和TSC等。先介绍客户机不会被调度出去的情况, PIT设备如何虚拟化. 下节介绍客户机被调度出去的情况.

PIT主要功能是为OS提供定时的时钟中断和时钟计数器. OS对PIT设备的I/O端口读写, 设定时钟中断的触发频率, 设置和读取时钟计数器.

为实现时间设备的虚拟化, VMM必须提供软件定时器机制, 使得程序可以在设定的某个未来时间执行一段代码, 同时还提供接口, 使得程序可以了解当前的实际时间.

假定客户机OS设定PIT时钟中断频率为10ms, VMM截获这个设定(截获方法参考I/O虚拟化), 并通知PIT设备模型. PIT设备模型会向VMM注册一个间隔为10ms的软件定时器, 并提供回调函数, 这个函数功能就是向客户机注入一个时钟中断. 具体中断注入参考中断虚拟化相关章节.

当客户机读取PIT的Counter寄存器时, PIT设备模型通过VMM了解当前的实际时间, 并减去PIT的事件计数器被初始化时的实际时间, 以得到流逝时间, 经过PIT频率转换后返回给客户机.

HPET和ACPI PM Timer, 基本方法相同, 不同点在于, 客户机读取PIT通过IO实现, 而这两个是MMIO截获实现. 同时, 各个时间设备的中断号不同.

由于OS可依赖多个时钟设备实现内部时间的维护, 因此, 当VMM提供多个时钟设备的仿真时, 需要保证各个设备模型之间的时间一致性.

# 4 实现客户机时间概念的一种方法



