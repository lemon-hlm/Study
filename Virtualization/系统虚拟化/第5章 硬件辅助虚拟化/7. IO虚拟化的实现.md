
# 1 概述

将VT\-d技术运用到VMM的I/O虚拟化中

# 2 设备直接分配

在"设备模拟"和"类虚拟化"两种I/O虚拟化技术中, 所有客户机都共享平台硬件设备. 考虑一种情况, 当VMM运行在一台有10块网卡的服务器上, 前两种技术完全可能只使用一块网卡来满足所有客户机的网络I/O需求, 这必然导致低性能和资源的浪费. 设备直接分配技术很好解决. 可以把某个设备直接分配给一个客户机, 让客户机的I/O访问直接访问到设备的I/O地址空间, 从宏观看, 这个客户机直接操作了平台的硬件设备.

在第2章中, I/O只有三个方面.

⓵ 驱动程序通过I/O地址空间操作设备, 即设备直接分配技术解决的问题.

⓶ 设备通过DMA读取/复制数据, 已经由VT\-d的DMA重映射技术解决.

⓷ 中断, 2.4已经介绍过

设备直接分配的一个问题是**如何阻止**来自**未分配到该设备的客户机的I/O访问！！！**. 例如, 系统中有三个客户机(0、1、2), 其中客户机1分配到网卡A, 则要阻止客户机0、2对网卡A的访问, 一个最直接的方法是隐藏, 让客户机0和客户机2认为网卡A根本就不存在. 实际上, 无论是"设备模拟"还是"类虚拟化"技术, 平台的硬件对于客户机都是透明的, 所谓隐藏主要是针对运行"设备模拟器"的客户机/宿主机, 或拥有"类虚拟化"后端驱动的客户机/宿主机而言的. 隐藏的方式视具体的情况而定, 例如可以在拥有硬件设备的客户机/宿主机加载驱动程序前, 先给要分配出去的设备加载一个伪驱动作为占位符. 由于没有真正的驱动程序, 该设备就不会被访问到.

# 3 设备I/O地址空间的访问

设备直接分配的另一个问题是如何让**客户机的I/O操作直接访问到设备真实的I/O地址空间**

第2章说过, **PCI设备**的**I/O地址空间**通过**PCI BAR(Base Address Register)报告给OS！！！**. 为此, 有**两种选择**供**设备直接分配技术**使用.

⓵ 将**设备的真实PCI BAR报告给客户机**, 并通过**VMCS的I/O bitmap**和**EPT**使**客户机的端口I/O**和**MMIO**都**不引起VM\-Exit！！！**, 则**客户机OS**的**驱动**可以**直接访问设备的I/O地址空间**

⓶ 建立**转换表**, 报告**虚拟的PCI BAR给客户机**, 当客户机访问到**虚拟的I/O地址空间**时, VMM负责**截获**操作, 并通过**转换表将I/O请求转发到设备的I/O地址空间**.

两种方法中， **方法⓵**是高效的(不引起VM\-Exit)和简单的(直接报告真实的PCI BAR给客户机), 实际运用会**存在一些问题**. 通常, VMM产品会使用多种I/O虚拟化技术, 客户机的I/O请求, 可能一部分由"设备模拟"技术满足, 一部分由设备直接分配技术满足. 例如, 一个客户机, 它的显卡是由"设备模拟器"模拟的, 但网卡又是操作的真实设备. 在2.6提到, 设备的PCI BAR通常是BIOS配置并由OS直接使用. 在上述情况中, 由"设备模拟器"提供的设备的PCI BAR由虚拟BIOS配置, 而真实设备的PCI BAR由平台的BIOS配置, 两者之间就可能冲突. 这种情况下, 在操作系统看来就是资源冲突, 很可能停用其中一个设备. 另外, OS有权利修改设备的PCI BAR, 但应该阻止客户机直接修改真实设备的PCI BAR, 这是为防止真是设备之间的PCI BAR冲突, 以及在客户机销毁时把设备分配给其它客户机使用. 所以, 在实现设备直接分配技术中, 通常采用方法⓶, 即建立转换表. 根据I/O地址空间的划分, 转换表分为Port I/O转换表和MMIO转换表.

对于Port I/O, 在VMCS时提过, 可通过I/O bitmap来控制客户机访问某个端口是否引起VM\-Exit. 这样, 完全可以使用"设备模拟器"的虚拟BIOS(或其他手段, 取决于VMM使用的I/O虚拟技术)为分配给客户机的真实设备生成虚拟的PCI BAR, 将它报告给客户OS, 并修改I/O bitmap使客户机在访问这些I/O端口时产生VM\-Exit. 

