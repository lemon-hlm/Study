
# 1 概述

将VT\-d技术运用到VMM的I/O虚拟化中

# 2 设备直接分配

在"设备模拟"和"类虚拟化"两种I/O虚拟化技术中, 所有客户机都共享平台硬件设备. 考虑一种情况, 当VMM运行在一台有10块网卡的服务器上, 前两种技术完全可能只使用一块网卡来满足所有客户机的网络I/O需求, 这必然导致低性能和资源的浪费. 设备直接分配技术很好解决. 可以把某个设备直接分配给一个客户机, 让客户机的I/O访问直接访问到设备的I/O地址空间, 从宏观看, 这个客户机直接操作了平台的硬件设备.

在第2章中, I/O只有三个方面.

⓵ 驱动程序通过I/O地址空间操作设备, 即设备直接分配技术解决的问题.

⓶ 设备通过DMA读取/复制数据, 已经由VT\-d的DMA重映射技术解决.

⓷ 中断, 2.4已经介绍过

设备直接分配的一个问题是**如何阻止**来自**未分配到该设备的客户机的I/O访问！！！**. 例如, 系统中有三个客户机(0、1、2), 其中客户机1分配到网卡A, 则要阻止客户机0、2对网卡A的访问, 一个最直接的方法是隐藏, 让客户机0和客户机2认为网卡A根本就不存在. 实际上, 无论是"设备模拟"还是"类虚拟化"技术, 平台的硬件对于客户机都是透明的, 所谓隐藏主要是针对运行"设备模拟器"的客户机/宿主机, 或拥有"类虚拟化"后端驱动的客户机/宿主机而言的. 隐藏的方式视具体的情况而定, 例如可以在拥有硬件设备的客户机/宿主机加载驱动程序前, 先给要分配出去的设备加载一个伪驱动作为占位符. 由于没有真正的驱动程序, 该设备就不会被访问到.

# 3 设备I/O地址空间的访问

设备直接分配的另一个问题是如何让**客户机的I/O操作直接访问到设备真实的I/O地址空间**

第2章说过, **PCI设备**的**I/O地址空间**通过**PCI BAR(Base Address Register)报告给OS！！！**. 为此, 有**两种选择**供**设备直接分配技术**使用.

⓵ 将**设备的真实PCI BAR报告给客户机**, 并通过**VMCS的I/O bitmap**和**EPT**使**客户机的端口I/O**和**MMIO**都**不引起VM\-Exit！！！**, 则**客户机OS**的**驱动**可以**直接访问设备的I/O地址空间**

⓶ 建立**转换表**, 报告**虚拟的PCI BAR给客户机**, 当客户机访问到**虚拟的I/O地址空间**时, VMM负责**截获**操作, 并通过**转换表将I/O请求转发到设备的I/O地址空间**.

两种方法中， **方法⓵**是高效的(不引起VM\-Exit)和简单的(**直接报告真实的PCI BAR给客户机**), 实际运用会**存在一些问题**. 通常, **VMM**产品会使用**多种I/O虚拟化技术**, **客户机**的**I/O请求**, 可能一部分由"**设备模拟**"技术满足, 一部分由**设备直接分配技术**满足. 例如, **一个客户机**, 它的**显卡**是由"**设备模拟器**"模拟的, 但**网卡**又是操作的**真实设备**. 在2.6提到, **设备的PCI BAR**通常是**BIOS配置**并由**OS直接使用**. 在上述情况中, 由"**设备模拟器！！！**"提供的**设备的PCI BAR！！！**由**虚拟BIOS配置！！！**, 而**真实设备！！！**的**PCI BAR**由**平台的BIOS！！！**配置, 两者之间就**可能冲突！！！**. 这种情况下, 在操作系统看来就是**资源冲突**, 很可能**停用其中一个设备**. 另外, **OS！！！**有权利**修改设备的PCI BAR**, 但应该**阻止客户机直接修改真实设备的PCI BAR**, 这是为**防止真实设备之间的PCI BAR冲突！！！**, 以及在客户机销毁时把设备分配给其它客户机使用. 所以, 在实现**设备直接分配技术**中, 通常采用**方法⓶！！！**, 即**建立转换表**. 根据**I/O地址空间**的划分, 转换表分为**Port I/O转换表！！！**和**MMIO转换表！！！**.

对于Port I/O, 在VMCS时提过, 可通过I/O bitmap来控制客户机访问某个端口是否引起VM\-Exit. 这样, 完全可以使用"设备模拟器"的虚拟BIOS(或其他手段, 取决于VMM使用的I/O虚拟技术)为分配给客户机的真实设备生成虚拟的PCI BAR, 将它报告给客户OS, 并修改I/O bitmap使客户机在访问这些I/O端口时产生VM\-Exit. 同时, VMM维护了一张虚拟PCI BAR到真实PCI BAR的映射表. 当客户机通过虚拟的PCI BAR发起I/O操作时, 会因为VM\-Exit陷入到VMM中, VMM即可通过转换表获得真实设备的I/O端口, 帮客户及将请求转发到真实硬件.

对于MMIO, 其访问方式和内存访问一样. 完全可以使用**内存虚拟化技术**来解决这个问题. 在虚拟BIOS产生虚拟PCI BAR之后, 只需将虚拟的MMIO地址空间映射到设备真实的MMIO地址空间上, 当客户机通过虚拟的MMIO地址空间访问设备时, 内存虚拟化机制处理一切. 举例, 如果当前VMM使用EPT, 则客户机在第一次访问虚拟MMIO地址空间时会陷入到VMM. 此时, 可修改EPT页表建立起虚拟MMIO地址空间到设备真实MMIO地址空间的映射, 则在以后访问中, 客户机对该虚拟MMIO地址空间的访问就不会陷入到VMM.

除了解决客户机直接访问设备I/O地址空间问题, 转换表还可以满足客户机修改设备PCI BAR的情况. 此时, 只需要修改虚拟的PCI BAR并维护修改后的值到真实PCI BAR的映射即可. 如何截获修改PCI BAR的操作. 请参照2.6提到的两个I/O端口0xCF8\~0xCFF. 只需要截获客户机对这个两个端口的操作即可.

# 4 设备发现



