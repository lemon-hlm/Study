
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 概述](#1-概述)
* [2 设备直接分配](#2-设备直接分配)
* [3 设备I/O地址空间的访问](#3-设备io地址空间的访问)
* [4 设备发现](#4-设备发现)
* [5 配置DMA重映射数据结构](#5-配置dma重映射数据结构)
* [6 设备中断虚拟化](#6-设备中断虚拟化)
* [7 案例分析: 网卡的直接分配在Xen中的实现](#7-案例分析-网卡的直接分配在xen中的实现)
* [8 进阶](#8-进阶)

<!-- /code_chunk_output -->

# 1 概述

将VT\-d技术运用到VMM的I/O虚拟化中

在"**设备模拟**"和"**类虚拟化**"**两种I/O虚拟化技术**中, **所有客户机**都**共享平台硬件设备**. 考虑一种情况, 当**VMM**运行在一台有**10块网卡**的服务器上, 前两种技术完全可能**只使用一块网卡！！！**来满足**所有客户机的网络I/O需求！！！**, 这必然导致**低性能！！！**和**资源的浪费！！！**. 

第2章提到, **I/O只有三个方面内容！！！**.

⓵ **驱动程序！！！**通过**I/O地址空间(PIO或MMIO)操作设备！！！**, 即 **设备直接分配技术！！！** 解决的问题.

⓶ **设备！！！** 通过 **DMA读取/复制数据！！！**, 已经由 **VT\-d的DMA重映射技术！！！** 解决.

⓷ **中断**, 5.4已经介绍过

**设备直接分配**技术很好解决. 可以把**某个设备直接分配给一个客户机**, 让**客户机的I/O访问直接访问到设备的I/O地址空间！！！**, 从宏观看, 这个客户机直接操作了平台的硬件设备.

# 2 设备直接分配

设备直接分配的一个问题是**如何阻止**来自**未分配到该设备的客户机的I/O访问！！！**. 

例如, 系统中有三个客户机(0、1、2), 其中客户机1分配到网卡A, 则要阻止客户机0、2对网卡A的访问, 一个最直接的方法是**隐藏**, 让客户机0和客户机2认为网卡A根本就不存在. 实际上, 无论是"设备模拟"还是"类虚拟化"技术, 平台的硬件对于客户机都是透明的, 所谓隐藏主要是针对运行"设备模拟器"的客户机/宿主机, 或拥有"类虚拟化"后端驱动的客户机/宿主机而言的. 隐藏的方式视具体的情况而定, 例如可以在拥有硬件设备的客户机/宿主机加载驱动程序前, 先给要分配出去的设备加载一个**伪驱动作为占位符**. 由于没有真正的驱动程序, 该设备就不会被访问到.

# 3 设备I/O地址空间的访问

设备直接分配的**另一个问题**是如何让**客户机的I/O操作直接访问到设备真实的I/O地址空间**

第2章说过, **PCI设备**的**I/O地址空间**通过**PCI BAR(Base Address Register)报告给OS！！！**. 为此, 有**两种选择**供**设备直接分配技术**使用.

⓵ 将**设备的真实PCI BAR报告给客户机**, 并通过**VMCS的I/O bitmap**和**EPT**使**客户机的端口I/O**和**MMIO**都**不引起VM\-Exit！！！**, 则**客户机OS**的**驱动**可以**直接访问设备的I/O地址空间**

⓶ 建立**转换表**, 报告**虚拟的PCI BAR给客户机**, 当客户机访问到**虚拟的I/O地址空间**时, VMM负责**截获**操作, 并通过**转换表将I/O请求转发到设备的I/O地址空间**.

两种方法中， **方法⓵**是高效的(不引起VM\-Exit)和简单的(**直接报告真实的PCI BAR给客户机**), 实际运用会**存在一些问题**. 通常, **VMM**产品会使用**多种I/O虚拟化技术**, **客户机**的**I/O请求**, 可能一部分由"**设备模拟**"技术满足, 一部分由**设备直接分配技术**满足. 例如, **一个客户机**, 它的**显卡**是由"**设备模拟器**"模拟的, 但**网卡**又是操作的**真实设备**. 在2.6提到, **设备的PCI BAR**通常是**BIOS配置**并由**OS直接使用**. 在上述情况中, 

- 由"**设备模拟器！！！**"提供的**设备的PCI BAR！！！**由**虚拟BIOS配置！！！**, 
- 而**真实设备！！！**的**PCI BAR**由 **平台的BIOS！！！** 配置, 

两者之间就**可能冲突！！！**. 这种情况下, 在操作系统看来就是**资源冲突**, 很可能**停用其中一个设备**. 另外, **OS！！！**有权利**修改设备的PCI BAR**, 但应该**阻止客户机直接修改真实设备的PCI BAR**, 这是为**防止真实设备之间的PCI BAR冲突！！！**, 以及在客户机销毁时把设备分配给其它客户机使用. 

所以, 在实现**设备直接分配技术**中, 通常采用**方法⓶！！！**, 即**建立转换表**. 根据**I/O地址空间**的划分, 转换表分为**Port I/O转换表！！！**和**MMIO转换表！！！**.

对于**Port I/O**, 在**VMCS**时提过, 可通过**I/O bitmap！！！**来控制**客户机访问某个端口是否引起VM\-Exit！！！**. 这样, 完全可以使用"**设备模拟器**"的**虚拟BIOS！！！**(或**其他手段！！！**, 取决于VMM使用的**I/O虚拟技术**)为分配给客户机的**真实设备**生成**虚拟的PCI BAR(存放MMIO或PIO的地址！！!**), 将它报告**给客户OS**, 并**修改I/O bitmap！！！**使**客户机**在访问这些**I/O端口**时产生**VM\-Exit**. 同时, **VMM**维护了一张**虚拟PCI BAR到真实PCI BAR的映射表！！！**. 当**客户机**通过**虚拟的PCI BAR**发起**I/O操作**时, 会**因为VM\-Exit！！！陷入到VMM**中, **VMM**即可通过**转换表**获得**真实设备的I/O端口**, 帮客户及将请求**转发到真实硬件**.

对于**MMIO**, 其**访问方式和内存访问一样**. 完全可以使用**内存虚拟化技术**来解决这个问题. 在**虚拟BIOS**产生**虚拟PCI BAR**之后, 只需将**虚拟的MMIO地址空间**映射到设备**真实的MMIO地址空间**上, 当**客户机**通过**虚拟的MMIO地址空间访问设备**时, 内存虚拟化机制处理一切. 举例, 如果当前VMM使用EPT, 则客户机在第一次访问虚拟MMIO地址空间时会陷入到VMM. 此时, 可修改EPT页表建立起虚拟MMIO地址空间到设备真实MMIO地址空间的映射, 则在以后访问中, **客户机**对**该虚拟MMIO地址空间的访问**就**不会陷入到VMM**.

除了解决**客户机直接访问设备I/O地址空间**问题, **转换表**还可以满足**客户机修改设备PCI BAR！！！**的情况. 此时, 只需要修改虚拟的PCI BAR并维护修改后的值到真实PCI BAR的映射即可. 如何截获**修改PCI BAR**的操作. 请参照2.6提到的两个I/O端口0xCF8\~0xCFF. 只需要**截获**客户机对**这个两个端口的操作**即可.

# 4 设备发现

前面解决客户机如何访问真实设备问题, 如何让**客户机OS发现真正的设备**?

VMM通常会使用**多种I/O虚拟化技术！！！**, 其中一项**必然**会**虚拟PCI总线**(一般, 这是"**设备模拟器**"的工作), 所以**只需**将**真实设备**"挂接"到这条**虚拟的PCI总线**上, **客户OS枚举PCI设备**时**必然会发现分配它**. 第2张关于PCI设备介绍可知, **PCI设备暴露给OS的接口**是**PCI配置空间**, 一个自然想法就是将**真实设备的PCI配置空间暴露给客户OS**. 前面提到, **PCI配置空间的PCI BAR**通常是**虚拟BIOS生成**的. 那么更进一步, 可以**为设备生成整个虚拟的PCI配置空间！！！**.

为让**客户OS正确识别**分配给它的设备, 这个**虚拟的PCI配置空间**中, 表示**设备标识**的**前16个字节**(见2.6)需要使用**真实的信息**, 这是没关系的. 这些信息**不会被客户OS修改**, 也**不会冲突**. 将**生成的PCI配置空间**以一个**虚拟设备的形式**挂接在**虚拟PCI总线**上, 当**客户OS枚举总线时**即可发现该设备并加载正确地驱动程序.

# 5 配置DMA重映射数据结构

VT\-d对DMA重映射进行地址转换. 对于**VMM的实现者**, 使用该技术**关键**在于**为所分配的设备正确设置根条目和上下文条目**, 以及**建立I/O页表**. **每个客户机**有**一张I/O页表**, 通常在**客户机创建初期**根据**客户机内存大小**、**VT\-d硬件支持的页表级数**、**页大小**创建. 

假设**Guest ID为1**, **I/O页表！！！**已经**创建好位于地址A！！！**, **根条目表**和**上下文条目表**已经在**VMM加载初期创建好！！！**, 要分配设备的BDF是{00:03:00}.

⓵ 找到**设备**对应的**DHRD结构**.

⓶ 获得该结构的**根条目表**, 通过**BDF的bus字段**获得该设备对应**根条目项**(以下称Root Entry0)

⓷ 通过**Root Entry0**的**CTP字段**获得**上下文条目表**, 用**BDF**的**dev:func**字段**索引该表**, 获得**设备对应的上下文条目**. 如果该上下文条目**不存在**, **分配一个**并**将地址写入Root Entry0的CTP字段**.

⓸ 将**I/O页表的地址A**填入**上下文条目**的**ASR字段**, 在**DID字段**写入**Guest ID 1**, 在p字段写入1.

⓹ **刷新上下文条目的缓存**.

上面只介绍了主要字段的配置, 其余字段也要根据格式正确配置. 在刷新操作后, 该设备的DMA请求就会被DMA重映射硬件截获并进行地址转换.

# 6 设备中断虚拟化

DMA最后一步往往是设备用中断报告驱动程序操作完成. 在设备直接分配给客户机, 以及DMA重映射到客户机内存情况下, 设备的中断也需要注入给客户机. 5.4已经介绍过.

# 7 案例分析: 网卡的直接分配在Xen中的实现

以Xen3.2为例, 其它VMM原理类似

首先, VMM需要知道要直接分配的设备的标识, 这里通常使用PCI设备的BDF号标识设备. 设备标识由用户指定. 假设网卡的BDF是03:00.1

下一步, 隐藏设备. 方法很多, Xen方法是在GRUB启动选项中指定设备的BDF, 然后在启动过程中不去使用这些设备. 网卡为例, 用户可增加Domain 0的启动选项pciback.hide=(03:00.0), 这样, Domain就不会为网卡(03:00.0)加载驱动, 该网卡在系统启动之后就处在未使用状态.

设备被隐藏后可直接分配给虚拟机. 同样, 用户在客户机配置文件中指定该设备的BDF号. Xen里面, 用户可以在HVM的配置文件中增加pci=['03:00.0'].

Xen获得直接分配请求后, 首先将设备呈献给客户机, 通过在设备模型中虚拟一个PCI网卡来实现. 客户机OS对该虚拟PCI网卡的操作请求都会被转交给物理网卡, 物理网卡处理完后的结果通过该虚拟PCI网卡返回给客户机OS.

Xen负责虚拟PCI网卡和物理网卡之间的交互. 具体来说, Xen主要需要做: 

首先, 由于虚拟PCI网卡的BDF和物理网卡的BDF不一定相同, 因此Xen负责两者转换.

其次, 虚拟PCI网卡的I/O空间(MMIO和Port I/O)和物理网卡不一定相同, 因此Xen为两者建立映射.

再次, 虚拟网卡的中断和物理网卡也是一样的, 因此Xen负责进行中断的转发. 

最后, Xen需要为物理网卡设置VT\-d页表, 确保客户机操作系统发出DMA请求时, 硬件能正确处理DMA地址.

# 8 进阶

客户机被销毁, 它所拥有的真实硬件应该能够被重新利用, 分配给其它客户机使用, 这要求设备能够进行再分配. 

只需要重新为设备生成新的PCI配置空间, 建立映射, 并挂接到新客户机的虚拟PCI总线上, 并修改设备对应的上下文条目, 就可以将设备分配给新的客户机使用了. 