
# 1 概述

将VT\-d技术运用到VMM的I/O虚拟化中

# 2 设备直接分配

在"**设备模拟**"和"**类虚拟化**"**两种I/O虚拟化技术**中, **所有客户机**都**共享平台硬件设备**. 考虑一种情况, 当**VMM**运行在一台有**10块网卡**的服务器上, 前两种技术完全可能**只使用一块网卡！！！**来满足**所有客户机的网络I/O需求！！！**, 这必然导致**低性能！！！**和**资源的浪费！！！**. **设备直接分配**技术很好解决. 可以把**某个设备直接分配给一个客户机**, 让**客户机的I/O访问直接访问到设备的I/O地址空间！！！**, 从宏观看, 这个客户机直接操作了平台的硬件设备.

第2章提到, **I/O只有三个方面内容！！！**.

⓵ **驱动程序！！！**通过**I/O地址空间操作设备！！！**, 即**设备直接分配技术！！！**解决的问题.

⓶ **设备！！！**通过**DMA读取/复制数据！！！**, 已经由**VT\-d的DMA重映射技术！！！**解决.

⓷ **中断**, 2.4已经介绍过

设备直接分配的一个问题是**如何阻止**来自**未分配到该设备的客户机的I/O访问！！！**. 例如, 系统中有三个客户机(0、1、2), 其中客户机1分配到网卡A, 则要阻止客户机0、2对网卡A的访问, 一个最直接的方法是隐藏, 让客户机0和客户机2认为网卡A根本就不存在. 实际上, 无论是"设备模拟"还是"类虚拟化"技术, 平台的硬件对于客户机都是透明的, 所谓隐藏主要是针对运行"设备模拟器"的客户机/宿主机, 或拥有"类虚拟化"后端驱动的客户机/宿主机而言的. 隐藏的方式视具体的情况而定, 例如可以在拥有硬件设备的客户机/宿主机加载驱动程序前, 先给要分配出去的设备加载一个伪驱动作为占位符. 由于没有真正的驱动程序, 该设备就不会被访问到.

# 3 设备I/O地址空间的访问

设备直接分配的另一个问题是如何让**客户机的I/O操作直接访问到设备真实的I/O地址空间**

第2章说过, **PCI设备**的**I/O地址空间**通过**PCI BAR(Base Address Register)报告给OS！！！**. 为此, 有**两种选择**供**设备直接分配技术**使用.

⓵ 将**设备的真实PCI BAR报告给客户机**, 并通过**VMCS的I/O bitmap**和**EPT**使**客户机的端口I/O**和**MMIO**都**不引起VM\-Exit！！！**, 则**客户机OS**的**驱动**可以**直接访问设备的I/O地址空间**

⓶ 建立**转换表**, 报告**虚拟的PCI BAR给客户机**, 当客户机访问到**虚拟的I/O地址空间**时, VMM负责**截获**操作, 并通过**转换表将I/O请求转发到设备的I/O地址空间**.

两种方法中， **方法⓵**是高效的(不引起VM\-Exit)和简单的(**直接报告真实的PCI BAR给客户机**), 实际运用会**存在一些问题**. 通常, **VMM**产品会使用**多种I/O虚拟化技术**, **客户机**的**I/O请求**, 可能一部分由"**设备模拟**"技术满足, 一部分由**设备直接分配技术**满足. 例如, **一个客户机**, 它的**显卡**是由"**设备模拟器**"模拟的, 但**网卡**又是操作的**真实设备**. 在2.6提到, **设备的PCI BAR**通常是**BIOS配置**并由**OS直接使用**. 在上述情况中, 由"**设备模拟器！！！**"提供的**设备的PCI BAR！！！**由**虚拟BIOS配置！！！**, 而**真实设备！！！**的**PCI BAR**由**平台的BIOS！！！**配置, 两者之间就**可能冲突！！！**. 这种情况下, 在操作系统看来就是**资源冲突**, 很可能**停用其中一个设备**. 另外, **OS！！！**有权利**修改设备的PCI BAR**, 但应该**阻止客户机直接修改真实设备的PCI BAR**, 这是为**防止真实设备之间的PCI BAR冲突！！！**, 以及在客户机销毁时把设备分配给其它客户机使用. 所以, 在实现**设备直接分配技术**中, 通常采用**方法⓶！！！**, 即**建立转换表**. 根据**I/O地址空间**的划分, 转换表分为**Port I/O转换表！！！**和**MMIO转换表！！！**.

对于**Port I/O**, 在**VMCS**时提过, 可通过**I/O bitmap！！！**来控制**客户机访问某个端口是否引起VM\-Exit！！！**. 这样, 完全可以使用"**设备模拟器**"的**虚拟BIOS！！！**(或**其他手段！！！**, 取决于VMM使用的**I/O虚拟技术**)为分配给客户机的**真实设备**生成**虚拟的PCI BAR(存放MMIO或PIO的地址！！!**), 将它报告**给客户OS**, 并**修改I/O bitmap！！！**使**客户机**在访问这些**I/O端口**时产生**VM\-Exit**. 同时, **VMM**维护了一张**虚拟PCI BAR到真实PCI BAR的映射表！！！**. 当**客户机**通过**虚拟的PCI BAR**发起**I/O操作**时, 会**因为VM\-Exit！！！陷入到VMM**中, **VMM**即可通过**转换表**获得**真实设备的I/O端口**, 帮客户及将请求**转发到真实硬件**.

对于**MMIO**, 其**访问方式和内存访问一样**. 完全可以使用**内存虚拟化技术**来解决这个问题. 在**虚拟BIOS**产生**虚拟PCI BAR**之后, 只需将**虚拟的MMIO地址空间**映射到设备**真实的MMIO地址空间**上, 当**客户机**通过**虚拟的MMIO地址空间访问设备**时, 内存虚拟化机制处理一切. 举例, 如果当前VMM使用EPT, 则客户机在第一次访问虚拟MMIO地址空间时会陷入到VMM. 此时, 可修改EPT页表建立起虚拟MMIO地址空间到设备真实MMIO地址空间的映射, 则在以后访问中, **客户机**对**该虚拟MMIO地址空间的访问**就**不会陷入到VMM**.

除了解决**客户机直接访问设备I/O地址空间**问题, **转换表**还可以满足**客户机修改设备PCI BAR！！！**的情况. 此时, 只需要修改虚拟的PCI BAR并维护修改后的值到真实PCI BAR的映射即可. 如何截获**修改PCI BAR**的操作. 请参照2.6提到的两个I/O端口0xCF8\~0xCFF. 只需要**截获**客户机对**这个两个端口的操作**即可.

# 4 设备发现

前面解决客户机如何访问真实设备问题, 如何让**客户机OS发现真正的设备**?

VMM通常会使用**多种I/O虚拟化技术！！！**, 其中一项**必然**会**虚拟PCI总线**(一般, 这是"**设备模拟器**"的工作), 所以**只需**将**真实设备**"挂接"到这条**虚拟的PCI总线**上, **客户OS枚举PCI设备**时**必然会发现分配它**. 第2张关于PCI设备介绍可知, **PCI设备暴露给OS的接口**是**PCI配置空间**, 一个自然想法就是将**真实设备的PCI配置空间暴露给客户OS**. 前面提到, **PCI配置空间的PCI BAR**通常是**虚拟BIOS生成**的. 那么更进一步, 可以**为设备生成整个虚拟的PCI配置空间！！！**.

为让**客户OS正确识别**分配给它的设备, 这个**虚拟的PCI配置空间**中, 表示**设备标识**的**前16个字节**(见2.6)需要使用**真实的信息**, 这是没关系的. 这些信息**不会被客户OS修改**, 也**不会冲突**. 将**生成的PCI配置空间**以一个**虚拟设备的形式**挂接在**虚拟PCI总线**上, 当**客户OS枚举总线时**即可发现该设备并加载正确地驱动程序.

# 5 配置DMA重映射数据结构

VT\-d对DMA重映射进行地址转换. 对于VMM的实现者, 使用该技术关键在于为所分配的设备正确设置根条目和上下文条目, 以及建立I/O页表. 每个客户机有一张I/O页表, 通常在客户机创建初期根据客户机内存大小、VT\-d硬件支持的页表级数、页大小创建. 

假设Guest ID为1, I/O页表已经创建好位于地址A, 根条目表和上下文条目表已经在VMM加载初期创建好, 要分配设备的BDF是{00:03:00}.

⓵ 找到设备对应的DHRD结构.

⓶ 获得该结构的根条目表, 通过BDF的bus字段获得该设备对应根条目项(以下称Root Entry0)

⓷ 通过Root Entry0的CTP字段获得上下文条目表, 用BDF的dev:func字段索引该表, 获得设备对应的上下文条目. 如果该上下文条目不存在, 分配一个并将地址写入Root Entry0的CTP字段.

⓸ 将I/O页表的地址A填入上下文条目的ASR字段, 在DID字段写入Guest ID 1, 在p字段写入1.

⓹ 刷新上下文条目的缓存.

上面只介绍了主要字段的配置, 其余字段也要根据格式正确配置. 在刷新操作后, 该设备的DMA请求就会被DMA重映射硬件截获并进行地址转换.

# 6 设备中断虚拟化

