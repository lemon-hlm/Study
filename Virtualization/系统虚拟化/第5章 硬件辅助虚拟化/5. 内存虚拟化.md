# 1 概述

内存虚拟化的主要任务是实现地址空间的虚拟化, **内存虚拟化**通过**两次地址转换**来支持地址空间的虚拟机, 即**客户机虚拟地址GVA**→**客户机物理地址GPA**→**宿主机物理地址HPA**的转换. 

其中, **GVA→GPA**的转换是由**客户机软件决定**, 通常是**客户机OS**通过V**MCS中客户机状态域CR3**指向的**页表**来指定; **GPA→HPA**的转换是由**VMM决定**, VMM在将**物理内存分配给客户机时**就确定了GPA→HPA的转换, VMM通常会用内部数据结构来记录这个关系.

传统的IA32架构只支持一次地址转换, 即通过**CR3指定的页表**实现"**虚拟地址**"→"**物理地址**"的转换. 这和**内存虚拟化**所要求的**两次地址转换**产生矛盾. 可通过将**两次转换合并成一次转换**解决, 即VMM根据**GVA→GPA→HPA的映射关系**, 计算出**GVA→HPA的映射关系**, 并将其写入"**影子页表**". 这样的软件方法尽管可以, 但缺点也很明显. 首先是**实现非常复杂**, 例如要考虑**各种页表同步情况！！！**等, 这样导致开发、调试和维护比较困难. 可参考Xen/KVM中影子页表的实现. 另外, **开销也很大**, 因为要为**每个客户机进程对应的页表！！！**都要维护一个"影子页表".

为解决这个问题, VT\-x提供了**Extend Page Table(EPT**)技术, 直接在**硬件支持GVA→GPA→HPA的两次地址转换**, 降低内存虚拟化的难度, 提高内存虚拟化性能.

此外, 为进一步**提高TLB的使用效率**, VT\-x还引入了**Virtual Processor ID(VPID**)功能, 进一步增强内存虚拟化性能.

# 2 EPT

## 2.1 EPT原理

图5\-13描述了EPT基本原理. 在原有CR3页表地址映射基础上, EPT还引入了EPT页表来实现另一次映射. 这样, **GVA→GPA→HPA两次地址转换！！！**都由**CPU硬件自动完成！！！**.

![config](./images/20.png)

这里假设**客户机页表！！！**和**EPT页表！！！**都是**4级页表**, CPU完成一次地址转换的基本过程如下.

**CPU**首先查找**Guest CR3**指向的**L4页表**. 由于**Guest CR3**给的是**GPA(！！！客户机物理地址, 不是客户机逻辑地址, 也不是宿主机物理地址！！！**), 因此CPU需要通过**EPT页表！！！**来实现**Guest CR3 GPA→HPA的转换！！！**. CPU首先会查看**硬件的EPT TLB(因为CR3是GPA！！！所以查找的是EPT的TLB！！！**), 如果**没有对应的转换**, CPU会**进一步查找EPT页表**, 如果还没有, CPU则**抛出EPT Violation异常**由**VMM**来处理.

获取**L4页表地址(！！！HPA！！！**)后, CPU根据**GVA**和**L4页表项内容**, 获取**L3页表项的GPA！！！**. 如果L4页表中GVA对应的表项显示为"缺页", 那么CPU产生**Page Fault**, 直接交给**Guest Kernel！！！**处理. 注意, 这里**不会产生VM\-Exi！！！**t. 获得**L3页表项的GPA**后, CPU同样要通过**查询EPT页表！！！来实现L3 GPA→HPA的转换**, 过程和上面一样.

同样, CPU依次查找L2、L1页表, 最后获得**GVA**对应的**GPA**, 然后通过**查询EPT页表获得HPA**. 上面可以看出, CPU需要**5次查询EPT页表(CR3<L4页表地址GPA>、L3页表地址、L2页表地址、L1页表地址和最终GPA查询EPT页表！！！**), **每次查询！！！**都需要**4次内存访问(！！！！！！**), 最坏共**20次内存访问**. EPT硬件通过增大EPT TLB来尽量减少内存访问.

注意: 上面的**EPT TLB**是用来将**客户机的GPA**转换成**宿主机的HPA**; 而在这之前, **客户机的GVA转成GPA是可以使用原始TLB？？？**

## 2.2 EPT的硬件支持

为了支持EPT, VT\-x规范在**VMCS**的"**VM\-Execution控制域**"中提供了**Enable EPT字段**. 如果在VM\-Entry的时候该位被置, CPU会使用EPT功能进行两次转换.

**EPT页表的基地址**是由**VMCS"VM\-Execution控制域**"的**Extended page table pointer字段**来执行的, 它包含了**EPT页表的宿主机物理地址HPA！！！**.

**EPT是一个多级页表**, 每级页表的**表项格式是相同**的, 如表5\-8

![config](./images/21.png)

EPT页表转换过程和**CR3页表转换是类似**的. 图5\-14展现了**CPU使用EPT页表进行地址转换**的过程.

![config](./images/22.png)

EPT通过**EPT页表**的**SP字段**支持大小为**2MB或1GB的超级页**. 图5\-15给出**2MB超级页**的地址转换过程. 和上图不同在于, 当CPU发现SP字段为1时, 就停止继续向下遍历页表, 而是直接转换了.

![config](./images/23.png)

EPT同样会使用TLB缓冲来加速页表的查找过程. 因此, VT\-x还提供了一条新指令INVEPT, 可使EPT的TLB项失效. 这样, 当EPT页表有更新时, CPU可以执行INVEPT使旧的TLB失效, 使CPU使用新的EPT表项.

和CR3页表会导致Page Fault一样, 使用EPT后, 如果CPU在遍历EPT页表进行GPA→HPA

