# 1 概述

内存虚拟化的主要任务是实现地址空间的虚拟化, **内存虚拟化**通过**两次地址转换**来支持地址空间的虚拟机, 即**客户机虚拟地址GVA**→**客户机物理地址GPA**→**宿主机物理地址HPA**的转换. 

其中, **GVA→GPA**的转换是由**客户机软件决定**, 通常是**客户机OS**通过V**MCS中客户机状态域CR3**指向的**页表**来指定; **GPA→HPA**的转换是由**VMM决定**, VMM在将**物理内存分配给客户机时**就确定了GPA→HPA的转换, VMM通常会用内部数据结构来记录这个关系.

传统的IA32架构只支持一次地址转换, 即通过**CR3指定的页表**实现"**虚拟地址**"→"**物理地址**"的转换. 这和**内存虚拟化**所要求的**两次地址转换**产生矛盾. 可通过将**两次转换合并成一次转换**解决, 即VMM根据**GVA→GPA→HPA的映射关系**, 计算出**GVA→HPA的映射关系**, 并将其写入"**影子页表**". 这样的软件方法尽管可以, 但缺点也很明显. 首先是**实现非常复杂**, 例如要考虑**各种页表同步情况！！！**等, 这样导致开发、调试和维护比较困难. 可参考Xen/KVM中影子页表的实现. 另外, **开销也很大**, 因为要为**每个客户机进程对应的页表！！！**都要维护一个"影子页表".

为解决这个问题, VT\-x提供了Extend Page Table(EPT)技术, 直接在硬件支持GVA→GPA→HPA的两次地址转换, 降低内存虚拟化的难度, 提高内存虚拟化性能.

此外, 为进一步提高TLB的使用效率, VT\-x还引入了Virtual Processor