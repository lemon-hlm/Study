# 1 概述

VT\-x基本思想如图5\-2.

首先, VT\-x引入了两种操作模式, 统称VMX操作模式.

- 根操作模式(VMX Root Operation): VMM运行所处的模式, 简称根模式.
- 非根操作模式(VMX Non\-Root Operation): 客户机运行所处的模式, 简称非根模式.

![config](./images/2.png)

这两种模式与IA32特权级0\~特权级3是正交的, 即每种操作模式都有相应的特权级0\~特权级3特权级. 故在VT\-x情况下, 描述程序运行在某个特权级, 必须指出当前处于根模式还是非根模式.

软件虚拟化中, 指令的虚拟化是通过"陷入再模拟"的方式实现, 而IA32架构有19条敏感指令不能通过这种方式处理, 导致虚拟化漏洞. 最直接方式就是使这些敏感指令能够触发异常. 可惜这种方式会改变这些指令的语义, 导致与原有软件不兼容. 引入新模式可以很好解决. 非根模式下所有敏感指令(包括19条不能被虚拟化的敏感指令)行为都被重新定义, 使得它们能不经虚拟化就直接运行或通过"陷入再模拟"方式来处理; 在根模式下, 所有指令的行为和传统IA32一样, 没有改变.

VT\-x中, **非根模式**下**敏感指令**引起的"**陷入**"被称为**VM\-Exit**. VM\-Exit发生时, **CPU自动！！！**从**非根模式**切换成**根模式**. 相应地, **VT\-x**也定义了**VM\-Entry**, 该操作由**VMM发起**, 通常是**调度某个客户机运行**, 此时**CPU**从**根模式**切换成**非根模式**.

其次, 为更好支持CPU虚拟化, VT\-x引入了**VMCS(Virtual\-Machine Control Structure, 虚拟机控制结构**). VMCS保存**虚拟CPU需要的相关状态**, 例如CPU在根模式和非根模式下的特权寄存器的值. **VMCS主要供CPU使用**, CPU在发生**VM\-Exit**和**VM\-Entry**时都会**自动查询和更新VMCS**. VMM可以**通过指令来配置VMCS！！！**, 进而**影响CPU的行为！！！**.

最后, VT\-x还引入了一组新的指令, 包括VMLAUCH/VMRESUME用于发起VM\-Entry, VMREAD/VMWRITE用于配置VMCS等.

# 2 VMCS

VMCS和软件的完全虚拟化中的虚拟寄存器概念类似, 可以看作是虚拟寄存器概念在硬件上的应用. 虚拟寄存器的操作和更改完全由软件执行, 但VMCS却主要由CPU操作. **VMCS**是保存在**内存中的数据结构**, 包含了**虚拟CPU的相关寄存器的内容**和**虚拟CPU相关的控制信息**, **每个VMCS**对应**一个虚拟CPU**.

**VMCS**在**使用时需要和物理CPU绑定！！！**. 在任意给定时刻, VMCS与物理CPU是一对一绑定的关系(！！！一对一的！！！). VMCS在不同的时刻可以绑定到不同的物理CPU, 例如在某个VMCS先和物理CPU1绑定, 并在某个时刻解除绑定关系, 并重新绑定到物理CPU2. 这种绑定关系的变化称为VMCS的"迁移(Migration)".

VT\-x提供了两条指令用于VMCS的绑定与解绑.

- VMPTRLD <VMCS地址>: 将指定的VMCS与执行该指令的物理CPU绑定.
- VMCLEAR: 将执行该指令的物理CPU与它的VMCS解绑. 该指令会将物理CPU缓存中的VMCS结构同步到内存中去, 从而保证VMCS和新的物理CPU绑定时, 内存中的值是最新的.

VMCS一次迁移过程如下.

⓵ 在CPU1上执行VMCLEAR, 解绑

⓶ 在CPU2上执行VMPTRLD, 新绑定.

VT\-x定义了VMCS的具体格式和内容. 规定它是一个最大不超过4KB的内存块, 并要求4KB对齐. 描述了VMCS的格式, 各域描述如下.

⓵ 偏移0是VMCS版本标识, 表示VMCS数据格式的版本号

⓶ 偏移4是VMX中止指示, VM\-Exit执行不成功时产生VMX中止, CPU会在此处存放VMX中止的原因, 以便调试

⓷ 偏移8处是VMCS数据域, 该域的格式是CPU相关的, 不同


