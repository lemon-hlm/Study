
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 概述](#0-概述)
* [1 容器技术的基本概念和发展背景](#1-容器技术的基本概念和发展背景)
	* [1.1 资源容器](#11-资源容器)

<!-- /code_chunk_output -->

# 0 概述

**OS领域**一直以来面临的一个主要挑战来自**应用间存在的相互独立性**和**资源互操作性**之间的矛盾, 即**每个应用程序**都希望能运行在一个**相对独立的系统环境**下, **不受其他程序的干扰**, 同时又能以方便快捷的方式**与其他程序交换和共享系统资源**.

虚拟化技术因其具有同时运行多个相对独立操作系统的能力而被用来克服上面挑战. VMware和Xen等虚拟化主流产品均采用Hypervisor模型. 该模型通过将应用程序运行在多个不同虚拟机内, 实现对上层应用程序的隔离. 但由于Hypervisor模型更倾向于每个虚拟机都拥有一套相对独立的系统资源, 提供相对完全的独立性支持, 这种策略造成处于不同虚拟机内的应用程序间实现相互操作非常困难. 例如, 同一台物理机的不同虚拟机, 应用程序之间仍然只能通过网络进行数据交换, 而非共享内存或文件.

Hypervisor模型这种强独立性保障策略在一定程度上牺牲系统的执行效率. 对于高性能计算、Web服务、数据库、游戏平台和分布式系统等很多应用领域, 提供高效的资源互操作性和保持程序间的独立性具有同等重要的意义. 针对这种需求, 学术界提出了一种基于资源与安全容器概念的虚拟化技术. 应用容器模型的虚拟机化产品Solaris 10和Linux\-Vsever, 能够满足基本的独立性需求的同时提供高效的系统资源共享支持. 

# 1 容器技术的基本概念和发展背景

容器技术主要涉及两个方面: 资源容器和安全容器. 

## 1.1 资源容器

当前比较流行的**高性能服务器程序**通常是**一个资源主体**对应**多个资源消费者**的模式, 如事件触发模式(Event\-Driven), 或者是**多个资源主体**对应**多个资源消费者**的模式, 如CGI程序. 这造成准确估算出**单个资源消费者**所使用的**资源量**变的很困难, 从而无法很好地进行**资源管理和控制**. 例如, 在**多线程服务器**上, **一个应用实例**对应**一个**可以执行多种独立行为的**进程**, 这个**进程**拥有所有属于它的**资源**. 但在使用**线程**完成**单个任务**时, 其所使用的**资源**往往只是这个**进程所属资源**的一个**子集**. 由于对**资源的控制粒度**只能细化到**进程级别**, 因此**不可能对单个线程**进行独立的**资源控制**. 而对需要**多线程协作**完成的任务进行**资源的统计和控制就更加难以实现**. 其它主要的限制来自于资源控制范围、线程调度策略和任务涉及线程差异等在内的多个方面. 例如, 系统很少对网络资源的使用进行控制, 必然造成对涉及网络使用的进程的资源统计数据的变差, 进而造成资源调度的不准确. 同样的, 线程调度中的中断抢占机制会导致计算线程运行时间的偏差, 也会引发类似问题.

学术界提出了延时处理机制(Lazy Receiver Processing), 将进程视为完成某个任务的核心. 将网络等资源的使用与进程联系起来, 从而提高了资源统计的精确度. 但该机制仍然无法彻底解决线程不是资源控制和统计单元(unit of resource)的问题.

