为了降低系统设计的复杂性，计算机系统被设计成**自上而下的抽象层次结构**，**每一个层次**都向**上一层次**呈现一个抽象，并且**每一层**只需知道**下层抽象的接口**，而**不需要了解其内部运作机制**。这样，**每一层**只需要考虑**本层的设计**以及**相邻层间的交互**。例如，**操作系统**所看到的**硬件**是一个**硬件抽象层**，而**不需要理解硬件的布线**或者**电气特性**等。

图 1-1 计算机系统的各个抽象层:

![config](./images/1.jpeg)

**硬件抽象层（Hardware Abstraction Layer, HAL**）是计算机中**软件**所能控制的**硬件的抽象接口**，通常包括**CPU的各种寄存器**、**内存管理模块**、**I/O端口**以及**内存映射的I/O地址**等。**API抽象层**是**一个进程**所能控制的**系统功能**的集合，包括创建新进程、内存申请、归还、进程间同步与共享、文件系统和网络操作系统等。

本质上，**虚拟化**是由位于**下层的软件模块**，通过向**上层软件模块**提供一个与它**原先所期待的运行环境完全一致的接口的方法**，抽象出一个**虚拟的软件或硬件接口**，使得上层软件可以直接运行在虚拟的环境上。

重要概念，在虚拟化中，**物理资源**通常有一个定语称为**宿主（Host**），而**虚拟出来的资源**通常有一个定语称为**客户（Guest**）。

各层虚拟化简介：

硬件抽象层上的虚拟化，通过虚拟硬件抽象层来实现虚拟机，为客户机操作系统呈现和物理硬件相同或相近的硬件抽象层。通常，宿主机和客户机的ISA（Instruction Set Architecture，指令集架构）是相同的，客户机的大部分指令可以在宿主机处理器上直接运行，只有部分需要虚拟化的指令才会由虚拟化软件进行处理，从而大大降低了虚拟化开销。比较知名的硬件抽象层的产品有VMware、Xen等。

操作系统层上的虚拟化，通过系统内核提供多个相互隔离的用户态实例，这些用户态实例具有自己独立的文件系统、网络、系统设置和库函数等。因为这是操作系统哦内核主动提供的虚拟化，因此操作系统层上的虚拟化比较高效，其系统开销非常小。

库函数层上的虚拟化，通过虚拟化操作系统的应用级函数的服务接口，使得应用程序不需要修改，就可以在不同的操作中无缝运行，从而提供系统间的互操作性。例如，WINE系统是在Linux上模拟了Windows的库函数接口，使得一个Windows的应用程序能够在Linux平台上运行。
