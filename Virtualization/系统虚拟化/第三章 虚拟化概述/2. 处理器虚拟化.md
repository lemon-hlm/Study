处理器虚拟化是VMM中最核心的部分, 因为**访问内存**和**I/O指令**本身就是**敏感指令**, 所以**内存虚拟化**和**I/O虚拟化**都依赖于**处理器虚拟化**的正确实现.

# 1 指令的模拟

VMM运行在最高特权级, 可以控制物理处理器上所有关键资源; 客户机OS运行在非最高特权级, 所以其敏感指令会陷入到VMM中通过软件方式进行模拟. 所以, 处理器虚拟化的关键在于正确模拟指令的行为.

介绍指令模拟之前, 我们理解三个概念: 虚拟寄存器、上下文和虚拟处理器.

从某种程度上, 物理处理器无非包括了一些存放数据的物理寄存器, 并且规定了使用这些寄存器的指令集, 然后按照一段预先写好的指令流, 在给定的时间点使用给定的部分寄存器来完成某种目的.

当**客户机OS**试图访问**关键资源！！！**的时候, 该请求并**不会真正发生在物理寄存器**上. 相反, **VMM**会通过**准确模拟物理处理器的行为**, 而**将其访问定位到**VMM为其设计与**物理寄存器对应的"虚拟"的寄存器**上. 当然, 从VMM实现来说, 这样的**虚拟寄存器往往是在内存中！！！**.

图3\-2是一个具体的**访问控制寄存器CR0的例子**. 当处理器取下一条指令**MOV CR0, EAX**后, 发现**特权级不符合！！！**, 则**抛出异常**, **VMM**会**截获这个异常**之后**模拟处理器的行为**, 读取**EAX(真实物理寄存器**)的内容并放到**虚拟的CR0**中. 由于**虚拟的CR0**存放在VMM为该虚拟机设计的**内存区域**里, 因此该指令执行的结果并**不会让物理的CR0内容发生改变**. 等到下一次, 当虚拟机试图读CR0时, 处理器也会抛出异常, 然后由VMM从虚拟的CR0而不是物理的CR0中返回内容给虚拟机.

![config](./images/2.png)

在没有虚拟化的环境中, 操作系统直接负责物理处理器管理, 负责进程间调度和切换. 但是, VMM接管物理处理器后, 客户机OS没有管理物理处理器的权利, 可以说此时它运行在**VMM**为之设计的**虚拟处理器**之上, 管理虚拟处理器, 并在**虚拟处理器**上负责该**虚拟机内进程调度和切换**. 而调度切换, 涉及到了上下文状态, 这里是虚拟处理器上下文.

而在某个时刻, 物理处理器中的寄存器状态构成了当前进程的上下文状态.

**进程上下文**主要是**与运算相关的寄存器状态**, 例如EIP寄存器指向进程当前执行的指令, ESP存放着当前进程的堆栈指针等. 当**操作系统进行调度**时, **当前进程的上下文**, 即**上述寄存器状态被保存在进程特定的内存区域**中, 而下一个进程的上下文被恢复到相应的寄存器中.

虚拟处理器上下文比进程上下文更为复杂, 因为客户机OS本身包含很多敏感指令, 会试图访问和修改物理处理器上定义的所有寄存器, 而这种访问和修改会被VMM重定位到虚拟处理器上. 所以, 对于虚拟处理器, 其上下文包括了更多的系统寄存器, 例如CR0、CR3、CR4和各种MSR等. 当VMM在决定切换虚拟处理器的时候, 需要考虑保存和恢复的上下文也更为复杂.

虚拟处理器可以从两个角度来理解.

首先, 从**客户机OS**角度, 其在运行的**虚拟处理器**需要具备与其"**期望"的物理处理器一样的功能和行为**, 这种"期望"的前提条件甚至可以允许客户机OS的修改, 例如VMM可以修改客户机OS的源码, 使客户机OS所"期望"的与VMM所呈现的功能集合一致. 典型"期望"包括:

⓵ 指令集合与执行效果

⓶ 可用寄存器集合, 包括通用寄存器以及各种系统寄存器.

⓷ 运行模式, 例如实模式、保护模式和64位长模式等。 处理器的运行模式决定了指令执行的效果、寻址宽度和限制以及保护粒度等. 

⓸ 地址翻译系统, 例如页表级数.

⓹ 保护机制, 例如分页和分段等.

⓺ 中断/异常机制, 例如虚拟处理器必须能够正确模拟真实处理器的行为, 在错误的执行条件下, 为虚拟机注入一个虚拟的异常.

其次, 从**VMM的角度**看, **虚拟处理器**是其需要模拟完成的一组**功能集合**. **虚拟处理器功能**可以由**物理处理器**和**VMM**共同完成. 对于**非敏感指令！！！**, **物理处理器直接解码处理其请求！！！**, 并**将相关效果直接反映到物理寄存器！！！**上; 对于**敏感指令！！！**, VMM负责**陷入再模拟！！！**, 从程序角度也就是**一组数据结构与相关处理代码的集合**. **数据结构**用于存储**虚拟寄存器的内容**, 而**相关处理代码**负责**按照物理处理器的行为将效果反映到虚拟寄存器！！！**上.

VMM已经可以为虚拟机呈现与实际物理机不一致的功能和行为。 例如， 虚拟处理器的个数， 可以与物理处理器的个数不一致。

总之, 在处理器虚拟化中, 定义虚拟寄存器和虚拟处理器, 利用上下文进行虚拟处理器调度切换, 宗旨都是让虚拟机执行的敏感指令陷入下来后, 能被VMM模拟, 而不直接作用于真实硬件上.

当然, 模拟的前提是能够陷入. 

那客户机OS执行时, 是如何通知VMM的, 也就是VMM的陷入方式. 概括讲, VMM陷入是利用处理器的保护机制, 利用中断和异常来完成的, 它有以下几种方式.



