处理器虚拟化是VMM中最核心的部分, 因为**访问内存**和**I/O指令**本身就是**敏感指令**, 所以**内存虚拟化**和**I/O虚拟化**都依赖于**处理器虚拟化**的正确实现.

# 1 指令的模拟

VMM运行在最高特权级, 可以控制物理处理器上所有关键资源; 客户机OS运行在非最高特权级, 所以其敏感指令会陷入到VMM中通过软件方式进行模拟. 所以, 处理器虚拟化的关键在于正确模拟指令的行为.

介绍指令模拟之前, 我们理解三个概念: 虚拟寄存器、上下文和虚拟处理器.

从某种程度上, 物理处理器无非包括了一些存放数据的物理寄存器, 并且规定了使用这些寄存器的指令集, 然后按照一段预先写好的指令流, 在给定的时间点使用给定的部分寄存器来完成某种目的.

当**客户机OS**试图访问**关键资源**的时候, 该请求并**不会真正发生在物理寄存器**上. 相反, **VMM**会通过**准确模拟物理处理器的行为**, 而**将其访问定位到**VMM为其设计与**物理寄存器对应的"虚拟"的寄存器**上. 当然, 从VMM实现来说, 这样的**虚拟寄存器往往是在内存中！！！**.

图3\-2是一个具体的访问控制寄存器CR0的例子. 当处理器取下一条指令MOV CR0, EAX后, 发现特权级不符合, 则抛出异常, VMM会截获这个异常之后模拟处理器的行为, 读取EAX的内容并放到虚拟的CR0中. 由于虚拟的CR0存放在VMM为该虚拟机设计的内存区域里, 因此该指令执行的结果并不会让物理的
