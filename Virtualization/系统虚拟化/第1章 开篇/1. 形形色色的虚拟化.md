
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 定义](#1-定义)
* [2 虚拟化技术的类别](#2-虚拟化技术的类别)
	* [2.1 按虚拟的对象分类](#21-按虚拟的对象分类)
	* [2.2 按抽象程度分类](#22-按抽象程度分类)
* [1 硬件抽象层上的虚拟化](#1-硬件抽象层上的虚拟化)
* [2 操作系统层上的虚拟化](#2-操作系统层上的虚拟化)
* [3 库函数层上的虚拟化](#3-库函数层上的虚拟化)
* [4 编程语言级虚拟化](#4-编程语言级虚拟化)

<!-- /code_chunk_output -->

# 1 定义

维基百科: 在计算机技术中，**虚拟化（技术**）或虚拟技术（英语：Virtualization）是一种**资源管理技术**，是将计算机的**各种实体资源**（CPU、内存、磁盘空间、网络适配器等），予以**抽象**、转换后呈现出来并可供分割、组合为一个或多个计算机配置环境。

由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些计算机硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。

# 2 虚拟化技术的类别

## 2.1 按虚拟的对象分类

- 硬件虚拟化
- 虚拟机（Virtual machine或VM），可以像真实机器一样运行程序的计算机的软件实现
    - 平台虚拟化，将操作系统和硬件平台资源分割开
        - 完全虚拟化，敏感指令在操作系统和硬件之间被捕捉处理，客户操作系统无需修改，所有软件都能在虚拟机中运行，例如IBM CP/CMS，VirtualBox，VMware Workstation
        - 硬件辅助虚拟化，利用硬件（主要是CPU）辅助处理敏感指令以实现完全虚拟化的功能，客户操作系统无需修改，例如VMware Workstation，Xen，KVM
        - 部分虚拟化，针对部分应用程序进行虚拟，而不是整个操作系统
        - 准虚拟化/超虚拟化（paravirtualization），为应用程序提供与底层硬件相似但不相同的软件接口，客户操作系统需要进行修改。例如Xen的半虚拟化模式。
        - 操作系统级虚拟化，使操作系统内核支持多用户空间实体，例如Parallels Virtuozzo Containers、OpenVZ、LXC以及类Unix系统上的chroot，Solaris上的Zone
    - 应用程序虚拟化，在操作系统和应用程序间创建虚拟环境
        - 便携式应用程序，允许程序在便携式设备中运行而不用在操作系统中安装
        - 跨平台虚拟化，允许针对特定CPU或者操作系统的软件不做修改就能运行在其他平台上，例如Wine
        - 虚拟设备，运行于虚拟化平台之上，面向应用的虚拟机映像
        - 模拟器
- 虚拟内存，将不相邻的内存区，甚至硬盘空间虚拟成统一连续的内存地址
- 存储虚拟化，将实体存储空间（如硬盘）分隔成不同的逻辑存储空间
- 网络虚拟化，将不同网络的硬件和软件资源结合成一个虚拟的整体(请给出来源？）
    - 虚拟专用网络（VPN），在大型网络（通常是Internet）中的不同计算机（节点）通过加密连接而组成的虚拟网络，具有类似局域网的功能
    - 存储器虚拟化，将网络系统中的随机存储器聚合起来，形成统一的虚拟内存池
- 桌面虚拟化，在本地计算机显示和操作远程计算机桌面，在远程计算机执行程序和储存信息
- 数据库虚拟化
- 软件虚拟化
- 服务虚拟化
- 数据虚拟化 (data virtualization), 数据虚拟化是一种统一来自多个来源的数据的方法，这样应用程序，报告工具和最终用户就可以访问数据，而不需要有关原始来源，位置和数据结构的详细信息。

## 2.2 按抽象程度分类

虚拟技术按抽象程度分为五个层次

![](./images/2019-06-03-14-24-32.png)

为了降低系统设计的复杂性，计算机系统被设计成**自上而下的抽象层次结构**，**每一个层次**都向**上一层次**呈现一个抽象，并且**每一层**只需知道**下层抽象的接口**，而**不需要了解其内部运作机制**。这样，**每一层**只需要考虑**本层的设计**以及**相邻层间的交互**。例如，**操作系统**所看到的**硬件**是一个**硬件抽象层**，而**不需要理解硬件的布线**或者**电气特性**等。

图 1-1 计算机系统的各个抽象层:

![config](./images/1.jpeg)

**硬件抽象层（Hardware Abstraction Layer, HAL**）是计算机中**软件**所能控制的**硬件的抽象接口**，通常包括**CPU的各种寄存器**、**内存管理模块**、**I/O端口**以及**内存映射的I/O地址**等。

**API抽象层**是**一个进程**所能控制的**系统功能**的集合，包括创建新进程、内存申请、归还、进程间同步与共享、文件系统和网络操作系统等。

本质上，**虚拟化**是由位于**下层的软件模块**，通过向**上层软件模块**提供一个与它**原先所期待的运行环境完全一致的接口的方法**，抽象出一个**虚拟的软件或硬件接口**，使得上层软件可以直接运行在虚拟的环境上。

重要概念，在虚拟化中，**物理资源**通常有一个定语称为**宿主（Host**），而**虚拟出来的资源**通常有一个定语称为**客户（Guest**）。

# 1 硬件抽象层上的虚拟化

**硬件抽象层上的虚拟化**，通过**虚拟硬件抽象层！！！**来实现虚拟机，为客户机操作系统呈现和物理硬件相同或相近的硬件抽象层。

由于**客户机操作系统**能看到的是**硬件抽象层**，因此客户机操作系统的行为和在物理平台上没什么区别。

通常，**宿主机和客户机**的**ISA（Instruction Set Architecture，指令集架构！！！**）是**相同**的，**客户机**的**大部分指令**可以在**宿主机处理器上直接运行(！！！**)，**只有部分需要虚拟化的指令(！！！**)才会由**虚拟化软件进行处理**，从而**大大降低了虚拟化开销**。

另外, 客户机和宿主机的硬件抽象层的**其他部分**如**中断控制器**、**设备等**，可以是**完全不同(！！！**)的, 当**客户机对硬件层抽象访问**时, **虚拟化软件**需要对此进行**截获并模拟**. 比较知名的硬件抽象层的产品有VMware、Xen等。

# 2 操作系统层上的虚拟化

**操作系统层上的虚拟化**，通过**系统内核**提供**多个相互隔离的用户态实例(经常被称为容器！！！**)，这些用户态实例对它的用户而言就像是一台真实的计算机, 具有自己**独立的文件系统**、**网络**、**系统设置**和**库函数等**。因为这是操作系统内核主动提供的虚拟化，因此操作系统层上的虚拟化比较高效，其系统开销非常小, 不需要硬件特殊支持。但灵活性较小, 每个容器中的操作系统通常必须是同一种操作系统. 另外, 操作系统层上的虚拟化虽然为用户态实例间提供了比较强的隔离性, 但其粒度比较粗. 所以被大量应用在虚拟主机服务环境中.

# 3 库函数层上的虚拟化

操作系统通常会通过应用级的库函数提供给应用程序一组服务, 例如文件操作服务、时间操作服务等, 这些库函数可以隐藏操作系统内部的一些细节, 使得应用程序编程更为简单。不同操作系统库函数有不同的服务接口. **库函数层上的虚拟化**，通过**虚拟化**操作系统的**应用级函数的服务接口**，使得**应用程序不需要修改**，就可以在**不同的操作系统**中无缝运行，从而提供**系统间的互操作性**。

例如，**WINE系统**是在**Linux**上**模拟了Windows的库函数接口(！！！**)，使得一个**Windows的应用程序**能够**在Linux平台上运行**。

WSL（Windows Subsystem for Linux）

# 4 编程语言级虚拟化

传统计算机是由指令集架构所驱动的一种机械语言，硬件的操作由特殊的I/O指令处理，也可以透过区块映射（Mapping）来操作存储器，此等级的虚拟化会将高级语言转译成一种名为字节码的语言，透过虚拟机转译成为可以直接运行的命令。跨操作系统平台、跨语言皆为其优点。

例如JVM或微软的CLR(Common Language Runtime)，**程序的代码**由虚拟机的运行时支持系统**首先翻译为硬件的机器语言**，然后**再执行**。通常**一个语言类虚拟机**是作为**一个进程**在**物理计算机系统**中运行的，因此，它属于**进程级虚拟化！！！**。
