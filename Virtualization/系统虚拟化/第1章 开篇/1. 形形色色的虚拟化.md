
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 定义](#1-定义)
* [2 虚拟化技术的类别](#2-虚拟化技术的类别)
	* [2.1 按虚拟的对象分类](#21-按虚拟的对象分类)
	* [2.2 按抽象程度分类](#22-按抽象程度分类)
		* [2.2.1 指令集架构等级的虚拟化（Instruction Set Architecture Level）](#221-指令集架构等级的虚拟化instruction-set-architecture-level)
		* [2.2.2 硬件抽象层等级的虚拟化（Hardware Abstraction Level）](#222-硬件抽象层等级的虚拟化hardware-abstraction-level)
		* [2.2.3 操作系统等级的虚拟化（Operating System Level）](#223-操作系统等级的虚拟化operating-system-level)
* [1 硬件抽象层上的虚拟化](#1-硬件抽象层上的虚拟化)
* [2 操作系统层上的虚拟化](#2-操作系统层上的虚拟化)
* [3 库函数层上的虚拟化](#3-库函数层上的虚拟化)
* [4 编程语言级虚拟化](#4-编程语言级虚拟化)

<!-- /code_chunk_output -->

# 1 定义

维基百科: 在计算机技术中，**虚拟化（技术**）或虚拟技术（英语：Virtualization）是一种**资源管理技术**，是将计算机的**各种实体资源**（CPU、内存、磁盘空间、网络适配器等），予以**抽象**、转换后呈现出来并可供分割、组合为一个或多个计算机配置环境。

由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些计算机硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。

# 2 虚拟化技术的类别

## 2.1 按虚拟的对象分类

- 硬件虚拟化
- 虚拟机（Virtual machine或VM），可以像真实机器一样运行程序的计算机的软件实现
    - 平台虚拟化，将操作系统和硬件平台资源分割开
        - 完全虚拟化，敏感指令在操作系统和硬件之间被捕捉处理，客户操作系统无需修改，所有软件都能在虚拟机中运行，例如IBM CP/CMS，VirtualBox，VMware Workstation
        - 硬件辅助虚拟化，利用硬件（主要是CPU）辅助处理敏感指令以实现完全虚拟化的功能，客户操作系统无需修改，例如VMware Workstation，Xen，KVM
        - 部分虚拟化，针对部分应用程序进行虚拟，而不是整个操作系统
        - 准虚拟化/超虚拟化（paravirtualization），为应用程序提供与底层硬件相似但不相同的软件接口，客户操作系统需要进行修改。例如Xen的半虚拟化模式。
        - 操作系统级虚拟化，使操作系统内核支持多用户空间实体，例如Parallels Virtuozzo Containers、OpenVZ、LXC以及类Unix系统上的chroot，Solaris上的Zone
    - 应用程序虚拟化，在操作系统和应用程序间创建虚拟环境
        - 便携式应用程序，允许程序在便携式设备中运行而不用在操作系统中安装
        - 跨平台虚拟化，允许针对特定CPU或者操作系统的软件不做修改就能运行在其他平台上，例如Wine
        - 虚拟设备，运行于虚拟化平台之上，面向应用的虚拟机映像
        - 模拟器
- 虚拟内存，将不相邻的内存区，甚至硬盘空间虚拟成统一连续的内存地址
- 存储虚拟化，将实体存储空间（如硬盘）分隔成不同的逻辑存储空间
- 网络虚拟化，将不同网络的硬件和软件资源结合成一个虚拟的整体(请给出来源？）
    - 虚拟专用网络（VPN），在大型网络（通常是Internet）中的不同计算机（节点）通过加密连接而组成的虚拟网络，具有类似局域网的功能
    - 存储器虚拟化，将网络系统中的随机存储器聚合起来，形成统一的虚拟内存池
- 桌面虚拟化，在本地计算机显示和操作远程计算机桌面，在远程计算机执行程序和储存信息
- 数据库虚拟化
- 软件虚拟化
- 服务虚拟化
- 数据虚拟化 (data virtualization), 数据虚拟化是一种统一来自多个来源的数据的方法，这样应用程序，报告工具和最终用户就可以访问数据，而不需要有关原始来源，位置和数据结构的详细信息。

## 2.2 按抽象程度分类

虚拟技术按抽象程度分为五个层次

![](./images/2019-06-03-14-24-32.png)


### 2.2.1 指令集架构等级的虚拟化（Instruction Set Architecture Level）

**不仅仅是处理器！！！**

指令集架构的虚拟化是透过**软件**来**模拟不同架构**的**处理器**、**存储器**、**总线**、**磁盘控制卡**、**计时器**等多个I/O设备，软件会将虚拟机所发出的**指令**转换为**本机可以操作的指令**在**现有的硬件上运行**。

这种等级的虚拟化对于模拟**相同处理器架构**的平台可以提供**很好的兼容性**，例如︰x86架构、Sparc架构、Alpha架构。

若**主机处理器**可以**运行**由虚拟机**转换出来的指令**，或是**使用相同的指令集**来完成任务，那就表示**除了处理器**以外的**操作系统**、**I/O设备**皆可**不受特定平台所绑定**，但由于虚拟机的**每条指令**都必须透过**软件来模拟**，所以在性能会有较大程度的耗损。

这个分类底下代表性的有Bochs以及QEMU。

### 2.2.2 硬件抽象层等级的虚拟化（Hardware Abstraction Level）

硬件抽象层等级的虚拟化是由**虚拟机监视器**来**隐藏不同厂商**的**处理器**、**存储器**、**芯片组**…等特征，为这些虚拟机提供**抽象与统一的虚拟平台**。运行此平台的计算机称之为主体机器（Host Machine），而在此平台中运作的虚拟机称为客体机器（Guest Machine），

当前**大多数x86平台**的商业计算机都在使用**这种虚拟化**，最主要是由于现今处理器厂商提供了**硬件辅助虚拟化技术**，例如︰第三代的Intel **VT\-d**、AMD\-Vi皆提供虚拟机直接存储器访问（Direct Memory Access）以及对各种PCI接口的直接访问功能（PCI passthrough）。

这个分类底下代表性的有VMware\_ESXi、Hyper\-V、Virtualbox、以及Citrix。

### 2.2.3 操作系统等级的虚拟化（Operating System Level）

硬件抽象层等级的虚拟化中的全虚拟化与操作系统底层间有非常高的隔离能力，支持不同的操作系统，安装后不须要重启主机、或修改引导程序（Boot Loader）以达到双系统的目的，风险低、维护简单。由于此等级的虚拟机可以访问底层操作系统，因此用户必须花费大量的时间来安装与设置虚拟机，接着才能开始评估或测试所需运作的软件，这些设置包含了操作系统的安装、安全性或兼容性软件的更新、网络、系统调教…等，如果所需的操作系统与底层操作系统相同，那么其实它们所作的跟实际上安装一台实体机器没有什么区别。

操作系统内核虚拟化可以最大限度的减少新增虚拟机的所需，在这个等级的虚拟机共享实体主机上的硬件以及操作系统，呈现彼此独立且隔离的虚拟机环境。

应用软件的环境是由操作系统、库、相依性软件、特定于系统的数据结构或文件系统，例如︰NTFS或Ext3，以及其他环境设置所组成。如果这些都保持不变，应用软件很难发现与真实环境的区别。这是所有操作系统等级虚拟化的关键想法。

这个分类底下代表性的有Docker、VPS以及KVM。





为了降低系统设计的复杂性，计算机系统被设计成**自上而下的抽象层次结构**，**每一个层次**都向**上一层次**呈现一个抽象，并且**每一层**只需知道**下层抽象的接口**，而**不需要了解其内部运作机制**。这样，**每一层**只需要考虑**本层的设计**以及**相邻层间的交互**。例如，**操作系统**所看到的**硬件**是一个**硬件抽象层**，而**不需要理解硬件的布线**或者**电气特性**等。

图 1-1 计算机系统的各个抽象层:

![config](./images/1.jpeg)

**硬件抽象层（Hardware Abstraction Layer, HAL**）是计算机中**软件**所能控制的**硬件的抽象接口**，通常包括**CPU的各种寄存器**、**内存管理模块**、**I/O端口**以及**内存映射的I/O地址**等。

**API抽象层**是**一个进程**所能控制的**系统功能**的集合，包括创建新进程、内存申请、归还、进程间同步与共享、文件系统和网络操作系统等。

本质上，**虚拟化**是由位于**下层的软件模块**，通过向**上层软件模块**提供一个与它**原先所期待的运行环境完全一致的接口的方法**，抽象出一个**虚拟的软件或硬件接口**，使得上层软件可以直接运行在虚拟的环境上。

重要概念，在虚拟化中，**物理资源**通常有一个定语称为**宿主（Host**），而**虚拟出来的资源**通常有一个定语称为**客户（Guest**）。

# 1 硬件抽象层上的虚拟化

**硬件抽象层上的虚拟化**，通过**虚拟硬件抽象层！！！**来实现虚拟机，为客户机操作系统呈现和物理硬件相同或相近的硬件抽象层。

由于**客户机操作系统**能看到的是**硬件抽象层**，因此客户机操作系统的行为和在物理平台上没什么区别。

通常，**宿主机和客户机**的**ISA（Instruction Set Architecture，指令集架构！！！**）是**相同**的，**客户机**的**大部分指令**可以在**宿主机处理器上直接运行(！！！**)，**只有部分需要虚拟化的指令(！！！**)才会由**虚拟化软件进行处理**，从而**大大降低了虚拟化开销**。

另外, 客户机和宿主机的硬件抽象层的**其他部分**如**中断控制器**、**设备等**，可以是**完全不同(！！！**)的, 当**客户机对硬件层抽象访问**时, **虚拟化软件**需要对此进行**截获并模拟**. 比较知名的硬件抽象层的产品有VMware、Xen等。

# 2 操作系统层上的虚拟化

**操作系统层上的虚拟化**，通过**系统内核**提供**多个相互隔离的用户态实例(经常被称为容器！！！**)，这些用户态实例对它的用户而言就像是一台真实的计算机, 具有自己**独立的文件系统**、**网络**、**系统设置**和**库函数等**。因为这是操作系统内核主动提供的虚拟化，因此操作系统层上的虚拟化比较高效，其系统开销非常小, 不需要硬件特殊支持。但灵活性较小, 每个容器中的操作系统通常必须是同一种操作系统. 另外, 操作系统层上的虚拟化虽然为用户态实例间提供了比较强的隔离性, 但其粒度比较粗. 所以被大量应用在虚拟主机服务环境中.

# 3 库函数层上的虚拟化

操作系统通常会通过应用级的库函数提供给应用程序一组服务, 例如文件操作服务、时间操作服务等, 这些库函数可以隐藏操作系统内部的一些细节, 使得应用程序编程更为简单。不同操作系统库函数有不同的服务接口. **库函数层上的虚拟化**，通过**虚拟化**操作系统的**应用级函数的服务接口**，使得**应用程序不需要修改**，就可以在**不同的操作系统**中无缝运行，从而提供**系统间的互操作性**。

例如，**WINE系统**是在**Linux**上**模拟了Windows的库函数接口(！！！**)，使得一个**Windows的应用程序**能够**在Linux平台上运行**。

WSL（Windows Subsystem for Linux）

# 4 编程语言级虚拟化

传统计算机是由指令集架构所驱动的一种机械语言，硬件的操作由特殊的I/O指令处理，也可以透过区块映射（Mapping）来操作存储器，此等级的虚拟化会将高级语言转译成一种名为字节码的语言，透过虚拟机转译成为可以直接运行的命令。跨操作系统平台、跨语言皆为其优点。

例如JVM或微软的CLR(Common Language Runtime)，**程序的代码**由虚拟机的运行时支持系统**首先翻译为硬件的机器语言**，然后**再执行**。通常**一个语言类虚拟机**是作为**一个进程**在**物理计算机系统**中运行的，因此，它属于**进程级虚拟化！！！**。
