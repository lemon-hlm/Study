进程是各种资源的合集, 通常一个进程包含以下几种资源.

(1) **私有**的**线性地址空间**: 这是**进程可以使用的线性地址的总和**, 其中**内核部分**可能和其它进程是**共享**的.

(2) **可执行的程序**: 也就是**二进制序列**, 包含**代码和数据**.

(3) 一些已经获得的**其它资源**, 如**打开的文件**、**管道**等.

(4) **进程的权限**: 进程的**运行权限**, 例如Linux中有root用户和非root用户之分

(5) 进程的描述符: 有的操作系统成为控制块, 包含操作该进程的一些必要信息, 例如进程ID号

这里介绍和虚拟化技术最紧密的概念--上下文.

# 1 上下文

上下文就是程序(进程/中断)运行时所需要的寄存器的最小集合. 

下面看下x86下上下文包含的寄存器.

(1) 通用寄存器组: EAX、EBX、ECX、EDX、ESI、EDI这6个， 加上ESP(栈指针)、EBP(框架指针).

(2) 段相关寄存器组: CS、DS、SS, 如果程序使用了ES等额外段寄存器, 也要包含进来.

(3) 标志寄存器: 主要指EFLAGS寄存器.

(4) 程序指针寄存器: EIP

(5) GDT基地址: 用于访问GDT、GDTR中的内容

(6) LDT段选择符: 如果程序使用了私有的LDT, LDTR的内容

(7) IDT基地址: 用于访问IDT表, IDTR的内容

(8) 控制寄存器组: CR系列, 表示当前程序运行时的CPU控制状态

(9) 浮点相关寄存器组: 用于浮点计算的一些寄存器组

(10) 一些特殊用途的寄存器: 例如x86架构下的MSR(Model\-Specific Registers)

一个程序的上下文可能是上面列出内容的一个子集(例如进程), 也可能是全部(例如虚拟机). 从程序员的观点看, 通常对于上下文切换时不需要改变的寄存器, 也可以说它不是改程序的上下文. 例如进程切换时, GDTR中的内容不需要改变, 为了方便, 通常在一个进程的上下文时不把GDTR算进去. 后面内容, 提到的上下文都是指在上下文切换时必须更改的寄存器的集合.

# 2 上下文切换

在操作系统中, 通常只有三种情况会发生上下文切换.

(1) 用户态到内核态的切换: 因为运行在不同的Ring级别, 对资源的访问权限不同, 需要切换部分上下文. 例如, 从用户态的栈切换到内核态的栈

(2) 进程切换: 这通常是全上下文的切换

(3) 到中断上下文的切换: 中断的处理函数运行在特殊的上下文环境, 称为中断上下文. CPU处理一个中断时, 不管当前CPU在运行一个进程, 还是本身就是在一个中断上下文, 都要切换到中断上下文. 例如, 更改栈指针、EIP变化等. 这通常是部分上下文的切换, 例如CR3寄存器的值就不需要更改. 根据x86架构特点, 处理中断必然经过一个中断上下文阶段, 可能的情况是:

⓵ 进程上下文→中断上下文(处理中断)→进程上下文(中断返回执行)

⓶ 进程上下文→中断上下文→新进程上下文(处理中断)→进程上下文(最先被