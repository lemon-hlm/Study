将计算机的任务进行一个粗略的分类, 其实只有两种: CPU运算和I/O操作.

# 1 x86的I/O架构

I/O是CPU访问外部设备的方法. **设备**通常通过**寄存器**和**设备RAM**将自身的功能展现给CPU, **CPU读写这些寄存器和RAM(！！！**)即可完成对设备的访问和操作. 通过**访问方式的不同**, 可以将x86架构的I/O分为如下两类.

⓵ **Port I/O(端口I/O**): 即通过**I/O端口**访问**设备寄存器**. **x86**有**65536个8位的I/O端口(！！！**), 编号为0x0000 \~ 0xFFFF. 如果将**端口号**看作**访问设备端口的地址**, 那么这65536个端口就构成了**64KB的地址空间**, 称为**I/O端口地址空间**. 与前面说的线性地址空间和物理地址空间不同, I/O端口地址空间是**独立的**, 也就说它并**不是线性地址空间或物理地址空间的一部分(！！！**). 使用**IN/OUT指令访问端口**时, **CPU**通过一个**特殊的管脚**标识这是一次**I/O端口访问**, 于是芯片组知道地址线上的地址是I/O端口号并进行相应操作. 此外, **2个**或**4个连续的8位I/O端口**, 可以组成**16位**或**32位的I/O端口**.

⓶ MMIO(Memory Map I/O, 内存映射I/O): 即通过**内存访问**的形式访问**设备寄存器或设备RAM**. x86架构下, **MMIO**和**Port I/O**最大不同在于**MMIO要占用CPU的物理地址空间**. 它把设备的寄存器或设备RAM映射到物理地址空间某段地址, 使用**MOV这样的访存指令**访问此段地址**即可访问到映射的设备**. 很多CPU架构都没有Port I/O, 采用统一的MMIO方式. 由此可见, MMIO是一种更先进的I/O访问方式.

对于**Port I/O**, 由于**编译器不能产生IN/OUT指令(！！！**), **操作系统**通常会把**汇编指令**封装成类似**inb()、outb()这样的函数**. 对于**MMIO**. 由于**整个物理地址空间**都会被映射到**线性地址空间**, 程序访问**I/O资源**时也要做**线性地址到物理地址的转换(！！！**). 与普通物理地址到线性地址的映射不同, MMIO地址通常是**不可缓存的(un\-cacheable**).

# 2 DMA

**DMA(直接内存访问**)是将**CPU从I/O操作中解放出来(！！！**)的一种技术. 如果**设备向内存复制数据**都**经过CPU**, 则会**消耗大量的CPU时间**, **不利于系统性能**. 通过**DMA**, **驱动程序(！！！**)可以**事先(或在需要的时候！！！**)设定一个**内存地址！！！**, **设备**就可以**绕开CPU直接向内存中复制(或读取)数据(！！！**). 根据发起者不同, DMA可以被分为两种.

⓵ 同步DMA: 是指**DMA操作由软件发起**. 一般流程是**设备驱动**在设定好需要被DMA访问的**内存地址**后, **写某个寄存器**来**通知设备发起DMA**. 此时, **设备**会**直接从该内存地址读取内容并操作**. 典型例子就是声卡, 当播放一段音频时, 驱动将该音频存放的地址通知声卡, 设备从内存直接读取数据并播放, 完成后以一个中断通知驱动操作完成.

设备的DMA操作都是使用物理地址访问内存, 不经过线性地址到物理地址的转换. 但IOMMU出现后, 这个情况就被改变了. 从驱动的角度看, 它要提供一片内存区域供设备访问, DMA要求这段内存区域在物理上是连续的. 现代设备支持一种称为"分散