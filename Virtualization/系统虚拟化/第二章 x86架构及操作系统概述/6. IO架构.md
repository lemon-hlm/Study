将计算机的任务进行一个粗略的分类, 其实只有两种: CPU运算和I/O操作.

# 1 x86的I/O架构

I/O是CPU访问外部设备的方法. **设备**通常通过**寄存器**和**设备RAM**将自身的功能展现给CPU, **CPU读写这些寄存器和RAM(！！！**)即可完成对设备的访问和操作. 通过**访问方式的不同**, 可以将x86架构的I/O分为如下两类.

⓵ **Port I/O(端口I/O**): 即通过**I/O端口**访问**设备寄存器**. **x86**有**65536个8位的I/O端口(！！！**), 编号为0x0000 \~ 0xFFFF. 如果将**端口号**看作**访问设备端口的地址**, 那么这65536个端口就构成了**64KB的地址空间**, 称为**I/O端口地址空间**. 与前面说的线性地址空间和物理地址空间不同, I/O端口地址空间是**独立的**, 也就说它并**不是线性地址空间或物理地址空间的一部分(！！！**). 使用**IN/OUT指令访问端口**时, **CPU**通过一个**特殊的管脚**标识这是一次**I/O端口访问**, 于是芯片组知道地址线上的地址是I/O端口号并进行相应操作. 此外, **2个**或**4个连续的8位I/O端口**, 可以组成**16位**或**32位的I/O端口**.

⓶ MMIO(Memory Map I/O, 内存映射I/O): 即通过**内存访问**的形式访问**设备寄存器或设备RAM**. x86架构下, **MMIO**和**Port I/O**最大不同在于**MMIO要占用CPU的物理地址空间**. 它把设备的寄存器或设备RAM映射到物理地址空间某段地址, 使用**MOV这样的访存指令**访问此段地址**即可访问到映射的设备**. 很多CPU架构都没有Port I/O, 采用统一的MMIO方式. 由此可见, MMIO是一种更先进的I/O访问方式.

对于**Port I/O**, 由于**编译器不能产生IN/OUT指令(！！！**), **操作系统**通常会把**汇编指令**封装成类似**inb()、outb()这样的函数**. 对于**MMIO**. 由于**整个物理地址空间**都会被映射到**线性地址空间**, 程序访问**I/O资源**时也要做**线性地址到物理地址的转换(！！！**). 与普通物理地址到线性地址的映射不同, MMIO地址通常是**不可缓存的(un\-cacheable**).

# 2 DMA

**DMA(直接内存访问**)是将**CPU从I/O操作中解放出来(！！！**)的一种技术. 如果**设备向内存复制数据**都**经过CPU**, 则会**消耗大量的CPU时间**, **不利于系统性能**. 通过**DMA**, **驱动程序(！！！**)可以**事先(或在需要的时候！！！**)设定一个**内存地址！！！**, **设备**就可以**绕开CPU直接向内存中复制(或读取)数据(！！！**). 根据发起者不同, DMA可以被分为两种.

⓵ 同步DMA: 是指**DMA操作由软件发起**. 一般流程是**设备驱动**在设定好需要被DMA访问的**内存地址**后, **写某个寄存器**来**通知设备发起DMA**. 此时, **设备**会**直接从该内存地址读取内容并操作**. 典型例子就是声卡, 当播放一段音频时, 驱动将该音频存放的地址通知声卡, 设备从内存直接读取数据并播放, 完成后以一个中断通知驱动操作完成.

设备的**DMA操作**都是使用**物理地址访问内存！！！**, **不经过线性地址到物理地址的转换！！！**. 但**IOMMU**出现后, 这个情况就被改变了, 后面说明. 

从**驱动的角度**看, 它要提供一片**内存区域供设备访问**, **DMA**要求这段内存区域在**物理上是连续！！！**的. 

**现代设备**支持一种称为"**分散 \- 聚合(Scatter\-gather**)"DMA的机制, 允许驱动向设备提供**不连续的物理内存**. 实际上, **驱动**是将**一组(！！！**)以"**起始地址 \- 长度**"为属性的**内存描述符**提供给设备, **每个描述符**描述了一块**连续的物理内存**, 但**连续两个描述符**描述的**内存不需要连续**的. 从**宏观上**看, 通过这组内存描述符可以向设备提供一片不连续的内存区域; 但从微观角度看, **DMA操作访问**的仍然是**连续的物理内存**.

# 3 PCI设备

在PCI总线之前, 各种平台都拥有自己特定的总线, 例如x86的ISA总线、Power PC的VME总线。PCI出现后, 由于速度快, 具有动态配置功能和独立于CPU架构等特点, 迅速被接收, 成为一种通用的总线架构.

## 3.1 PCI总线架构

PCI总线是一种典型的树结构. 把北桥中HOST\-PCI桥看作根, 总线中其它PCI\-PCI桥、PCI\-ISA桥(ISA总线转PCI总线桥)等桥设备和直接接PCI总线的设备看作节点, 整个PCI架构可概括成图2\-14所示.

![config](./images/12.png)

通过桥, **PCI总线**可以很容易被**扩展**, 并且**与其它总线互相挂接**, 构成**整个系统的总线网络**. 与**HOST\-PCI相连的总线被称为总线0！！！**, **其它层次总线的编号！！！**, 是在**BIOS(或操作系统)枚举设备时确定！！！**的.

## 3.2 设备标识符

设备标识符可以看作是设备在PCI总线上的地址, 格式如图2\-15.

![config](./images/13.png)

其中, 8位的Bus字段代表设备所在的总线号, 故系统中最多有256条总线. Device字段表示设备号, 代表在Bus所表示总线上的某个设备. Function字段表示功能号, 标识具体设备上的某个功能单元. "功能单元"可以理解为逻辑设备. 举一个简单的例子, 一块PCI卡, 它上面有两个独立的设备, 这两个设备共享了一些电子线路, 那么这两个设备就是这块PCI卡的两个功能单元. 但从软件角度看, 它们和两个独立接入PCI总线的设备无异.  
