将计算机的任务进行一个粗略的分类, 其实只有两种: CPU运算和I/O操作.

# 1 x86的I/O架构

I/O是CPU访问外部设备的方法. **设备**通常通过**寄存器**和**设备RAM**将自身的功能展现给CPU, **CPU读写这些寄存器和RAM(！！！**)即可完成对设备的访问和操作. 通过**访问方式的不同**, 可以将x86架构的I/O分为如下两类.

⓵ **Port I/O(端口I/O**): 即通过**I/O端口**访问**设备寄存器**. **x86**有**65536个8位的I/O端口(！！！**), 编号为0x0000 \~ 0xFFFF. 如果将**端口号**看作**访问设备端口的地址**, 那么这65536个端口就构成了**64KB的地址空间**, 称为**I/O端口地址空间**. 与前面说的线性地址空间和物理地址空间不同, I/O端口地址空间是**独立的**, 也就说它并**不是线性地址空间或物理地址空间的一部分(！！！**). 使用**IN/OUT指令访问端口**时, **CPU**通过一个**特殊的管脚**标识这是一次**I/O端口访问**, 于是芯片组知道地址线上的地址是I/O端口号并进行相应操作. 此外, **2个**或**4个连续的8位I/O端口**, 可以组成**16位**或**32位的I/O端口**.

⓶ MMIO(Memory Map I/O, 内存映射I/O): 即通过**内存访问**的形式访问**设备寄存器或设备RAM**. x86架构下, **MMIO**和**Port I/O**最大不同在于**MMIO要占用CPU的物理地址空间**. 它把设备的寄存器或设备RAM映射到物理地址空间某段地址, 使用**MOV这样的访存指令**访问此段地址**即可访问到映射的设备**. 很多CPU架构都没有Port I/O, 采用统一的MMIO方式. 由此可见, MMIO是一种更先进的I/O访问方式.

对于**Port I/O**, 由于**编译器不能产生IN/OUT指令(！！！**), **操作系统**通常会把**汇编指令**封装成类似**inb()、outb()这样的函数**. 对于**MMIO**. 由于**整个物理地址空间**都会被映射到**线性地址空间**, 程序访问**I/O资源**时也要做**线性地址到物理地址的转换(！！！**). 与普通物理地址到线性地址的映射不同, MMIO地址通常是**不可缓存的(un\-cacheable**).

# 2 DMA

**DMA(直接内存访问**)是将**CPU从I/O操作中解放出来(！！！**)的一种技术. 如果**设备向内存复制数据**都**经过CPU**, 则会**消耗大量的CPU时间**, **不利于系统性能**. 通过**DMA**, **驱动程序(！！！**)可以**事先(或在需要的时候！！！**)设定一个**内存地址！！！**, **设备**就可以**绕开CPU直接向内存中复制(或读取)数据(！！！**). 根据发起者不同, DMA可以被分为两种.

⓵ 同步DMA: 是指**DMA操作由软件发起**. 一般流程是**设备驱动**在设定好需要被DMA访问的**内存地址**后, **写某个寄存器**来**通知设备发起DMA**. 此时, **设备**会**直接从该内存地址读取内容并操作**. 典型例子就是声卡, 当播放一段音频时, 驱动将该音频存放的地址通知声卡, 设备从内存直接读取数据并播放, 完成后以一个中断通知驱动操作完成.

设备的**DMA操作**都是使用**物理地址访问内存！！！**, **不经过线性地址到物理地址的转换！！！**. 但**IOMMU**出现后, 这个情况就被改变了, 后面说明. 

从**驱动的角度**看, 它要提供一片**内存区域供设备访问**, **DMA**要求这段内存区域在**物理上是连续！！！**的. 

**现代设备**支持一种称为"**分散 \- 聚合(Scatter\-gather**)"DMA的机制, 允许驱动向设备提供**不连续的物理内存**. 实际上, **驱动**是将**一组(！！！**)以"**起始地址 \- 长度**"为属性的**内存描述符**提供给设备, **每个描述符**描述了一块**连续的物理内存**, 但**连续两个描述符**描述的**内存不需要连续**的. 从**宏观上**看, 通过这组内存描述符可以向设备提供一片不连续的内存区域; 但从微观角度看, **DMA操作访问**的仍然是**连续的物理内存**.

# 3 PCI设备

在PCI总线之前, 各种平台都拥有自己特定的总线, 例如x86的ISA总线、Power PC的VME总线。PCI出现后, 由于速度快, 具有动态配置功能和独立于CPU架构等特点, 迅速被接收, 成为一种通用的总线架构.

## 3.1 PCI总线架构

PCI总线是一种典型的树结构. 把北桥中HOST\-PCI桥看作根, 总线中其它PCI\-PCI桥、PCI\-ISA桥(ISA总线转PCI总线桥)等桥设备和直接接PCI总线的设备看作节点, 整个PCI架构可概括成图2\-14所示.

![config](./images/12.png)

通过桥, **PCI总线**可以很容易被**扩展**, 并且**与其它总线互相挂接**, 构成**整个系统的总线网络**. 与**HOST\-PCI相连的总线被称为总线0！！！**, **其它层次总线的编号！！！**, 是在**BIOS(或操作系统)枚举设备时确定！！！**的.

## 3.2 设备标识符

设备标识符可以看作是设备在PCI总线上的地址, 格式如图2\-15.

![config](./images/13.png)

其中, 8位的Bus字段代表设备所在的总线号, 故系统中最多有256条总线. Device字段表示设备号, 代表在Bus所表示总线上的某个设备. Function字段表示功能号, 标识具体设备上的某个功能单元. "功能单元"可以理解为逻辑设备. 举一个简单的例子, 一块PCI卡, 它上面有两个独立的设备, 这两个设备共享了一些电子线路, 那么这两个设备就是这块PCI卡的两个功能单元. 但从软件角度看, 它们和两个独立接入PCI总线的设备无异. 如同Function字段长度描述的, 一个独立的PCI设备上最多能有8个功能单元. Device和Function两个字段一般合起来使用, 表示一条总线上最多有256个设备. 通常, 用设备标识符三个字段的缩写BDF来代表它.

当程序通过BDF访问某个设备, 先通过Bus字段选定特定的总线, 再根据Device字段选定特定的设备, 最后通过Function字段就可以选定特定的功能单元(逻辑设备)了.

## 3.3 PCI配置空间

对于程序员来说, 不需要了解PCI设备电路实现细节, 只需要了解操作它的接口. PCI配置空间就是这样一个接口, 其结构如图.

![config](./images/14.png)

PCI设备规范规定, 设备的配置空间最多256个字节, 其中前64个字节的格式和用途是统一的, 如图. 各字段的具体含义参见"PCI Local Bus Specification Revision 3.0"的第6章, 这里只关心对程序员最重要的Base Address Registers和Interrupt Pin、Interrupt Line。

(1) Base Address Registers: **基地址寄存器**, 也就是常说的**PCI Bar！！！**. 它报告**设备寄存器！！！**或**设备RAM！！！**在**I/O端口地址空间！！！**(或**物理地址空间！！！**中)的地址. 地址是由**软件(BIOS或操作系统)动态配置！！！**的, 这就一改**ISA设备通过跳线进行配置！！！**的不灵活的特点. 通常**枚举PCI设备的软件(BIOS或操作系统！！！**)会在获得平台**所有PCI设备**后, 根据**设备数量**, 依照**固定的算法！！！**为**每个设备的PCI Bar**分配**I/O端口(或物理地址**). **设备的电子线路(非软件！！！**)负责将这些端口(或地址)映射到自身的寄存器(设备RAM)上, 这样, CPU就可以通过端口号(Port I/O方式)、物理地址(MMIO)方式访问到设备了. 使用哪种方式访问, 由PCI Bar的最后一位表示. 当该位为1时, 表示是I/O端口; 该位为0时, 表示是MMIO端口. 某些架构没有Port I/O, 只有MMIO. 根据访问目标性质不同, PCI Bar又可以划分为如下两种类型.

⓵ 可预取(Prefetchable)类型: 主要是设备RAM. 由于RAM具有在每次读操作后内容不自动改变的性质, 所以可以使用预读机制. 例如, 程序在读第N个字节的内容时, 总线可能已经读出了第N+1个字节的内容. 当预读出的内容不需要时, 只要简单的抛弃就行, 不会有什么影响.

⓶ 不可预取类型(Un\-Prefetchable): 主要指设备寄存器. 寄存器和RAM有不同的性质, 有些寄存器本身就是设备的FIFO队列的接口. 很可能当一次读操作完成后, 寄存器的值就改变了. 如果使用预读机制, 例如程序本身只读了寄存器的第一个字节, 而总线却连续读了4个字节, 那么后面3个字节的内容可能就会改变, 下次程序真正访问时得到的就是错误的值. 对于PCI Bar是否为可预取类型, 可以根据该PCI Bar的第3个位判断, 1为可预取, 否则不可预取.

(2) Interrupt Pin: **中断针脚**. PCI**中断线**的标准设计是4条: **INTA、INTB、INTC和INTD**, 分别对应值0\~3. 该寄存器的**值**表示**设备连接的是哪个中断针脚**.

(3) Interrupt Line: 设备的中断线. 该寄存器只起一个保存作用, BIOS和操作系统可以自由使用它. BIOS通常用它来保存设备所连的PIC/IOAPIC的管脚号.

x86架构把**I/O端口地址空间**中的**0xCF8\~0xCFF段**预留给了**PCI总线**, 用于**访问设备的配置空间**. 其中, 前32位的寄存器为"地址寄存器", 后32位为"值寄存器". 软件通过把设备的BDF和要访问的配置空间的字节偏移写入"地址寄存器"中, 就可以通过"值寄存器"读写该配置空间了.

## 3.4 PCI设备枚举过程

PCI设备的枚举和资源分配(即配置PCI配置空间)通常是由BIOD完成的, 并提供特殊的PCI设备枚举接口供保护模式下的操作系统使用, 这些接口称为PCIBIOS. 由于某些平台, 例如嵌入式, 是没有BIOS的, 并且操作系统厂商对BIOS的