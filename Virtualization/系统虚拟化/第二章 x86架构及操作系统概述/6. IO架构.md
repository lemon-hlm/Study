将计算机的任务进行一个粗略的分类, 其实只有两种: CPU运算和I/O操作.

# 1 x86的I/O架构

I/O是CPU访问外部设备的方法. **设备**通常通过**寄存器**和**设备RAM**将自身的功能展现给CPU, **CPU读写这些寄存器和RAM(！！！**)即可完成对设备的访问和操作. 通过**访问方式的不同**, 可以将x86架构的I/O分为如下两类.

⓵ **Port I/O(端口I/O**): 即通过**I/O端口**访问**设备寄存器**. **x86**有**65536个8位的I/O端口(！！！**), 编号为0x0000 \~ 0xFFFF. 如果将**端口号**看作**访问设备端口的地址**, 那么这65536个端口就构成了**64KB的地址空间**, 称为**I/O端口地址空间**. 与前面说的线性地址空间和物理地址空间不同, I/O端口地址空间是**独立的**, 也就说它并**不是线性地址空间或物理地址空间的一部分(！！！**). 使用**IN/OUT指令访问端口**时, **CPU**通过一个**特殊的管脚**标识这是一次**I/O端口访问**, 于是芯片组知道地址线上的地址是I/O端口号并进行相应操作. 此外, **2个**或**4个连续的8位I/O端口**, 可以组成**16位**或**32位的I/O端口**.

⓶ MMIO(Memory Map I/O, 内存映射I/O): 即通过**内存访问**的形式访问**设备寄存器或设备RAM**. x86架构下, **MMIO**和**Port I/O**最大不同在于**MMIO要占用CPU的物理地址空间**. 它把设备的寄存器或设备RAM映射到物理地址空间某段地址, 使用MOV这样的访存指令访问此段地址即可访问到映射的设备. 很多CPU架构都没有Port I/O, 采用统一的MMIO方式. 由此可见, MMIO是一种更先进的I/O访问方式.

对于Port I/O, 由于编译器不能产生IN/OUT指令, 操作系统