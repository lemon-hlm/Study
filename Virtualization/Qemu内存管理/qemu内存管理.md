
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 Qemu内存分布](#1-qemu内存分布)
* [2 内存初始化](#2-内存初始化)

<!-- /code_chunk_output -->

# 1 Qemu内存分布

![](./images/2019-06-15-22-08-00.png)

# 2 内存初始化

Qemu中的内存模型，简单来说就是Qemu**申请用户态内存**并进行管理，并将该部分申请的内存**注册**到**对应的加速器（如KVM）中**。

这样的模型有如下好处：

1. **策略与机制分离**。**加速的机制**由**KVM**负责，而**如何调用**加速的机制由**Qemu负责**

2. 可以由**Qemu**设置**多种内存模型**，如**UMA**、**NUMA**等等

3. 方便Qemu**对特殊内存的管理**（如MMIO）

4. 内存的**分配**、**回收**、**换出**等都可以采用Linux原有的机制，**不需要**为KVM**单独开发**。

5. 兼容其他加速器模型（或者无加速器，单纯使用Qemu做模拟）

Qemu需要做的有两方面工作：向KVM注册用户态内存空间，申请用户态内存空间。

Qemu主要通过如下结构来维护内存：



参考

https://blog.51cto.com/zybcloud/2149626