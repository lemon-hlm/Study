
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 SMP技术](#1-smp技术)
* [2 NUMA技术](#2-numa技术)

<!-- /code_chunk_output -->

KVM的性能调优, 可以从四个方面入手: CPU、内存、磁盘IO、网络.

CPU这块我们是针对NUMA这块的调优. NUMA是英文 Non Uniform Memory Access Architecture 的缩写，意思就是非统一内存访问，它是一种解决**多CPU共同工作**的解决方案。我们知道现在的服务器配置都比较高了，CPU很多都是多路多核的，而且CPU是需要跟存储器进行数据交互的，以往的年代，那时候的CPU运算速率不高，而且都是**单CPU模式**，那么存储器里的数据要放到CPU里进行运算这是完完全全跟得上的。但是现在的CPU运算速度大大增强了，而且都是多CPU模式，于是就出现了不平衡，那就是存储器里的数据完全不够让CPU消化，并且还会出现多个CPU抢食存储器的情况... 这种情况下CPU就表现得非常的饥渴... 数据不够享用，而且存储器还不够分配。

因此计算机科学家为了提升计算机的性能，就认真的研究了下CPU和存储器之间的协调交互模式。总体核心思想就是寻找一个多CPU模式下，如何让CPU能最大化的“享用”更多来自多个存储器的数据。

于是就设计出了以下几套解决方案：

# 1 SMP技术

最开始是SMP技术，SMP（Symmetric Multi\-Processing ）技术就是对称多处理结构，这种结构的最大特点就是CPU共享所有资源，比如总线，内存，IO系统等等。

既然是共享所有的资源，所以，各个CPU之间是平等的关系，然后操作系统管理着这些CPU对资源的访问（通常是用队列的形式去管理）。每个CPU依次的去处理队列中的进程，如果两个CPU同时访问，那么一般是通过软件锁的机制去解决争夺的问题，软件锁这概念跟开发里的线程安全锁机制道理是一样的，当一个CPU处理着一进程，一般会先锁住，处理完再释放。

所以说到这里，这里的对称指的就是CPU之间是平等的无主从，访问资源也是平等的。我们可以看下面这张图：

![](./images/2019-04-10-19-39-05.png)

这个结构是最早出现的方案，但是就是因为最早出现，所以它的弊端很快就显现出来了，那就是它的扩展能力不强。我们看上面这张图就明显感觉到，如果服务器要提升性能增加CPU，那么内存（内存最大化的情况下）就明显不够了，因为是共享模式，多一个CPU就多一个吃内存数据的人...  因此多增加的CPU没法享受到内存的数据，就会停歇，这样就造成了CPU的浪费。

有实验数据表明，SMP型的服务器CPU最好是2-4颗就OK了，多余的就浪费了。

![](./images/2019-04-10-19-41-43.png)

# 2 NUMA技术

NUMA刚才我们在前面说了是非统一内存访问的意思，它的出现就很好的解决了SMP的扩展问题。有了NUMA技术那么就可以把几十个甚至上百个CPU组合在一个服务器內。

NUMA架构设计图：

![](./images/2019-04-10-19-42-28.png)

从图中我们发现，**每个CPU模块**之间都是通过**互联模块**进行连接和信息交互，CPU都是互通互联的，同时，**每个CPU模块**平均划分为**若干个Chip（不多于4个**），**每个Chip**都有自己的**内存控制器**及**内存插槽**。

在NUMA中还有三个节点的概念：

本地节点： 对于某个节点中的所有CPU，此节点称为本地节点。

邻居节点：与本地节点相邻的节点称为邻居节点。

远端节点：非本地节点或邻居节点的节点，称为远端节点。

邻居节点和远端节点，都称作非本地节点(Off Node)。

这里要注意的是，CPU访问不同类型节点内存的速度是不相同的，访问本地节点的速度最快，访问远端节点的速度最慢，即访问速度与节点的距离有关，距离越远访问速度越慢，此距离称作Node Distance。正是因为有这个特点，所以我们的应用程序要尽量的减少不通CPU模块之间的交互，也就是说，如果你的应用程序能有方法固定在一个CPU模块里，那么你的应用的性能将会有很大的提升。