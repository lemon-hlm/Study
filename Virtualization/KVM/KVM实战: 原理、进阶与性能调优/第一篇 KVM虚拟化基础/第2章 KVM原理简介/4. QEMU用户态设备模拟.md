
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->



<!-- /code_chunk_output -->

QEMU原本就是一个著名的开源虚拟机软件项目，而不是KVM虚拟化软件的一部分。与KVM不同，**QEMU最初**实现的虚拟机是一个**纯软件**的实现，通过**二进制翻译**来实现虚拟化客户机中的CPU指令模拟，所以**性能比较低**。但是，其优点是**跨平台**，QEMU支持在Linux、Windows、FreeBSD、Solaris、MacOS等多种操作系统上运行，能支持在QEMU本身编译运行的平台上就实现虚拟机的功能，甚至可以支持**客户机与宿主机并不是同一个架构**（比如在x86平台上运行ARM客户机）。作为一个存在已久的虚拟机监控器软件，**QEMU的代码**中有**完整的虚拟机实现**，包括**处理器虚拟化**、**内存虚拟化**，以及KVM也会用到的**虚拟设备模拟**（比如网卡、显卡、存储控制器和硬盘等）。

除了二进制翻译的方式，QEMU也能与**基于硬件虚拟化**的**Xen、KVM**结合，为它们**提供客户机的设备模拟**。通过与KVM的密切结合，让虚拟化的性能提升得非常高，在真实的企业级虚拟化场景中发挥重要作用，所以我们通常提及KVM虚拟化时就会说“**QEMU/KVM**”这样的软件栈。

![](./images/2019-05-14-21-42-10.png)

最早期的KVM开发者们为了简化软件架构和代码重用，**根据KVM特性**在**QEMU的基础上**进行了**修改**（当然**这部分修改**已经**合并回QEMU的主干**代码，故**现在的QEMU已原生支持KVM虚拟化**特性）。从图2\-8可以看出，**每一个虚拟客户机**在**宿主机中**就体现为**一个QEMU进程**，而**客户机**的**每一个虚拟CPU**就是**一个QEMU线程**。虚拟机运行期间，**QEMU**会通过**KVM模块**提供的**系统调用进入内核**，由KVM模块负责将虚拟机置于处理器的特殊模式下运行。遇到虚拟机进行I/O操作时，KVM模块会从上次的系统调用出口处返回QEMU，由QEMU来负责解析和模拟这些设备。

从QEMU角度来看，也可以说QEMU使用了KVM模块的虚拟化功能，为自己的虚拟机提供硬件虚拟化的加速，从而极大地提高了虚拟机的性能。除此之外，虚拟机的配置和创建，虚拟机运行依赖的虚拟设备，虚拟机运行时的用户操作环境和交互，以及一些针对虚拟机的特殊技术（如：动态迁移），都是由QEMU自己实现的。

QEMU除了提供完全模拟的设备（如：e1000网卡、IDE磁盘等）以外，还支持virtio协议的设备模拟。virtio是一个沟通客户机前端设备与宿主机上设备后端模拟的比较高性能的协议，在前端客户机中需要安装相应的virtio-blk、virtio-scsi、virtio-net等驱动，而QEMU就实现了virtio的虚拟化后端。QEMU还提供了叫作virtio-blk-data-plane的一种高性能的块设备I/O方式，它最初在QEMU 1.4版本中被引入。virtio-blk-data-plane与传统virtio-blk相比，它为每个块设备单独分配一个线程用于I/O处理，data-plane线程不需要与原QEMU执行线程同步和竞争锁，而且它使用ioeventfd/irqfd机制，同时利用宿主机Linux上的AIO（异步I/O）来处理客户机的I/O请求，使得块设备I/O效率进一步提高。

总之，QEMU既是一个功能完整的虚拟机监控器，也在QEMU/KVM的软件栈中承担设备模拟的工作。
