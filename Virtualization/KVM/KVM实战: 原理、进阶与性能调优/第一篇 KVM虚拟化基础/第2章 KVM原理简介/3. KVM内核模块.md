**KVM内核模块**是标准Linux内核的一部分，由于**KVM的存在**让**Linux本身**就变成了**一个Hypervisor**，可以**原生地支持虚拟化功能**。目前，**KVM**支持**多种处理器平台**，它支持最常见的以Intel和AMD为代表的x86和x86_64平台，也支持PowerPC、S/390、ARM等非x86架构的平台。

**KVM模块**是KVM虚拟化的**核心模块**，它在内核中由两部分组成：

- 一个是**处理器架构无关**的部分，用**lsmod命令**中可以看到，叫作**kvm模块**；
- 另一个是**处理器架构相关**的部分，在**Intel**平台上就是**kvm\_intel**这个**内核模块**。

KVM的**主要功能**是**初始化CPU硬件**，**打开虚拟化模式**，然后**将虚拟客户机运行在虚拟机模式**下，并对虚拟客户机的运行提供一定的支持。

**KVM仅支持硬件辅助的虚拟化**，所以**打开并初始化系统硬件**以支持虚拟机的运行，是KVM模块的职责所在。

以**KVM**在Intel公司的CPU上运行为例，

1. 在**被内核加载**的时候，KVM模块会先**初始化内部的数据结构**；

2. 做好准备之后，KVM模块**检测**系统**当前的CPU**，然后**打开CPU控制寄存器CR4**中的**虚拟化模式开关**，并通过**执行VMXON指令**将**宿主操作系统（包括KVM模块本身**）置于CPU执行模式的虚拟化模式中的**根模式**；

3. 最后，**KVM模块**创建特殊设备文件/**dev/kvm**并等待来自**用户空间**的命令。

接下来，**虚拟机的创建和运行**将是一个用户空间的**应用程序（QEMU**）和**KVM模块**相互配合的过程。

/dev/kvm这个设备可以被当作一个标准的字符设备，KVM模块与用户空间QEMU的通信接口主要是一系列针对这个特殊设备文件的loctl调用。当然，每个虚拟客户机针对/dev/kvm文件的最重要的loctl调用就是“创建虚拟机”。在这里，“创建虚拟机”可以理解成KVM为了某个特定的虚拟客户机（用户空间程序创建并初始化）创建对应的内核数据结构。同时，KVM还会返回一个文件句柄来代表所创建的虚拟机。针对该文件句柄的loctl调用可以对虚拟机做相应的管理，比如创建用户空间虚拟地址和客户机物理地址及真实内存物理地址的映射关系，再比如创建多个可供运行的虚拟处理器（vCPU）。同样，KVM模块会为每一个创建出来的虚拟处理器生成对应的文件句柄，对虚拟处理器相应的文件句柄进行相应的loctl调用，就可以对虚拟处理器进行管理。

针对虚拟处理器的最重要的loctl调用就是“执行虚拟处理器”。通过它，用户空间准备好的虚拟机在KVM模块的支持下，被置于虚拟化模式中的非根模式下，开始执行二进制指令。在非根模式下，所有敏感的二进制指令都会被处理器捕捉到，处理器在保存现场之后自动切换到根模式，由KVM决定如何进一步处理（要么由KVM模块直接处理，要么返回用户空间交由用户空间程序处理）。

除了处理器的虚拟化，内存虚拟化也是由KVM模块实现的，包括前面提到的使用硬件提供的EPT特性，通过两级转换实现客户机虚拟地址到宿主机物理地址之间的转换。

处理器对设备的访问主要是通过I/O指令和MMIO，其中I/O指令会被处理器直接截获，MMIO会通过配置内存虚拟化来捕捉。但是，外设的模拟一般不由KVM模块负责。一般来说，只有对性能要求比较高的虚拟设备才会由KVM内核模块来直接负责，比如虚拟中断控制器和虚拟时钟，这样可以大量减少处理器模式切换的开销。而大部分的输入输出设备交给下一节将要介绍的用户态程序QEMU来负责。
