
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 SDL的使用](#1-sdl的使用)
	* [1.1 QEMU编译选项](#11-qemu编译选项)
	* [1.2 SDL图形局限以及使用](#12-sdl图形局限以及使用)
* [2 VNC的使用](#2-vnc的使用)
	* [2.1 宿主机中的VNC使用](#21-宿主机中的vnc使用)
		* [2.1.1 安装vnc\-server包](#211-安装vnc-server包)
		* [2.1.2 设置安全策略](#212-设置安全策略)
			* [2.1.2.1 关闭防火墙](#2121-关闭防火墙)
			* [2.1.2.2 关闭SELinux](#2122-关闭selinux)
		* [2.1.3 启动vnc server](#213-启动vnc-server)
		* [2.1.4 安装vnc client包](#214-安装vnc-client包)
		* [2.1.5 连接vnc](#215-连接vnc)
	* [2.2 QEMU使用VNC图形显示方式启动客户机](#22-qemu使用vnc图形显示方式启动客户机)
		* [2.2.1 displayport参数](#221-displayport参数)
		* [2.2.2 使用示例](#222-使用示例)
			* [2.2.2.1 \-display vnc\=\:0￼](#2221-display-vnc0)
			* [2.2.2.2 \-display vnc=localhost:0,password \-monitor stdio￼](#2222-display-vnclocalhost0password-monitor-stdio)
			* [2.2.2.3 \-display vnc=none \-monitor stdio](#2223-display-vncnone-monitor-stdio)
			* [2.2.2.4 \-display vnc=localhost:0 \-monitor stdio￼](#2224-display-vnclocalhost0-monitor-stdio)
			* [2.2.2.5 反向连接](#2225-反向连接)
* [3 VNC显示中的鼠标偏移](#3-vnc显示中的鼠标偏移)
* [4 非图形模式](#4-非图形模式)
	* [4.1 客户机输出重定向](#41-客户机输出重定向)
		* [4.1.1 方法一: 修改客户机grub](#411-方法一-修改客户机grub)
	* [4.2 \-nographic启动虚拟机](#42-nographic启动虚拟机)
* [5 显示相关的其他选项](#5-显示相关的其他选项)
	* [5.1 \-curses](#51-curses)
	* [5.2 \-vga type](#52-vga-type)
	* [5.3 \-no\-frame](#53-no-frame)
	* [5.4 \-full\-screen](#54-full-screen)
	* [5.5 \-alt\-grab](#55-alt-grab)
	* [5.6 \-ctrl\-grab](#56-ctrl-grab)

<!-- /code_chunk_output -->

# 1 SDL的使用

SDL（**Simple DirectMedia Layer**）是一个用C语言编写的、跨平台的、免费和开源的**多媒体程序库**，它提供了一个**简单的接口**用于**操作硬件平台**的**图形显示**、**声音**、**输入设备**等。SDL库被广泛应用于各种操作系统（如Linux、FreeBSD、Windows、MacOS、iOS、Android等）上的游戏开发、多媒体播放器、模拟器（如QEMU）等众多应用程序之中。尽管SDL是用C语言编写的，但是其他很多流行的编程语言（如C++、C#、Java、Objective C、Lisp、Erlang、Pascal、Perl、Python、PHP、Ruby等）都提供了对SDL库的绑定，在这些编程语言中可以很方便地调用SDL的功能。

## 1.1 QEMU编译选项

在**QEMU模拟器**中的图形显示**默认使用！！！** 的就是**SDL**。当然，需要在**编译QEMU**时配置**对SDL的支持**后，才能编译SDL功能到QEMU的命令行工具中，最后才能在启动客户机时使用SDL的功能。

在**编译QEMU**时，需要有SDL的开发包的支持。例如，在RHEL系统中需要安装**SDL\-devel**这个RPM包。

```
rpm -q SDL-devel
yum install SDL-devel
```

如果有了**SDL\-devel**软件包，在3.4.2节中配置QEMU时**默认会配置为提供SDL**的支持。

运行**configure程序**，在其输出信息中看到“**SDL support yes**”即表明SDL支持将会被编译进去￼。

当然，如果不想将SDL的支持编译进去，那么在配置QEMU时加上“\-\-**disable\-sdl**”的参数即可，在**configure输出**信息中会显示提示“SDL support no”。

查看当时编译的**config.status**能得知编译的选项

```
unset SDL_CONFIG
unset SDL2_CONFIG
```

## 1.2 SDL图形局限以及使用

SDL的功能很好用，也比较强大。

不过它也有**局限性**，那就是在**创建客户机并以SDL方式显示**时会**直接弹出一个窗口！！！**，所以SDL方式**只能在图形界面！！！** 中使用。

如果在**非图形界面**中（如ssh连接到宿主机中）使用SDL会出现如下的错误信息：

```
[root@kvm-host root]# qemu-system-x86_64 rhel7.img￼
Could not initialize SDL(No available video device) - exiting
```

在通过qemu命令行启动客户机时，若采用SDL方式，其效果如图5\-13所示。
￼
![](./images/2019-05-23-09-59-15.png)

在**使用SDL**时，如果将鼠标放入客户机中进行操作会导致**鼠标被完全抢占**，此时在**宿主机**中**不能使用鼠标**进行任何操作。QEMU**默认使用Ctrl+Alt**组合键￼来实现鼠标在**客户机与宿主机中的切换**。图5\-14显示了客户机抢占了鼠标的使用场景，在QEMU monitor上部边框中提示按哪个组合键可以释放鼠标。
￼
![](./images/2019-05-23-10-01-33.png)

使用**SDL方式启动客户机**时，弹出的**QEMU窗口**是一个**普通的窗口**，其右上角有最小化、最大化（或还原）和关闭等功能。其中，单击“**关闭**”按钮会将QEMU窗口关闭，同时**客户机也被直接关闭**了，**QEMU进程会直接退出**。

为了避免因误操作而**关闭窗口从而导致客户机直接退出**的情况发生，QEMU命令行提供了“\-**no\-quit**”参数来**去掉SDL窗口的直接关闭功能**。

在加了“\-no\-quit”参数后，SDL窗口中的“关闭”按钮的功能将会失效，而最小化、最大化（或还原）等功能正常。

# 2 VNC的使用

VNC（Virtual Network Computing）是图形化的桌面分享系统，它使用**RFB**（**Remote FrameBuffer**）协议来远程控制另外一台计算机系统。它通过**网络**将控制端的**键盘、鼠标的操作**传递到**远程受控计算机**中，而将**远程计算机**中的**图形显示屏幕反向传输回控制端的VNC窗口**中。VNC是**不依赖于操作系统**的。

尽管QEMU仍然采用**SDL作为默认的图形显示方式**，但VNC的管理方式在虚拟化环境中使用得更加广泛，因为它克服了**SDL**“**只能在图形界面中使用**”的局限性，而很多的Linux**服务器**系统通常**启动文本模式**而**不是图形界面模式**。

VNC中的操作在**VNC窗口关闭或网络断开**后，仍然会在**服务端继续执行**。另外，使用了VNC，可以在**服务器端**分别启动**多个VNC session**，从而让多人通过**各自VNC客户端同时连接到各自！！！的VNC桌面！！！** 并进行图形界面下的操作与维护。

下面分别讲述在宿主机中直接使用VNC和在通过qemu命令行创建客户机时采用VNC方式的图形显示。

## 2.1 宿主机中的VNC使用

### 2.1.1 安装vnc\-server包

在宿主机中**安装VNC的服务器软件包**（如**tigervnc\-server**）。可以用如下命令查询vnc server的安装情况。

```
[root@gerrylee qemu]# rpm -q tigervnc
tigervnc-1.8.0-13.el7.x86_64
[root@gerrylee qemu]# rpm -q tigervnc-server
tigervnc-server-1.8.0-13.el7.x86_64
```

### 2.1.2 设置安全策略

设置**宿主机中的安全策略**，使其允许VNC方式的访问，主要需要设置**防火墙**和**SELinux**的安全策略。这里为了简单起见，直接关闭了防火墙和SELinux，在实际生产环境中，需要根据特定的安全策略去设置。

#### 2.1.2.1 关闭防火墙

可以使用“**setup**”命令来**设置或关闭防火墙**，如图所示。

![](./images/2019-05-23-10-20-56.png)

也可以用“**systecmctl stop firewalld**”命令来实现同样的效果。

#### 2.1.2.2 关闭SELinux

**关闭SELinux**可以采取如下3种方式：

- 在运行时执行“**setenforce**”命令来设置，命令行如下（这个效果是**一次性**的）：

```
[root@gerrylee qemu]# setenforce 0
setenforce: SELinux is disabled
[root@gerrylee qemu]# getenforce
Disabled
```

- 修改配置文件“/etc/selinux/config”，代码段如下（这个效果是永久的）：

```
# This file controls the state of SELinux on the system.￼
# SELINUX= can take one of these three values:￼
#     enforcing - SELinux security policy is enforced.￼
#     permissive - SELinux prints warnings instead of enforcing.￼
#     disabled - No SELinux policy is loaded.￼
SELINUX=disabled￼
# SELINUXTYPE= can take one of these two values:￼
#     targeted - Targeted processes are protected,￼
#     mls - Multi Level Security protection.￼
SELINUXTYPE=targeted
```

- 设置**系统启动时GRUB配置的kernel命令参数**，加上“**selinux=0**”即可。/boot/grub/grub.conf配置文件中KVM启动条目的示例如下（这个效果只对本次启动有效）：

```
title Redhat Enterprise Linux Server (3.5.0)￼
    root (hd0,0)￼
    kernel /boot/vmlinuz-3.5.0 ro root=UUID=1a65b4bb-cd9b-4bbf-97ff-7e1f7698d3db selinux=0￼
    initrd /boot/initramfs-3.5.0.img
```

### 2.1.3 启动vnc server

在宿主机中启动VNC服务端，运行命令“vncserver：1”即可启动端口为5901￼（5900+1）的VNC远程桌面的服务器，示例如下.

可以**启动多个VNC Server**，使用**不同的端口供多个客户端使用**。

```
[root@kvm-host ~]# vncserver :1￼
￼
New 'kvm-host:1 (root)' desktop is kvm-host:1￼
￼
Starting applications specified in /root/.vnc/xstartup￼
Log file is /root/.vnc/kvm-host:1.log￼
￼
[root@gerrylee qemu]# ps aux | grep Xvnc
root     13862  0.0  0.0 112724   988 pts/0    S+   10:26   0:00 grep --color=auto Xvnc
root     18890  0.0  0.2 312084 46052 ?        Sl   5月21   0:31 /usr/bin/Xvnc :1 -auth /root/.Xauthority -desktop gerrylee:1 (root) -fp catalogue:/etc/X11/fontpath.d -geometry 1024x768 -httpd /usr/share/vnc/classes -pn -rfbauth /root/.vnc/passwd -rfbport 5901 -rfbwait 30000
```

### 2.1.4 安装vnc client包

在客户端中，安装VNC的客户端软件。

在RHEL中可以安装上面查询结果中列出的“**tigervnc**”这个RPM包；

在Windows中，可以安装**RealVNC**的**VNC Viewer**软件。

### 2.1.5 连接vnc

连接到远程的宿主机服务器，使用的格式为“IP(hostname)：PORT”。

## 2.2 QEMU使用VNC图形显示方式启动客户机

在**qemu命令行**中，添加“\-**display vnc=displayport**”参数就能让VGA显示输出到**VNC会话中而不是SDL**中。

如果在进行**QEMU编译时没有SDL**的支持，却有**VNC**的支持，则qemu命令行在启动客户机时**不需要“\-vnc**”参数也会自**动使用VNC**而**不是SDL**。

### 2.2.1 displayport参数

在qemu命令行的VNC参数中，**displayport参数**是必不可少的，它有如下3种具体值。

（1）host:N

表示仅允许从host主机的N号显示窗口来建立TCP连接到客户机。在通常情况下，QEMU会根据数字N建立对应的TCP端口，其**端口号为5900 \+ N**。

而**host值**在这里是一个**主机名**或一个**IP地址**，是可选的，如果**host值为空**，则表示QEMU建立的Server端接受来自**任何主机的连接**。

增加host参数值，可以**阻止来自其他主机的VNC连接请求**，从而在一定程度上提高了使用QEMU的VNC服务的安全性。

（2）to=L

QEMU在上面**指定的端口（5900\+N**）已被被其他应用程序占用的情况下，会依次**向后递增尝试**。

这里**to=L**，就表示**递增到5900\+L端口号为止**，不再继续往后尝试。**默认为0，即不尝试**。

（3）unix：path

表示允许通过Unix domain socket￼连接到客户机，而其中的path参数是一个处于监听状态的socket的位置路径。这种方式使用得不多，故不详细叙述。

（4）none

表示**VNC已经被初始化**，但是并**不在开始时启动**。而在需要**真正使用**VNC之时，可以在**QEMU monitor**中用**change命令启动VNC连接**。

作为可选参数的option则有如下几个可选值，每个option标志用逗号隔开。

（1）reverse

表示“反向”连接到一个处于监听中的VNC客户端，这个客户端是由前面的display参数（host：N）来指定的。需要注意的是，在反向连接这种情况下，display中的端口号N是对端（客户端）处于监听中的TCP端口，而不是现实窗口编号，即如果客户端（IP地址为IP_Demo）已经监听的命令为“vncviewer-listen：2”，则这里的VNC反向连接的参数为“-vnc IP_Demo：5902，reverse”，而不是用2这个编号。

（2）password

表示在客户端连接时需要采取基于密码的认证机制，但这里只是声明它使用密码验证，其具体的密码值必须在QEMU monitor中用change命令设置。

（3）“tls”“x509=/path/to/certificate/dir”“x509verify=/path/to/certificate/dir”“sasl”和“acl”

这5个选项都是与VNC的验证、安全￼相关的选项，本书不对其详述。

### 2.2.2 使用示例

准备两个系统，一个是KVM的宿主机系统A（IP为192.168.199.176，主机名为kvm-host），另一个是类似环境的备用KVM系统B（IP为192.168.199.146，主机名为kvm-host2），这两个系统之间可以通过网络连通。

#### 2.2.2.1 \-display vnc\=\:0￼

示例1：

在启动客户机时，带有一个**不需要密码的对任何主机都可以连接的VNC服务**。

在宿主机A系统中，运行如下命令即可启动服务。

```
[root@kvm-host ~]# qemu-system-x86_64 -smp 4 -m 16G -enable-kvm rhel7.img -device e1000,netdev=brnet0 -netdev bridge,id=brnet0,br=virbr0 -display vnc=:0￼
WARNING: Image format was not specified for 'rhel7.img' and probing guessed raw.￼
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.￼
         Specify the 'raw' format explicitly to remove the restrictions.
```

在**宿主机**中，用如下命令连接到客户机中。

```
[root@kvm-host ~]# vncviewer :0
```

而在**B系统**中，用如下命令中即可连接到**A主机**中对客户机开启的VNC服务。

```
[root@kvm-host2 ~]# vncviewer 192.168.199.176:0
```

#### 2.2.2.2 \-display vnc=localhost:0,password \-monitor stdio￼

示例2：

在启动客户机时，带有一个**需要密码**的、**仅能通过本机连接**的VNC服务。

在宿主机A系统中，运行如下命令即可将其启动。如前面提过的，**VNC的密码**需要在**QEMU monitor中设置**，所以这里加了“**\-monitor stdio**”参数，使monitor指向目前的标准输入输出，这样可以直接输入“change vnc password”命令来设置密码（否则，我们就没法连入guest了）。

```
[root@kvm-host ~]# qemu-system-x86_64 -smp 4 -m 16G -enable-kvm rhel7.img -device e1000,netdev=brnet0 -netdev bridge,id=brnet0,br=virbr0 -display vnc=localhost:0,password -monitor stdio￼
￼
    Specify the 'raw' format explicitly to remove the restrictions.￼
QEMU 2.7.0 monitor - type 'help' for more information￼
(qemu) change vnc password "123456"￼
(qemu) change vnc password￼
Password: ******￼
(qemu)
```

在QEMU monitor中，运行“**change vnc password"123456"**”命令可以将VNC密码设置为“123456”，而如果使用“change vnc password”命令不加具体密码，QEMU monitor会**交互式地提示用户输入密码**。这两个设置方法的效果是一样的。

设置好VNC密码后，在本机系统（A）中运行“vncviewer：0”或“vncviwer localhost：0”即可连接到客户机的VNC显示上。系统会需要密码验证，输入之前设置的密码即可，如图5\-18所示。
￼
![](./images/2019-05-23-10-49-37.png)

由于在QEMU启动时设置了**只有通过主机名为“localhost**”（即宿主机A系统）的主机的0号显示窗口才能连接到VNC服务，因此在B系统中无论是使用A主机的IP还是主机名去连接其0号VNC，都会提示“连接被拒绝”，如图5-19所示。
￼
![](./images/2019-05-23-10-49-56.png)

#### 2.2.2.3 \-display vnc=none \-monitor stdio

示例3：

启动客户机时**并不启动VNC**，启动后根据需要使用命令才真正开启VNC。

在宿主机A系统中，将VNC参数中的display设置为none，然后在重定向到标准输入输出的QEMU monitor中使用“change vnc：0”命令来开启VNC。操作命令如下：

```
[root@kvm-host ~]# qemu-system-x86_64 -smp 4 -m 16G -enable-kvm rhel7.img -device e1000,netdev=brnet0 -netdev bridge,id=brnet0,br=virbr0 -display vnc=none -monitor stdio￼
WARNING: Image format was not specified for 'rhel7.img' and probing guessed raw.￼
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.￼
         Specify the 'raw' format explicitly to remove the restrictions.￼
QEMU 2.7.0 monitor - type 'help' for more information￼
(qemu) change vnc ?￼
no vnc port specified￼
(qemu) change vnc :0
```

#### 2.2.2.4 \-display vnc=localhost:0 \-monitor stdio￼

示例4：

虽然在启动客户机时设置了VNC的参数，但是仍希望在**guest启动后动态地修改此参数**。

这个需求可以通过QEMU monitor中的“change vnc XX”命令来实现。在客户机启动时，仅允许localhost：0连接到VNC，并且没有设置密码。但是在客户机启动后，根据实际的需求，改变VNC设置为：允许来自任意主机的对本宿主机上3号VNC端口的连接来访问客户机，还增加了访问时的密码验证。实现这个需求的命令行操作如下：

```
[root@kvm-host ~]# qemu-system-x86_64 -smp 4 -m 16G -enable-kvm rhel7.img -device e1000,netdev=brnet0 -netdev bridge,id=brnet0,br=virbr0 -display vnc=localhost:0 -monitor stdio￼
WARNING: Image format was not specified for 'rhel7.img' and probing guessed raw.￼
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.￼
         Specify the 'raw' format explicitly to remove the restrictions.￼
QEMU 2.7.0 monitor - type 'help' for more information￼
(qemu) change vnc :3￼
(qemu) change vnc password "hellovnc"￼
If you want use passwords please enable password auth using '-vnc ${dpy},password'.￼
Could not set password￼
(qemu) change vnc :3,password "hellovnc"￼
(qemu)
```

当然，在本示例中，“\-monitor stdio”这个参数不是必需的，只需要在启动客户机后切换到QEMU monitor中执行相关的change命令即可。

#### 2.2.2.5 反向连接

示例5：

在启动客户机时，将**客户机的VNC反向连接到一个已经处于监听状态的VNC客户端**。

本示例中的这种使用场景也是非常有用的，如某用户在KVM虚拟机中调试一个操作系统，经常需要多次重启客户机中的操作系统，而该用户并不希望每次都重新开启一个VNC客户端连接到客户机。有了“reverse”参数，在实现反向连接后，该用户就可以先开启一个VNC客户端，使其处于监听某个端口的状态，然后在每次用qemu命令行重启客户机的时候，自动地反向连接到那个处于监听状态的VNC客户端。

1）在B系统中启动**vncviwer处于listen状态**，如图5\-20所示。
￼
```
vncviewer -listen :0
```

![](./images/2019-05-23-11-00-39.png)

2）在宿主机（A系统）中**启动客户机**，VNC中的参数包含**B主机的IP（或主机名**）、TCP端口，以及“**reverse**”选项。其中TCP端口的值根据B系统的监听端口来确定，从图5-20中可以看到“Listening on port 5500”，所以监听的TCP端口是5500。在宿主机系统中，启动客户机的命令行操作如下：

```
qemu-system-x86_64 rhel6u3.img -vnc 192.168.199.99:5500,reverse
```

3）在客户机启动后，在B系统中监听中的VNC客户端，就会自动连接上A系统的客户机，呈现客户机启动过程的界面，如图5\-21所示。
￼
![](./images/2019-05-23-11-05-44.png)

当然，本示例在同一个系统中也是可以操作的，在宿主机系统上监听，然后在宿主机系统上启动客户机使其“反向”连接到本地处于监听状态的VNC客户端。

# 3 VNC显示中的鼠标偏移

在QEMU中的VNC显示客户机使用很方便，而且有较多可用选项，所以其功能比较强大。不过VNC显示客户机也有一个小的缺点，那就是在**VNC显示中有鼠标偏移**的现象。

这里的偏移现象是指通过**VNC连接到客户机中操作**时，会看到**两个鼠标**，一个是**客户机中的鼠标**（这个是让客户机操作实际生效的鼠标），另一个是连接到客户机VNC的客户端系统中的鼠标。这两个鼠标的焦点通常不重合，而且相差的距离还有点大，这样会导致在客户机中移动鼠标非常不方便，如图5\-22所示。

![](./images/2019-05-23-11-07-59.png)

在图5\-22中，右上方的鼠标是Windows 7客户机中实际使用的鼠标，而中间位置的鼠标为连接VNC的客户端所在系统的鼠标。

因为存在鼠标偏移的问题，所以在**使用VNC方式启动客户机**时，强烈建议将“**\-usb**”和“**\-usbdevice tablet**”这两个USB选项一起使用，从而解决上面提到的鼠标偏移问题。

- “**\-usb**”参数开启**为客户机USB驱动的支持**（**默认已经生效**，可以省略此参数），
- 而“**\-usbdevice tablet**”参数表示添加一个“tablet”类型的USB设备。“tablet”类型的设备是一个使用**绝对坐标定位的指针设备**，就像在触摸屏中那样定位，这样可以让QEMU能够在客户机不抢占鼠标的情况下获得鼠标的定位信息。

在最新的QEMU中，与“\-usb \-usbdevice tablet”参数功能相同，也可以用“**\-device piix3\-usb\-uhci\-device usb\-tablet**”参数。目前，QEMU社区也主要推动使用功能丰富的“\-device”参数来替代以前的一些参数（如：\-usb等）。

用如下的命令启动客户机，可解决VNC中的鼠标偏移问题。

```
qemu-system-x86_64 win7.img -vnc :2 -usb -usbdevice tablet
```

或者，

```
qemu-system-x86_64 win7.img -vnc :2 -device piix3-usb-uhci -device usb-tablet
```

# 4 非图形模式

在**qemu命令行**中，添加“**\-nographic**”参数可以**完全关闭QEMU的图形界面输出**，从而让QEMU在该模式下成为简单的命令行工具。而在QEMU中**模拟产生的串口**被重定向到了**当前的控制台（console**）中，所以在客户机中对其内核进行配置使内核的控制台输出重定向到串口后，依然可以在**非图形模式下**管理客户机系统或调试客户机的内核。

## 4.1 客户机输出重定向

### 4.1.1 方法一: 修改客户机grub

需要修改**客户机的grub配置**，使其在kernel行中加上将**console输出重定向**到**串口ttyS0**。对一个客户机进行修改后的grub配置文件如下：

```
default=0￼
timeout=5￼
splashimage=(hd0,0)/boot/grub/splash.xpm.gz￼
hiddenmenu￼
title Redhat Enterprise Linux (2.6.32-279.el6.x86_64)￼
    root (hd0,0)￼
    kernel /boot/vmlinuz-2.6.32-279.el6.x86_64 ro root=UUID=9a971721-db8f-4002c-a3f4-f4ae8b037ba3 3 console=ttyS0￼
    initrd /boot/initramfs-2.6.32-279.el6.x86_64.img
```

QEMU有

## 4.2 \-nographic启动虚拟机

用“\-nographic”参数关闭图形输出，其启动命令行及客户机启动（并登录进入客户机）的过程如下所示。可见内核启动的信息就通过重定向到串口从而输出在当前的终端之中，而且可以通过串口登录到客户机系统（有的客户机Linux系统需要进行额外的设置才允许从串口登录）。

```
[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 2 -m 4G -nographic rhel7.img￼
WARNING: Image format was not specified for 'rhel7.img' and probing guessed raw.￼
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.￼
         Specify the 'raw' format explicitly to remove the restrictions.￼
[    0.000000] Linux version 4.9.0 (root@kvm-guest) (gcc version 4.8.5 20150623 (Redhat 4.8.5-11) (GCC) ) #1 SMP Mon Jan 2 15:16:01 CST 2017￼
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.9.0 root=/dev/mapper/rhel-root ro crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb console=tty0 console=ttyS0 LANG=en_US.UTF-8 3￼
<!--此处省略数百行 启动时的串口输出信息-->￼
Redhat Enterprise Linux Server 7.3 (Maipo)￼
Kernel 4.9.0 on an x86_64￼
￼
kvm-guest login: ￼
kvm-guest login: root      #这里就是客户机的登录界面了￼
Password:￼
Password: ￼
Last login: Tue Aug  8 19:30:27 on :0￼
[root@kvm-guest ~]#
```

# 5 显示相关的其他选项

QEMU还有不少关于图形显示相关的其他选项，本节再介绍其中几个比较有用的。

## 5.1 \-curses

curses是类UNIX上终端控制的库, 应用能基于它去构建文本模式下的用户界面. 而ncurses是指"new curses", 是目前curses最著名的实现.

让QEMU将**VGA￼显示输出**到使用**curses/ncurses￼接口**支持的**文本模式界面**，而**不是使用SDL来显示客户机**。

与“\-nographic”模式相比，它的好处在于，由于它是**接收客户机VGA！！！的正常输出**而**不是串口的输出信息**，因此**不需要额外更改客户机配置**将控制台重定向到串口。

当然，为了使用“\-curses”选项，在宿主机中必须有“**curses**或**ncurses**”这样的软件包提供显示接口的支持，然后再**编译QEMU**。

通过Putty连接到宿主机，然后添加“\-curses”参数的qemu命令行来启动客户机，启动到登录界面如图5\-24所示。
￼
```
qemu-system-x86_64 -enable-kvm -m 2G -hda /root/centos7.4.test.qcow2 -curses
```

![](./images/2019-05-23-11-40-06.png)

## 5.2 \-vga type

VGA(Video Graphics Array)是1987年IBM引入的显示硬件接口, 后来也成为了工业标准.

选择为客户机模拟的**VGA卡的类别**，可选类型有如下6种。

（1）**cirrus**

为客户机模拟出“**Cirrus Logic GD5446”显卡**，在客户机启动后，可以在客户机中看到VGA卡的型号，如在Linux中可以用“**lspci**”查看到VGA卡的信息。这个选项对图形显示的体验并不是很好，它的彩色是16位的，分辨率也不高，仅支持2D显示，不支持3D。不过绝大多数的系统（包括Windows 95）都支持这个系列的显卡。

在Linux客户机中查看VGA卡的类型，可以使用下面的命令行：

```
[root@kvm-guest ~]# lspci | grep VGA￼
00:02.0 VGA compatible controller: Cirrus Logic GD 5446
```

（2）**std**

模拟标准的VGA卡，带有Bochs VBE扩展。当客户机支持VBE￼2.0及以上标准时（目前流行的操作系统多数都支持），如果需要支持更高的分辨率和彩色显示深度，就会使用这个选项。显示的device id是1234：1111。

（3）VMware

提供对“VMware SVGA-II”兼容显卡的支持。

（4）virtio

半虚拟化的VGA显卡模拟。

```
[root@kvm-guest ~]# lspci | grep VGA￼
00:02.0 VGA compatible controller: Redhat, Inc Virtio GPU (rev 01)￼
[root@kvm-guest ~]# lspci -s 00:02.0 -k￼
00:02.0 VGA compatible controller: Redhat, Inc Virtio GPU (rev 01)￼
    Subsystem: Redhat, Inc Device 1100￼
    Kernel driver in use: virtio-pci￼
    Kernel modules: virtio_pci
```

（5）qxl

它也是一种半虚拟化的模拟显卡，与VGA兼容。当使用spice display的时候，推荐选择这种显卡。

（6）none

关闭VGA卡，使SDL或VNC窗口中无任何显示。一般不使用这个参数。

以上这些VGA设备的指定也都可以用-device参数来替代，并且QEMU推荐使用\-device参数。

```
Display devices:￼
name "cirrus-vga", bus PCI, desc "Cirrus CLGD 54xx VGA"￼
name "isa-cirrus-vga", bus ISA￼
name "isa-vga", bus ISA￼
name "secondary-vga", bus PCI￼
name "sga", bus ISA, desc "Serial Graphics Adapter"￼
name "VGA", bus PCI￼
name "virtio-gpu-pci", bus PCI, alias "virtio-gpu"￼
name "virtio-vga", bus PCI￼
name "VMware-svga", bus PCI
```

## 5.3 \-no\-frame

使SDL显示时没有边框。选择这个选项后，图5-13和图5-14中SDL窗口就没有边框的修饰。

## 5.4 \-full\-screen

在启动客户机时，自动使用全屏显示。

## 5.5 \-alt\-grab

使用“Ctrl\+Alt\+Shift”组合键去抢占和释放鼠标，从而使“Ctrl\+Alt\+Shift”组合键成为QEMU中的一个特殊功能键。在QEMU中默认使用“Ctrl\+Alt”组合键，所以本书常提到在SDL或VNC中用“Ctrl+Alt+2”组合键切换到QEMU monitor的窗口，而使用了“\-alt\-grab”选项后，应该相应改用“Ctrl\+Alt\+Shift\+2”组合键切换到QEMU monitor窗口。

## 5.6 \-ctrl\-grab

使用右“Ctrl”键去抢占和释放鼠标，使其成为QEMU中的特殊功能键。这与前面的“\-alt\-grab”的功能类似。
