
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 vCPU的概念](#1-vcpu的概念)
* [2 SMP的支持](#2-smp的支持)

<!-- /code_chunk_output -->

# 1 vCPU的概念

**QEMU/KVM**为客户机提供一套完整的**硬件系统环境**，在**客户机**看来，其所拥有的CPU即是**vCPU（virtual CPU**）。

在KVM环境中，**每个客户机**都是一个**标准的Linux进程（QEMU进程**），而**每一个vCPU**在宿主机中是**QEMU进程派生**的一个**普通线程**。

在**普通的Linux系统**中，进程一般有**两种执行模式**：**内核模式**和**用户模式**。

而在**KVM环境**中，增加了第3种模式：**客户模式**。vCPU在3种执行模式下的不同分工如下。

（1）用户模式（User Mode）

主要处理**I/O的模拟和管理**，由**QEMU**的代码实现。

（2）内核模式（Kernel Mode）

主要处理特别需要高性能和安全相关的指令，如处理客户模式到内核模式的转换，处理客户模式下的I/O指令或其他特权指令引起的退出（VM\-Exit），处理影子内存管理（shadow MMU）。

（3）客户模式（Guest Mode）

主要执行Guest中的大部分指令，I/O和一些特权指令除外（它们会引起VM\-Exit，被Hypervisor截获并模拟）。

vCPU在KVM中的这3种执行模式下的转换如图5\-1所示。

![](./images/2019-05-19-20-06-17.png)

在KVM环境中，整个系统的基本分层架构如图5\-2所示。

在系统的底层CPU硬件中需要有硬件辅助虚拟化技术的支持（Intel VT或AMD\-V等），宿主机就运行在硬件之上，**KVM的内核部分**是作为**可动态加载内核模块**运行在宿主机中的，其中

- 一个模块是与**硬件平台无关**的实现虚拟化核心基础架构的**kvm模块**，
- 另一个是**硬件平台相关**的kvm\_intel（或kvm\_amd）模块。

而KVM中的**一个客户机**是作为一个**用户空间进程（qemu**）运行的，它和其他普通的用户空间进程（如gnome、kde、firefox、chrome等）一样由内核来调度，使其运行在物理CPU上，不过它由kvm模块的控制，可以在前面介绍的**3种执行模式**下运行。

**多个客户机**就是宿主机中的**多个QEMU进程**，而**一个客户机**的**多个vCPU**就是**一个QEMU进程**中的**多个线程**。

和普通操作系统一样，在**客户机系统**中，同样分别运行着客户机的内核和客户机的用户空间应用程序。

![](./images/2019-05-19-20-10-10.png)

# 2 SMP的支持

在**SMP系统**中，**多个程序（进程**）可以真正做到**并行执行**，而且单个进程的多个线程也可以得到并行执行，这极大地提高了计算机系统并行处理能力和整体性能。

在**硬件**方面，**早期**的计算机系统更多的是在**一个主板**上拥有**多个物理的CPU插槽**，来实现SMP系统。后来，随着**多核技术**、**超线程（Hyper\-Threading**）技术的出现，SMP系统使用**多处理器**、**多核**、**超线程**等技术中的**一个或多个**。

在**操作系统软件**方面，多数的现代操作系统都提供了**对SMP系统的支持**。

例如，在Linux中，下面的Bash脚本（cpu\-info.sh）可以根据/proc/cpuinfo文件来检查当前系统中的CPU数量、多核及超线程的使用情况。

```sh
#!/bin/bash￼
#filename: cpu-info.sh￼
#this script only works in a Linux system which has one or more identical physical CPU(s).￼
￼
echo -n "logical CPU number in total: "￼
#逻辑CPU个数￼
cat /proc/cpuinfo | grep "processor" | wc -l￼
￼
#有些系统没有多核也没有打开超线程，就直接退出脚本￼
cat /proc/cpuinfo | grep -qi "core id"￼
if [ $? -ne 0 ]; then￼
    echo "Warning. No multi-core or hyper-threading is enabled."￼
    exit 0;￼
fi￼
￼
echo -n "physical CPU number in total: "￼
#物理CPU个数￼
cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l￼
￼
echo -n "core number in a physical CPU: "￼
#每个物理CPU上core的个数(未计入超线程)￼
core_per_phy_cpu=$(cat /proc/cpuinfo | grep "core id" | sort | uniq | wc -l)￼
echo $core_per_phy_cpu￼
￼
echo -n "logical CPU number in a physical CPU: "￼
#每个物理CPU中逻辑CPU(可能是core、threads或both)的个数￼
logical_cpu_per_phy_cpu=$(cat /proc/cpuinfo | grep "siblings" | sort | uniq | awk- F: '{print $2}')￼
echo $logical_cpu_per_phy_cpu￼
￼
#是否打开超线程，以及每个core上的超线程数目￼
#如果在同一个物理CPU上的两个逻辑CPU具有相同的”core id”，那么超线程是打开的￼
#此处根据前面计算的core_per_phy_cpu和logical_core_per_phy_cpu的比较来查看超线程￼
if [ $logical_cpu_per_phy_cpu -gt $core_per_phy_cpu ]; then￼
    echo "Hyper threading is enabled. Each core has $(expr $logical_cpu_per_phy_cpu / $core_per_phy_cpu ) threads."￼
elif [ $logical_cpu_per_phy_cpu -eq $core_per_phy_cpu ]; then￼
    echo "Hyper threading is NOT enabled."￼
else￼
    echo "Error. There's something wrong."￼
fi
```

SMP是如此的普及和被广泛使用，而QEMU在给客户机模拟CPU时，也可以提供对SMP架构的模拟，让客户机运行在SMP系统中，充分利用物理硬件的SMP并行处理优势。由于**每个vCPU**在**宿主机**中都是**一个线程**，并且宿主机Linux系统是支持多任务处理的，因此可以通过两种操作来实现客户机的SMP，一是将不同的vCPU的进程交换执行（分时调度，即使物理硬件非SMP，也可以为客户机模拟出SMP系统环境），二是将在物理SMP硬件系统上同时执行多个vCPU的进程。

在qemu命令行中，“\-smp”参数即是配置客户机的SMP系统，其具体参数如下：

```
-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets]
```

其中：
·n用于设置客户机中使用的逻辑CPU数量（默认值是1）。
·maxcpus用于设置客户机中最大可能被使用的CPU数量，包括启动时处于下线（offline）状态的CPU数量（可用于热插拔hot-plug加入CPU，但不能超过maxcpus这个上限）。
·cores用于设置每个CPU的core数量（默认值是1）。
·threads用于设置每个core上的线程数（默认