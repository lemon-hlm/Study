
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->



<!-- /code_chunk_output -->

初始化流程
KVM模块分为三个主要模块：kvm.ko、kvm-intel.ko和kvm-amd.ko，这三个模块在初始化阶段的流程如图5-4所示。
￼
图5-4 KVM模块初始化阶段:

5. KVM内核模块重要流程的分析.md-2019-07-05-21-21-24.png

KVM模块可以编译进内核中，也可以作为内核模块在Linux系统启动完成之后加载。加载时，KVM 根据主机所用的体系架构是 Intel的 VMX技术还是AMD的SVM技术，会采用略微不同的加载流程。
Linux的子模块入口通常通过module_init宏进行定义，由内核进行调用。KVM的初始化流程如图5-5所示。
KVM的初始化步骤分为以下三步。
1）在平台相关的KVM模块中通过module_init宏正式进入KVM的初始化阶段，并且执行相关的硬件初始化准备。
￼
图5-5 KVM的初始化流程
2）进入kvm_main.c中的kvm_init函数进行正式的初始化工作，期间进行了一系列子操作。
● 通过kvm_arch_init函数初始化KVM内部的一些数据结构：注册全局
变量kvm_x86_ops、初始化MMU等数据结构、初始化Timer定时器架构。
● 分配KVM内部操作所需要的内存空间。
● 调用kvm_x86_ops的hardware_setup函数进行具体的硬件体系结构的初始化工作。
● 注册sysfs和devfs等API接口信息。
● 最后初始化debugfs的调试信息。
3）进行后续的硬件初始化准备操作。
5.5.2 虚拟机的创建
基于KVM的虚拟机创建分为虚拟机创建和虚拟CPU创建两个步骤。在下文的描述中，虚拟机对应的文件描述符为vm_fd，虚拟CPU对应的文件描述符为vcpu_fd。
打开/dev/kvm 文件并且获得文件描述符 fd 后，通过 ioctl 指令写入KVM_CREATE_KVM，即可创建一个 VM 虚拟。KVM 的该部分代码实现在kvm_dev 的 file_operation 结构体中，对应的代码在 kvm_main.c 中调用 kvm_dev_ioctl_creat_vm函数实现，其代码如下：
代码5-7 KVM_CREATE_VM实现代码

```
￼     (1880)        case KVM_CREATE_VM:￼     (1881)             r = -EINVAL;￼     (1882)             if (arg)￼     (1883)                  goto out;￼     (1884)             r = kvm_dev_ioctl_create_vm();￼     (1885)             break;
```

kvm_dev_ioctl_create_vm函数通过调用kvm_create函数对KVM结构体进行创建。KVM 结构体如前文所述，保存了虚拟机运行的上下文及其他相关状态，在使用之前，需要进行一定的初始化工作。
在 x86体系架构中，KVM结构体的初始化任务在 kvm_arch_create_vm函数中进行，进行了分配内存、初始化设备列表、设置中断管理和初始化 tsc 的spin_lock的功能。在完成之后，将执行硬件初始化工作，该部分硬件初始化工作通过调用on_each_cpu宏，将在每个物理CPU上执行同样的操作。
该操作主要是尝试将所有的CPU切换入vitualize模式，并且设置好时钟等信息，这个过程通过 kvm_arch_hardware_enable 函数完成。该函数代码(arch/x86/kvm/x86.c)如下，主要执行了两