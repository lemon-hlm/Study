
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 概述](#0-概述)
* [1 PCI设备热插拔](#1-pci设备热插拔)
	* [1.1 软硬件支持](#11-软硬件支持)
	* [1.2 QEMU Monitor中热插拔功能的操作](#12-qemu-monitor中热插拔功能的操作)
* [2 PCI设备热插拔](#2-pci设备热插拔)
	* [2.1 网卡的热插拔](#21-网卡的热插拔)
	* [2.2 USB设备的热插拔](#22-usb设备的热插拔)
	* [2.3 SATA硬盘控制器的热插拔](#23-sata硬盘控制器的热插拔)
* [3 CPU的热插拔](#3-cpu的热插拔)
* [4 内存的热插拔](#4-内存的热插拔)
* [5 磁盘的热插拔](#5-磁盘的热插拔)
* [6 网卡接口的热插拔](#6-网卡接口的热插拔)

<!-- /code_chunk_output -->

# 0 概述

热插拔（hot plugging）即“带电插拔”，指可以在计算机运行时（不关闭电源）插上或拔除硬件。热插拔最早出现在服务器领域，目的是提高服务器扩展性、灵活性和对灾难的及时恢复能力。

实现热插拔需要有几方面支持：**总线电气特性**、**主板BIOS**、**操作系统**和**设备驱动**。

目前，在服务器硬件中，可实现热插拔的部件主要有SATA硬盘（IDE不支持热插拔）、CPU、内存、风扇、USB、网卡等。

在KVM虚拟化环境中，在**不关闭客户机**的情况下，也可以对客户机的设备进行热插拔。目前，主要支持**PCI设备**、**CPU**￼、**内存**的热插拔。
￼
注: CPU目前不支持热拔出

# 1 PCI设备热插拔

QEMU/KVM支持**动态添加和移除**各种**PCI设备**，包括QEMU模拟的**virtio类别**的以及**VT\-d直接分配**的。

## 1.1 软硬件支持

PCI设备的热插拔主要需要如下几个方面的支持。

（1）**BIOS**

QEMU/KVM**默认**使用**SeaBIOS**￼作为客户机的BIOS，该BIOS文件路径一般为/**usr/local/share/qemu/bios.bin**。

目前默认的BIOS已经可以支持PCI设备的热插拔。

（2）**PCI总线**

（对于VT\-d传入的设备）物理硬件中必须有VT\-d的支持，而且现在的PCI、PCIe总线都支持设备的热插拔。

（3）**客户机操作系统**

多数流行的Linux和Windows操作系统都支持设备的热插拔。可以在客户机的Linux系统的**内核配置文件**中看到一些相关的配置。

以下是RHEL 7系统中的部分相关配置：

```
CONFIG_HOTPLUG_PCI_PCIE=y￼
CONFIG_HOTPLUG_PCI=y￼
CONFIG_HOTPLUG_PCI_ACPI=y￼
CONFIG_HOTPLUG_PCI_ACPI_IBM=m￼
CONFIG_HOTPLUG_PCI_SHPC=m
```

（4）**客户机中的驱动程序**

一些**网卡驱动**（如Intel的e1000e、igb、ixgbe、igbvf、ixgbevf等）、SATA或SAS磁盘驱动、USB2.0、USB3.0驱动都支持设备的热插拔。

注意，在一些**较旧的Linux系统**（如RHEL 5.5）中需要加载“**acpiphp**”（使用“modprobe acpiphp”命令）这个模块后才支持设备的热插拔，否则热插拔完全不会对客户机系统生效；而**较新内核的Linux系统**（如RHEL 6以后、Fedora 17以后等）中已经**没有该模块**，**不需要加载该模块**，默认启动的系统就支持设备热插拔。

## 1.2 QEMU Monitor中热插拔功能的操作

有了BIOS、PCI总线、客户机操作系统和驱动程序的支持后，热插拔功能只需要在QEMU monitor中使用两个命令即可完成。

将一个BDF为**02：00.0**的**PCI设备**动态添加到**客户机**中（设置id为mydevice），在monitor中的命令如下：

```
device_add vfio-pci,host=02:00.0,id=mydevice
```

将一个设备（id为mydevice）从客户机中**动态移除**，在monitor中的命令如下：

```
device_del mydevice
```

这里的mydevice是在添加设备时**设置的唯一标识**，可以通过“**info pci**”命令在QEMU monitor中查看到当前的客户机中的PCI设备及其id值。

在6.2.2节中也已经提及，在命令行启动客户机时分配设备也可以**设置这个id值**，如果这样，那么也就可以用“device\_del id”命令将该PCI设备动态移除。

# 2 PCI设备热插拔

在介绍了PCI设备热插拔所需的必要条件和操作命令之后，本节分别以网卡、U盘、SATA硬盘的热插拔为例来演示具体的操作过程。

## 2.1 网卡的热插拔

1）启动一个客户机，**不向它分配**任何网络设备。命令行如下：

```
[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 4 -m 8G rhel7.img -net none
```

2）选择并用**vfio\-pci隐藏**一个网卡设备供热插拔使用。命令行如下：

```
[root@kvm-host ~]# lspci -s 05:00.0￼
05:00.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)￼

[root@kvm-host ~]# ./vfio-pci.sh -h 05:00.0￼
0￼
Unbinding 0000:05:00.0 from ixgbe￼
Binding 0000:05:00.0 to vfio-pci
```

这里选取了Intel 82599网卡的一个口作为热插拔的设备。

3）切换到**QEMU monitor**中，将网卡**动态添加**到客户机中，命令如下所示。

一般可以用“**Ctrl+Alt+2**”组合键**进入monitor**中，也可以在启动时添加参数“\-**monitor stdio**”，将**monitor定向**到**当前终端的标准输入输出**中直接进行操作。

```
(qemu) device_add vfio-pci,host=05:00.0,id=nic0
```

4）在QEMU monitor中**查看客户机的PCI设备**信息。命令如下：

```
(qemu) info pci￼
......￼
Bus  0, device   3, function 0:￼
    Ethernet controller: PCI device 8086:10fb￼
        IRQ 10.￼
        BAR0: 64 bit prefetchable memory at 0xc0000000 [0xc007ffff].￼
        BAR2: I/O at 0xffffffffffffffff [0x001e].￼
        BAR4: 64 bit prefetchable memory at 0xc0080000 [0xc0083fff].￼
        id "nic0"
```

由以上信息可知，“Bus 0，device 3，function 0”设备就是动态添加的网卡设备。

5）在**客户机**中检查动态添加和网卡工作情况。命令行如下：

```
[root@kvm-guest ~]# lspci | grep -i eth￼
00:03.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)￼

[root@kvm-guest ~]# ifconfig￼
ens3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500￼
    inet 192.168.100.194  netmask 255.255.252.0  broadcast 192.168.103.255￼
    inet6 fe80::92e2:baff:fec4:7394  prefixlen 64  scopeid 0x20<link>￼
    ether 90:e2:ba:c4:73:94  txqueuelen 1000  (Ethernet)￼
    RX packets 297  bytes 27154 (26.5 KiB)￼
    RX errors 0  dropped 0  overruns 0  frame 0￼
    TX packets 104  bytes 14644 (14.3 KiB)￼
    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0 ￼
......￼

[root@kvm-guest ~]# route -n￼
Kernel IP routing table￼
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface￼
0.0.0.0         192.168.100.1   0.0.0.0         UG    100    0        0 ens3￼
192.168.100.0   0.0.0.0         255.255.252.0   U     100    0        0 ens3￼
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0￼
[root@kvm-guest ~]# ping 192.168.100.1￼
PING 192.168.100.1 (192.168.100.1) 56(84) bytes of data.￼
64 bytes from 192.168.100.1: icmp_seq=1 ttl=255 time=0.474 ms￼
64 bytes from 192.168.100.1: icmp_seq=2 ttl=255 time=0.556 ms￼
^C￼
--- 192.168.100.1 ping statistics ---￼
2 packets transmitted, 2 received, 0% packet loss, time 1000ms￼
rtt min/avg/max/mdev = 0.474/0.515/0.556/0.041 ms
```

由以上输出信息可知，动态添加的网卡是客户机中唯一的网卡设备，其网络接口名称为“ens3”，它的网络连接是通畅的。

6）将刚添加的网卡**动态地从客户机中移除**。命令行如下：

```
(qemu) device_del nic0
```

将网卡动态移除后，在monitor中用“info pci”命令查不到刚才的PCI网卡设备信息，在客户机中用“lspci”命令也不能看到客户机中有网卡设备的信息。

## 2.2 USB设备的热插拔

USB设备是现代计算机系统中比较重要的一类设备，包括**USB**的**键盘**和**鼠标**、**U盘**。

之前说过，USB设备也可以像普通PCI设备那样进行**VT\-d设备直接分配**，而在**热插拔**方面也是类似的。下面以**USB鼠标**的热插拔为例来介绍一下操作过程。

USB设备的热插拔操步骤和前面介绍网卡热插拔的步骤基本是一致的，需要注意以下几点：

- 对于USB设备，使用**两个专门的命令**（**usb\_add**和**usb\_del**）对单个USB设备进行热插拔操作。当然，还可以用“**device\_add**”和“**device\_del**”将**USB根控制器！！！**（它是一个**PCI设备！！！**）连带它**上面的所有USB设备**一并**热插拔**。

- QEMU**默认没有！！！** 向客户机提供**USB总线**，需要在启动客户机的qemu命令行中添加“\-**usb**”参数（或“\-**device piix4\-usb\-uhci**”参数），来提供客户机中的**USB总线**。

- QEMU的**usb\_add/del**热插拔，包括启动时（\-**usbdevice host**）指定，都依赖于**libusb包**，需要在**宿主机**上安装好**libusbx\-devel**￼包，再编译QEMU（\-\-**enable\-libusb**）。可以在编译完QEMU之后，通过查看**config\-host.mak**里面有没有“**CONFIG\_USB\_LIBUSB=y**”来确认USB功能有没有被编译进去。

- machine type（qemu\-machine或者\-**M参数**）最好指定成较新的**q35**。QEMU**默认**模拟的**machine type**是“**pc**”Standard PC(i440FX\+PIIX，1996)，它比较老了，在加上\-usb参数后，QEMU模拟的USB系统总线常常不能与USB2.0以后的设备很好地兼容。

1）查看**宿主机**中的**USB设备**情况，然后启动一个带有USB总线控制器的客户机。命令行如下：

```
[root@kvm-host ~]# lsusb￼
Bus 002 Device 002: ID 8087:8002 Intel Corp. ￼
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub￼
Bus 001 Device 002: ID 8087:800a Intel Corp. ￼
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub￼
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub￼
Bus 003 Device 004: ID 046b:ff10 American Megatrends, Inc. Virtual Keyboard and Mouse￼
Bus 003 Device 003: ID 03f0:8607 Hewlett-Packard Optical Mobile Mouse￼
Bus 003 Device 002: ID 14dd:1005 Raritan Computer, Inc. ￼
Bus 003 Device 005: ID 03f0:0024 Hewlett-Packard KU-0316 Keyboard￼
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub ￼

[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 4 -m 8G rhel7.img -M q35 -usb -net none
```

2）切换到**QEMU monitor窗口**，动态添加USB鼠标给客户机。使用“usb\_add”命令行如下：

```
(qemu) usb_add host:003.003
```

或者，

```
(qemu) usb_add host:03f0:8607
```

而像6.2.4节中那样将宿主机中**USB根控制器**作为**PCI设备**分配给客户机，对其进行隐藏，然后使用**device\_add**命令动态添加设备。命令如下：

```
(qemu) device_add vfio-pci,host=00:14.0,id=myusb
```

解释一下“**usb\_add**”这个用于**动态添加一个USB设备**的命令，在monitor中命令格式如下：

```
usb_add devname
```

其中devname是对该USB设备的**唯一标识**，该命令支持**两种devname的格式**：

- 一种是USB hub中的**Bus**和**Device**号码的组合，
- 一种是USB的**vendor ID**和**device ID**的组合（在6.2.3节中也曾提及过）。

举个例子，对于该宿主机中的一个SanDisk的U盘设备（前一步的lsusb命令），devname可以设置为“003.003”和“03f0：8607”两种格式。另外，需要像上面命令行操作的那样，用“host：003.003”或“host：03f0：8607”来指定分配宿主机中的USB设备给客户机。

3）在客户机中，查看动态添加的USB设备。命令行如下：

```
[root@kvm-guest ~]# lsusb￼
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub￼
Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub￼
Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub￼
Bus 002 Device 002: ID 03f0:8607 Hewlett-Packard Optical Mobile Mouse￼
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
```

可见，USB鼠标已经成功地被客户机识别了。

4）在QEMU **monitor**中查看USB设备，然后动态移除USB设备。命令行操作如下：

```
(qemu) info usb￼
    Device 0.2, Port 3, Speed 1.5 Mb/s, Product HP Mobile USB Optical Mouse ￼
(qemu) usb_del 0.2￼
(qemu) info usb
```

由上面的输出信息可知，移除前，用“info usb”命令可以看到USB设备，在用“usb\_del”命令移除后，用“info usb”命令就没有查看到任何USB设备了。注意，usb\_del命令后的参数是用“info usb”命令查询出来的“Device”后的地址标识，这里为“0.2”。


当然，对于使用device\_add命令动态添加的USB设备，则应使用如下device\_del命令将其移除：

```
(qemu) device_del myusb
```

## 2.3 SATA硬盘控制器的热插拔

与6.2.4节类似，在本节的示例中，宿主机从一台机器上的SAS硬盘启动，然后将SATA硬盘动态添加给客户机使用，接着动态移除该硬盘。

1）检查宿主机系统，得到需要动态热插拔的SATA硬盘（实际上用的是**整个SATA控制器**），并将其用vfio\-pci模块隐藏起来以供热插拔使用。命令行操作如下：

```
[root@kvm-host ~]# lspci | grep SATA￼
00:1f.2 SATA controller: Intel Corporation 82801JI (ICH10 Family) SATA AHCI Controller￼

[root@kvm-host ~]# lspci | grep SAS￼
16:00.0 SCSI storage controller: LSI Logic / Symbios Logic SAS1078 PCI-Express Fusion-MPT SAS (rev 04)￼

[root@kvm-host ~]# df -h￼
Filesystem            Size  Used Avail Use% Mounted on￼
/dev/sda1             197G   76G  112G  41% /￼
tmpfs                  12G   76K   12G   1% /dev/shm￼

[root@kvm-host ~]# ls -l /dev/disk/by-path/pci-0000\:16\:00.0-sas-0x1221000000000000-lun-0￼
lrwxrwxrwx 1 root root 9 Oct 29 15:28 /dev/disk/by-path/pci-0000:16:00.0-sas-0x1221000000000000-lun-0 -> ../../sda￼

[root@kvm-host ~]# ls -l /dev/disk/by-path/pci-0000\:00\:1f.2-scsi-0\:0\:0\:0￼
lrwxrwxrwx 1 root root 9 Oct 29 15:28 /dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 -> ../../sdb￼

[root@kvm-host ~]# lspci -k -s 00:1f.2￼
00:1f.2 SATA controller: Intel Corporation 82801JI (ICH10 Family) SATA AHCI Controller￼
    Subsystem: Intel Corporation Device 34f8￼
    Kernel driver in use: ahci￼
    Kernel modules: ahci￼

[root@kvm-host ~]# ./vfio-pci.sh -h 00:1f.2￼
Unbinding 0000:00:1f.2 from ahci￼
Binding 0000:00:1f.2 to vfio-pci￼
[root@kvm-host ~]# lspci -k -s 00:1f.2￼
00:1f.2 SATA controller: Intel Corporation 82801JI (ICH10 Family) SATA AHCI Controller￼
    Subsystem: Intel Corporation Device 34f8￼
    Kernel driver in use: vfio-pci￼
    Kernel modules: ahci
```

2）启动一个客户机。命令行如下：

```
[root@kvm-host ~]# qemu-system-x86_64 rhel7.img -m 1024 -smp 2￼
VNC server running on ‘::1:5900'
```

3）在QEMU monitor中，**动态添加该SATA硬盘**。命令行如下：

```
(qemu) device_add vfio-pci,host=00:1f.2,id=sata,addr=0x06￼
(qemu) info pci   #查看客户机中pci设备，可以看到动态添加的SATA控制器￼
    Bus  0, device   6, function 0:￼
        SATA controller: PCI device 8086:3a22￼
            IRQ 9.￼
            BAR0: I/O at 0x1020 [0x1027].￼
            BAR1: I/O at 0x1030 [0x1033].￼
            BAR2: I/O at 0x1028 [0x102f].￼
            BAR3: I/O at 0x1034 [0x1037].￼
            BAR4: I/O at 0x1000 [0x101f].￼
            BAR5: 32 bit memory at 0x40000000 [0x400007ff].￼
            id "sata"
```

4）在客户机中查看动态添加的SATA硬盘。命令行如下：

```
[root@kvm-guest ~]# fdisk -l /dev/sdb￼
￼
Disk /dev/sdb: 164.7 GB, 164696555520 bytes￼
255 heads, 63 sectors/track, 20023 cylinders￼
Units = cylinders of 16065 * 512 = 8225280 bytes￼
Sector size (logical/physical): 512 bytes / 512 bytes￼
I/O size (minimum/optimal): 512 bytes / 512 bytes￼
Disk identifier: 0x0003e001￼
￼
    Device Boot     Start         End      Blocks   Id  System￼
/dev/sdb1   *           1        6528    52428800   83  Linux￼
/dev/sdb2            6528        7050     4194304   82  Linux swap / Solaris￼
/dev/sdb3            7050        9600    20480000   83  Linux￼
￼
[root@kvm-guest ~]# lspci -k -s 00:06.0￼
00:06.0 SATA controller: Intel Corporation 82801JI (ICH10 Family) SATA AHCI Controller￼
    Subsystem: Intel Corporation Device 34f8￼
    Kernel driver in use: ahci￼
    Kernel modules: ahci
```

由以上信息可知，客户已经能够获取到SATA硬盘（/dev/sdb）的信息，然后就可以正常使用动态添加的硬盘了。

5）在客户机中使用完SATA硬盘后，可以动态移除SATA硬盘。在QEMU monitor中命令行如下：

```
(qemu) device_del myusb
```

在动态移除SATA硬盘后，客户机中将没有SATA硬盘的设备，宿主机又可以控制SATA硬盘，将其用于其他用途（包括分配给另外的客户机使用）。

# 3 CPU的热插拔

CPU和内存的热插拔是**RAS（Reliability、Availability和Serviceability**）的一个重要特性，在**非虚拟化环境**中，只有**较少的x86服务器硬件**支持CPU和内存的热插拔。

在操作系统方面，拥有**较新内核的Linux系统**（如RHEL 7）等已经支持CPU和内存的热插拔，在其**内核配置文件**中可以看到类似如下的选项与CPU热插拔有关（内存热插拔见6.3.4节）。

```
CONFIG_HOTPLUG_CPU=y￼
CONFIG_BOOTPARAM_HOTPLUG_CPU0=y￼
# CONFIG_DEBUG_HOTPLUG_CPU0 is not set￼
CONFIG_ACPI_HOTPLUG_CPU=y
```

目前QEMU/KVM虚拟化环境对CPU的热插拔的支持已经比较成熟。

1）在qemu命令行中启动客户机时，使用“\-**smp n,maxvcpus=N**”参数，如下：

```
[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 4,maxcpus=8 -m 8G rhel7.img -device virtio-net-pci,netdev=nic0 -netdev bridge,id=nic0,br=virbr0
```

这就是在客户机启动时使用的4个vCPU，而最多支持客户机动态添加8个vCPU。

2）在客户机中检查CPU的状态，如下：

```
[root@kvm-guest ~]# ls /sys/devices/system/cpu/
cpu0  cpu1  cpu2  cpu3  cpuidle  isolated  kernel_max  microcode  modalias  nohz_full  offline  online  possible  power  present  uevent
```

3）通过QEMU monitor中的“**cpu\-add id**”命令为客户机添加某个vCPU，如下：

```
(qemu) cpu-add 4
```

然后，我们在客户机中就可以看到，CPU数量增加到了5个。

```
[root@kvm-guest ~]# ls /sys/devices/system/cpu/￼ cpu0  cpu1  cpu2  cpu3  cpu4  cpuidle  isolated  kernel_max  microcode  modalias  nohz_full  offline  online  possible  power  present  uevent
```

并且它也自动online了。

```
[root@kvm-guest ~]# cat /sys/devices/system/cpu/cpu4/online ￼
1￼

[root@kvm-guest ~]# cat /proc/cpuinfo | grep processor ￼
processor   : 0￼
processor   : 1￼
processor   : 2￼
processor   : 3￼
processor   : 4
```

4）如果发现客户机中新增的CPU**没有自动上线**工作，可以用“**echo 1>/sys/devices/system/cpu/cpu4/online**”命令使其进入可用状态。

目前（截止本书写作时）关于CPU热插拔的一些注意事项如下：

- 目前QEMU**只有cpu\-add**而**没有！！！对应的cpu\-del**，也就是只能热插入，而不能热拔出。

- cpu\-add id，**必须顺序加入！！！**，不能乱序，否则会影响动态迁移。

# 4 内存的热插拔

6.1.3节**virtio\_balloon**可以认为是**早期**的**间接实现内存热插拔**的功能。但其实没有热插拔，而是动态增减内存大小，并且依赖于virtio\_balloon的驱动，对客户机来说并**没有硬件上的增减**。

**真正的热插拔**是指**内存设备（DIMM**）的插拔。

自上版以来，Kernel本身（非虚拟化环境下）对内存热插拔的支持也在逐渐完善。我们先了解下这些背景知识，再介绍QEMU/KVM对内存热插拔的支持。毕竟，QEMU/KVM的目标就是无缝地模拟非虚拟化的场景，让客户机感受不到任何差别。

**内核社区**将**内存的热插拔**分为两步骤：

- **物理内存热插拔**（Physical Memory Hotplug）
- **逻辑内存热插拔**（Logical Memory Hotplug）。

前者指对**物理的内存条插拔的支持**，后者指**物理内存**作为**内核内存管理系统**可以使用的资源，被动态地加入或踢出的支持。

内存热插拔的过程是：物理内存热插入→逻辑内存热添加→逻辑内存热删除→物理内存热拔出。目前，Linux kernel对于这4个步骤都已支持（除了**逻辑内存热删除**有一点**局限性**，下面会讲到）。

**物理内存热插拔的支持**，主要依赖于**ACPI的功能**。

**逻辑内存热插拔**的支持，需要对**原来的内存管理子系统的功能**进行增补。具体的内存管理子系统的增补有：

1）新增了**ZONE\_MOVABLE**，与原来ZONE\_NORMAL、ZONE\_DMA、ZONE\_HIGHMEM并列。ZONE\_MOVABLE就专门管理movable（可以动态移除的页）￼。

2）**kernel**的**启动参数**，新增了**kernelcore**和**movablecore**，以及**movable\_node**这3个参数。

- **kernelcore**指定系统boot起来时，分配**多少内存**作为**kernel page**，剩下的都作为**movable page**。
- **movablecore**就是反过来，指定**多少**作为**movable page**￼，剩下的都是**kernel page**。
- **movable\_node**是指定**是否需要**这样一个**memory node**专门放**movable zone**。

3）/**sys/device/system/memory**下面的内存设备管理的接口，如新增valid\_zone等接口。

4）其他内部实现细节，本书不涉及。

我们在/sys/device/system/memory下面可以看到**很多memoryN这样的子目录**，这是因为**kernel**是**以memory block为单位**管理**物理内存**的。每个**block的大小**根据平台可能会有所不同，在x86\_64环境中，通常是**128MB**。以下是笔者的环境（注意输出是**十六进制**）：

```
[root@kvm-host ~]# cat /sys/devices/system/memory/block_size_bytes
8000000
```

一共有**1024个memory block**，所以**总的物理内存**是**128M×1024**=**128G**。与实际相符。

```
[root@kvm-host ~]# ls -ld /sys/devices/system/memory/memory* | wc -l￼
1024
```

在内核配置文件中，如下一些配置与内存热插拔有关，需要在**客户机**内核中使能。

```
CONFIG_MEMORY_HOTPLUG=y￼
CONFIG_SPARSEMEM=y￼
CONFIG_ACPI_HOTPLUG_MEMORY=y￼
CONFIG_MEMORY_HOTPLUG_SPARSE=y￼
CONFIG_MEMORY_HOTREMOVE=y￼
# CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE is not set￼
CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y￼
CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y￼
CONFIG_MIGRATION=y￼
CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=y
```

**QEMU/KVM**中对**内存热插拔的支持**主要是通过**对dimm设备的热插拔的支持**来实现的，对客户机的内核来说，就相当于物理地插入和拔出内存条一样。

**dimm设备**的**热插拔**与**PCI设备一样**，通过“**device\_add**”来完成。但如我们前面几章提到的那样，device\_add（或者\-device参数）是指定前端设备，也就是QEMU模拟出来的客户机看到的设备，它的实体是要靠一个对应的后端设备来实现的。所以，在device_add之前，我们先要通过object_add来定义这个后端设备，它的名字叫“memory-backend-ram”。

本节的示例没有用RHEL 7自带的3.10 kernel，而是最新的4.9kernel，以便我们可以看到最新的接口。读者需自行在客户机里编译安装最新的kernel并从它启动。

我们先用如下命令启动一个客户机。注意，这里用-m指定内存大小时候，一定要加上“slots=x，maxmem=yy”，它们表示这个客户机可供热插拔的内存插槽一共有多少，最大可以增加到多大内存。如果不指定，后续的热插拔会失败。

```
[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 4 -m 8G,slots=4,maxmem=16G rhel7.img
```

在客户机里我们查看一下内存设备，128MB×64=8GB，与我们的启动设置相符。

```
[root@kvm-guest ~]# cat /sys/devices/system/memory/block_size_bytes ￼ 8000000￼ [root@kvm-guest ~]# ls -ld /sys/devices/system/memory/memory* | wc -l￼ 64
```

在QEMU monitor中，我们添加后端设备（memory-backend-ram对象，id=mem1），以及前端设备（pc-dimm设备，id=dimm1）。我们通过info memory-device可以看到这个新添加的内存设备，大小为1073741824B=1GB，是可以热插拔的（hotpluggable）。

```
(qemu) object_add memory-backend-ram,id=mem1,size=1G￼ (qemu) device_add pc-dimm,id=dimm1,memdev=mem1￼ (qemu) info memory-devices ￼ Memory device [dimm]: "dimm1"￼     addr: 0x240000000￼     slot: 0￼     node: 0￼     size: 1073741824￼     memdev: /objects/mem1￼     hotplugged: true￼     hotpluggable: true
```

在客户机中我们可以看到新增了memory72~memory79，一共8个memory block，刚好1GB。

```
[root@kvm-guest ~]# ls -l /sys/devices/system/memory/memory* -d | sort￼ ...￼ /sys/devices/system/memory/memory9￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory72￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory73￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory74￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory75￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory76￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory77￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory78￼ drwxr-xr-x. 3 root root 0 Jan  2 17:39 /sys/devices/system/memory/memory79
```

它们的状态都自动online了（完成了物理内存的添加步骤），客户机的可用内存也增加到了9GB（也完成了逻辑内存的添加步骤）。

```
[root@kvm-guest ~]# cat /sys/devices/system/memory/memory7[23456789]/state￼ online￼ online￼ online￼ online￼ online￼ online￼ online￼ online￼ [root@kvm-guest ~]# cat /proc/meminfo ￼ MemTotal:        9223028 kB￼ MemFree:         8425988 kB￼ ......
```

同时它们都是可移除（removable）的。

```
[root@kvm-guest ~]# cat /sys/devices/system/memory/memory7[23456789]/removable￼ 1￼ 1￼ 1￼ 1￼ 1￼ 1￼ 1￼ 1
```

同时，通过valid_zones我们可以看到，新加入的内存页都默认归入了NORMAL zone。￼

```
[root@kvm-guest ~]# cat /sys/devices/system/memory/memory7[23456789]/valid_zones￼ Normal￼ Normal￼ Normal￼ Normal￼ Normal￼ Normal￼ Normal￼ Normal Movable
```

下面我们来热拔出这根虚拟内存条，注意要与跟热插入反序操作：在QEMU monitor中先删除dimm，再删除object。

```
(qemu) device_del dimm1￼ (qemu) object_del mem1
```

客户机里看到，memory block又变成了64个，内存大小又变成8GB了。

```
[root@kvm-guest ~]# ls -l /sys/devices/system/memory/memory* -d | wc -l￼ 64￼ [root@kvm-guest ~]# cat /proc/meminfo ￼ MemTotal:        8174452 kB￼ ......
```

客户机的dmesg会输出以下信息，对应于8个memory block的offline（逻辑内存拔出的步骤）。

```
[12360.500961] Offlined Pages 32768￼ [12360.503610] Offlined Pages 32768￼ [12360.506433] Offlined Pages 32768￼ [12360.509741] Offlined Pages 32768￼ [12360.519677] Offlined Pages 32768￼ [12360.521781] Offlined Pages 32768￼ [12360.523798] Offlined Pages 32768￼ [12360.526199] Offlined Pages 32768
```

另外，除了“memory-backend-ram”这个object类型以外，还有一个类似的“memory-backend-file”，其实这个更早被支持，就是用宿主机里的一个文件（可以是普通文件，也可以是hugetlbfs）作为前端dimm设备的后端。操作与上面例子类似，读者可以自己试试。

# 5 磁盘的热插拔

前面已经介绍过SATA硬盘控制器使用VT-d方式进行热插拔，其实在客户机中的磁盘一般在宿主机中表现为raw/qcow2等格式的一个文件。本节介绍普通磁盘的热插拔，操作比较简单和灵活。

首先，启动一个客户机（为了命令行简单起见，这里系统磁盘是IDE磁盘）。命令如下：

```
[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 4 -m 8G rhel7.img
```

然后，在宿主机上用qemu-img命令创建一个10GB大小的qcow2文件，作为给客户机热插拔的磁盘。

```
[root@kvm-host ~]# qemu-img create -f qcow2 hotplug-10G.img 10G
```

在QEMU monitor中，用drive_add命令添加一个基于前面创建的qcow2文件的磁盘驱动器，再用device_add命令将磁盘驱动器以virtio-blk-pci设备的形式添加到客户机中。这样就实现了给客户机热插入了一块磁盘。操作过程演示如下：

```
(qemu) drive_add 0 file=/root/hotplug-10G.img,format=qcow2,id= drive-disk1,if=none￼ OK  #这个OK是命令执行成功后的输出信息￼ (qemu) device_add virtio-blk-pci,drive=drive-disk1,id=disk1
```

到客户机中用lspci命令可以看到新添加的virtio-blk磁盘设备，用fdisk-l命令也可以查看到多了一个10GB大小的磁盘。

```
[root@kvm-guest ~]# lspci | grep IDE￼ 00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]   ￼ # 这个是启动时的IDE系统盘￼ ￼ [root@kvm-guest ~]# lspci | grep block￼ 00:04.0 SCSI storage controller: Redhat, Inc Virtio block device # 这个就是添加进去的￼                             virtio-blk磁盘￼ ￼ [root@kvm-guest ~]# fdisk -l￼ ￼ Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors￼ Units = sectors of 1 * 512 = 512 bytes￼ Sector size (logical/physical): 512 bytes / 512 bytes￼ I/O size (minimum/optimal): 512 bytes / 512 bytes￼ Disk label type: dos￼ Disk identifier: 0x0003c0e3￼ ￼    Device Boot      Start         End      Blocks   Id  System￼ /dev/sda1   *        2048     1026047      512000   83  Linux￼ /dev/sda2         1026048    41943039    20458496   8e  Linux LVM￼ ￼ Disk /dev/vda: 10.7 GB, 10737418240 bytes, 20971520 sectors￼ Units = sectors of 1 * 512 = 512 bytes￼ Sector size (logical/physical): 512 bytes / 512 bytes￼ I/O size (minimum/optimal): 512 bytes / 512 bytes￼ # 这里的 /dev/vda 就是新添加的磁盘
```

较新的主流Linux发行版中的内核一般都将hotplug的支持编译到内核中了，配置为CONFIG_HOTPLUG_PCI_ACPI=y。对于一些较老的系统（如：CentOS 5.x系统），内核可能没有默认加载hotplug相关的模块，需在进行磁盘热插拔前先在客户机中运行modprobe acpiphp、modprobe pci_hotplug这两个命令，加载hotplug模块，否则在客户机中热插拔的磁盘不能被识别。

当客户机中不使用刚才添加的磁盘时，在QEMU monitor中，使用device_del命令（添加上device_add时的设备ID）即可将添加的磁盘从客户机中拔出。操作命令如下：

```
(qemu) device_del disk1
```

使用libvirt和virsh工具的读者，可以使用virsh attach-device、virsh detach-device（或者attach-disk、detach-disk）这两个命令来实现磁盘的热插拔，具体使用方法这里不赘述。

# 6 网卡接口的热插拔

前面介绍过将物理网卡作为一个PCI/PCI-E设备使用VT-d方式直接分配给客户机使用的热插拔操作。其实在客户机中的一个网卡并非是宿主机中的一个物理网卡，本节将介绍对于这种普通网卡接口的热插拔。

首先，启动一个客户机。命令如下：

```
[root@kvm-host ~]# qemu-system-x86_64 -enable-kvm -smp 4 -m 8G rhel7.img
```

在QEMU monitor中，用netdev_add命令添加宿主机上一个网卡设备，再用device_add命令将网卡设备以virtio-net-pci设备的形式添加到客户机中。这样就实现了给客户机热插入了一块网卡。操作过程演示如下：

```
(qemu) netdev_add user,id=net1￼ # 这里设备类型选择了最简单的user模式的网卡，还有其他tap、bridge、vhost-user等可供选择￼ (qemu) device_add virtio-net-pci,netdev=net1,id=nic1,mac=52:54:00:12:34:56
```

到客户机中用lspci命令可以看到新添加的virtio-net网卡设备，用ifconfig命令也可以查看到多了一个名为eth0的网络接口。

```
[root@kvm-guest ~]# lspci | grep Eth￼ 00:05.0 Ethernet controller: Redhat, Inc Virtio network device￼ ￼ [root@kvm-guest ~]# realpath /sys/class/net/eth0￼ /sys/devices/pci0000:00/0000:00:05.0/virtio1/net/eth0￼ # 这里查看了eth0接口与virtio-net-pci网络设备的对应关系￼ ￼ [root@kvm-guest ~]# ifconfig eth0￼ eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500￼     inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255￼     inet6 fe80::5054:ff:fe12:3456  prefixlen 64  scopeid 0x20<link>￼     inet6 fec0::5054:ff:fe12:3456  prefixlen 64  scopeid 0x40<site>￼     ether 52:54:00:12:34:56  txqueuelen 1000  (Ethernet)￼     RX packets 4  bytes 1400 (1.3 KiB)￼     RX errors 0  dropped 0  overruns 0  frame 0￼     TX packets 45  bytes 7423 (7.2 KiB)￼     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

同上一节磁盘热插拔中提到的一样，客户机内核要支持设备热插拔才能实现网卡的热插拔。本节不赘述。

在QEMU monitor中，使用device_del命令（添加上device_add时的设备ID）即可将添加的网卡从客户机中拔出。操作命令如下：

```
(qemu) device_del nic1
```

使用libvirt和virsh工具的读者，可以使用virsh attach-device、virsh detach-device（或者attach-interface、detach-interface）这两个命令来实现网卡的热插拔，具体使用方法这里不赘述