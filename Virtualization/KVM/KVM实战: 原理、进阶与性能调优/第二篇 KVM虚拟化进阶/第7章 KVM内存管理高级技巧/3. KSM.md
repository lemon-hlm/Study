
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->



<!-- /code_chunk_output -->

在现代操作系统中，共享内存被很普遍地应用。如在Linux系统中，当使用fork函数创建一个进程时，子进程与其父进程共享全部的内存，而当子进程或父进程试图修改它们的共享内存区域之时，内核会分配一块新的内存区域，并试图将修改的共享内存区域复制到新的内存区域上，然后让进程去修改复制的内存。这就是著名的“写时复制”（copy-on-write，COW）技术。而本节介绍的KSM技术却与这种内存共享概念不同。
7.3.1　KSM基本原理
KSM是“Kernel SamePage Merging”的缩写，中文可称为“内核同页合并”。KSM允许内核在两个或多个进程（包括虚拟客户机）之间共享完全相同的内存页。KSM让内核扫描检查正在运行中的程序并比较它们的内存，如果发现它们有完全相同的内存区域或内存页，就将多个相同的内存合并为一个单一的内存页，并将其标识为“写时复制”。这样可以起到节省系统内存使用量的作用。之后，如果有进程试图去修改被标识为“写时复制”的合并内存页，就为该进程复制出一个新的内存页供其使用。
在QEMU/KVM中，一个虚拟客户机就是一个QEMU进程，所以使用KSM也可以实现多个客户机之间的相同内存合并。而且，如果在同一宿主机上的多个客户机运行的是相同的操作系统或应用程序，则客户机之间的相同内存页的数量就可能比较大，这种情况下KSM的作用就更加显著。在KVM环境下使用KSM，还允许KVM请求哪些相同的内存页是可以被共享而合并的，所以KSM只会识别并合并那些不会干扰客户机运行且不会影响宿主机或客户机运行的安全内存页。可见，在KVM虚拟化环境中，KSM能够提高内存的速度和使用效率。具体可以从以下两个方面来理解。
1）在KSM的帮助下，相同的内存页被合并了，减少了客户机的内存使用量。一方面，内存中的内容更容易被保存到CPU的缓存中，另一方面，有更多的内存可用于缓存一些磁盘中的数据。因此，不管是内存的缓存命中率（CPU缓存命中率），还是磁盘数据的缓存命中率（在内存中命中磁盘数据缓存的命中率）都会提高，从而提高了KVM客户机中操作系统或应用程序的运行速度。
2）正如在5.3.3节中提及的那样，KSM是内存过载使用的一种较好的方式。KSM通过减少每个客户机实际占用的内存数量，可以让多个客户机分配的内存数量之和大于物理上的内存数量。而对于使用相同内存量的客户机而言，在物理内存量不变的情况下，可以在一个宿主机中创建更多的客户机，提高了虚拟化客户机部署的密度，提高了物理资源的利用效率。
KSM是在Linux内核2.6.32中被加入内核主干代码中去的。目前多数流行的Linux发型版都已经将KSM的支持编译到内核中了，其内核配置文件中有“CONFIG_KSM=y”项。Linux系统的内核进程ksmd负责扫描后合并进程的相同内存页￼，从而实现KSM功能。root用户可以通过“/sys/kernel/mm/ksm/”目录下的文件来配置和监控ksmd这个守护进程。KSM只会去扫描和试图合并那些应用程序建议为可合并的内存页，应用程序（如QEMU）通过如下的madvice系统调用来告诉内核哪些页可合并。目前的QEMU都是支持KSM的，也可以通过查看其代码中对madvise函数的调用情况来确定是否支持KSM。QEMU中的关键函数简要分析如下：

/* 将地址标志为KSM可合并的系统调用*/￼ /* int madvise(addr, length, MADV_MERGEABLE) */￼ /* madvise系统调用的声明在 <sys/mman.h>中*/￼ /* int　madvise(　void　*start,　size_t　length,　int　advice　);　*/￼ ￼ /* qemu代码的exec.c文件中，开启内存可合并选项*/￼ static int memory_try_enable_merging(void *addr, size_t len)￼ {￼ /*这里可以看到：通过qemu的-machine mem-merge=on|off参数可以对每个客户机开启或关闭KSM支持。￼   我们后面通过实例观察效果。*/￼     if (!machine_mem_merge(current_machine)) {￼         /* disabled by the user */￼         return 0;￼     }￼ ￼     return qemu_madvise(addr, len, QEMU_MADV_MERGEABLE);￼ }￼ ￼ /* qemu代码的osdep.c文件中对qemu_madvise()函数的定义*/￼ int qemu_madvise(void *addr, size_t len, int advice)￼ {￼     if (advice == QEMU_MADV_INVALID) {￼         errno = EINVAL;￼         return -1;￼     }￼ #if defined(CONFIG_MADVISE)￼     return madvise(addr, len, advice);￼ #elif defined(CONFIG_POSIX_MADVISE)￼     return posix_madvise(addr, len, advice);￼ #else￼     errno = EINVAL;￼     return -1;￼ #endif￼ }￼ ￼ /*在osdep.h中看到，只有QEMU configure了CONFIG-MADVISE（检查你的config-host.mak）并且你￼ 的宿主机系统支持MADV_MERGEABLE标准POSIX系统调用，QEMU才可以支持KSM；否则，QEMU就不会去调用POSIX接口来做KSM*/￼ #if defined(CONFIG_MADVISE)￼ ￼ ...￼ #ifdef MADV_MERGEABLE￼ #define QEMU_MADV_MERGEABLE MADV_MERGEABLE￼ #else￼ #define QEMU_MADV_MERGEABLE QEMU_MADV_INVALID￼ #endif

KSM最初就是为KVM虚拟化中的使用而开发的￼，不过它对非虚拟化的系统依然非常有用。KSM可以在KVM虚拟化环境中非常有效地降低内存使用量，据笔者在网上看到的资料显示，在KSM的帮助下，有人在物理内存为16GB的机器上，用KVM成