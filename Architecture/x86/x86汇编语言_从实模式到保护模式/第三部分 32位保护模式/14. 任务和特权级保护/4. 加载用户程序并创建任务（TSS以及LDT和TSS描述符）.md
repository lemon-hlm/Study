## 1. 任务控制块和TCB链

把控制权从较低的特权级转移到较高的特权级，通过调用门可以，但是直接控制转移是不允许的。

内核初始化完成后，接下来加载和重定位用户程序（应用程序），并移交控制权。按处理器的要求，**要使一个程序成为“任务”，并且能够参与任务切换和调度，必须要有LDT和TSS**。

加载程序并创建一个任务，需要用到很多数据，比如程序的大小、加载的位置等等。当任务执行结束，还要依据这些信息回收所占用的内存空间。还有，多任务系统是多个任务同时运行的，特别是在一个单处理器（核）的系统中，**为了任务切换和轮转**，必须能追踪到**所有正在运行的任务**，记录它们的状态，或根据它们的当前状态来采取合适操作（16章学习任务切换和轮转）。

为满足以上要求，内核应该为每一个任务创建一个内存区域，来记录任务的信息和状态，称为任务控制块（Task Control Block，TCB）。**TCB不是处理器要求**，是我们自己为方便发明的。

为追踪到所有任务，应当把每个人物控制块TCB串起来，形成一个链表。

## 3. 加载用户程序

**当用户程序被读入内存，并处于运行或等待运行的状态时，就视为一个任务**。每个任务允许有自己的LDT，而且可以定义在任何内存位置。所以，我们需要做三件事：

- 分配一块内存，作为LDT使用，为创建用户程序各个段的描述符准备；
- 将LDT的大小和起始线性地址登记在任务控制块TCB中；
- 分配内存并加载用户称故乡，并将它的大小和起始线性地址登记到TCB中。

## 7. 安装LDT描述符到GDT中

**LDT和GDT都用来存放各种描述符，因为它们用于系统管理，所以称为系统的段或系统段**。《ComputerArchitecture/x86/CPU/实模式和保护模式区别及寻址方式》可以查看所有系统段。

GDT是唯一的，所以**只需要用GDTR寄存器存放其线性地址和段界限即可（不需要设置GDT描述符<指向GDT的描述符>）**；但LDT不同，每个任务一个，所以为了追踪它们，处理器要求**在GDT中安装每个LDT的描述符（每个LDT都有相应的描述符在GDT中）**。

**当要使用这些LDT（即执行该任务时，TSS中有一个IDT选择子）**时，可以**用它们的选择子来访问GDT**，**将LDT描述符加载到LDTR寄存器**。其实主要用来做寄存器和特权级的保护工作。

下图是**LDT描述符**（意思是在**GDT中的指向相应LDT的描述符**）的格式。

![config](images/18.png)

LDT本身时一种特殊的段，最大尺寸是64KB。段基地址指示LDT在内存的起始地址，段界限指示LDT的范围；描述符的G是颗粒度，适用于LDT，**即使4KB的颗粒度，也不能超过64KB的大小**。

D位（或叫B位）和L位对LDT描述符来说没有意义，固定为0。

AVL和P位含义和存储器的段描述符相同。

LDT描述符中的S位固定为0，表示系统的段描述符或门描述符，以相对于存储器的段描述符（S=1），因为LDT描述符属于系统的段描述符。

在描述符为系统的段描述符时，即，S=0的前提下，TYPE字段为0010（二进制）表明这是一个LDT描述符。

## 8. 任务状态段TSS的格式

![config](images/2.png)

TSS内偏移0处是前一个任务的TSS描述符选择子。当系统多个任务同时存在，可以从一个任务切换到另一个任务执行，此时称任务是嵌套的。被嵌套的任务用这个指针指向前一个任务，控制返回时，处理器需要这个指针。当Call指令、中断或者异常造成任务切换，处理器会把旧任务的TSS选择子复制到新任务的TSS的Back Link字段中，并且设置**新任务的NT**（EFLAGS的bit14）为1，以表明新任务嵌套于旧任务中。关于这点我们会在第15章学习。在创建一个任务的时候，这个字段可以填写0.

SS0、SS1和SS2分别是0、1和2特权级的**栈段选择子**，ESP0、ESP1和ESP2分别是0、1和2特权级栈的栈顶指针。这些内容由当前任务的创建者填写，且填写后一般不变的静态部分，当通过门进行特权级之间的控制转移时，处理器使用这些信息来切换栈。

CR3和分页有关，16章讲述。此处一般由任务的创建者填写。

偏移32~92区域是处理器各个寄存器的快照部分，用于在进行任务切换时，保存处理器的状态以便恢复现场。在一个多任务环境中，每次创建一个任务，操作系统至少要填写EIP、EFLAGS、ESP、CS、DS、SS、ES、FS和GS，当任务第一次执行，处理器从这里加载初始执行环境，并从CS:EIP处开始执行任务的第一条指令。此后运行期间，该区域内容由处理器固件进行更改。

LDT选择子是当前任务的LDT描述符选择子。由内核填写，指向当前任务的LDT。该信息由处理器在任务切换时使用，在任务运行期间保持不变。

T位用于软件调试。多任务环境中，T=1，每次切换到该任务时，将**引发一个调试异常中断**。调试程序可以接管该中断并显示任务的状态。

I/O映射基地址用于决定当前任务是否可以访问特定的硬件端口。

#### I/O许可位图（I/O Permission Bit Map）

EFLAGS寄存器的IOPL位决定了当前任务的I/O特权级别。如果在数值上CPL<=IOPL，那么所有的I/O操作都是允许的，针对任何硬件端口的访问都可以通过；如果在数值上CPL>IOPL，也并不是说就不能访问硬件端口。事实上，处理器的意思是总体上不允许，但个别端口除外。至于个别端口是哪些端口，要找到当前任务的TSS，并检索I/O许可位图。

I/O许可位图（I/O Permission Bit Map）是一个比特序列，因为处理器最多可以访问65536个端口，所以这个比特序列最多允许65536比特（即8KB）。

![config](images/21.png)

如下图中的绿色部分，第一个字节代表端口0~7，第二个字节代表端口8~15，以此类推。每个比特的值决定了相应的端口是否允许访问。为1时禁止访问，为0时允许访问。

在TSS内偏移为102字节的那个字单元，是I/O位图基地址字段，它指明了I/O许可位图相对于TSS起始处的偏移，例如下图中这个字段的值是144.

有几点需要说明： 

1. 如果I/O位图基地址的值>=TSS的段界限（就是TSS描述符中的段界限），就表示没有I/O许可位图。 
2. 处理器要求I/O位图的末尾必须附加一个全1的字节，即0xFF. 
3. 处理器不要求为每一个I/O端口都提供位映射，对于那些没有在位图中映射的位，处理器假定它对应的比特是1（禁止访问）。 
4. TSS描述符中的界限值包括I/O许可位图在内，也包括最后附加的0xFF. 以下图为例，TSS的界限值是149（总大小150减去1）。
 
![config](images/20.png)

## 9. 创建任务状态TSS

TSS的界限值必须至少103，小于改值的TSS，执行任务切换时，会引发处理器异常中断。

## 10. 安装TSS描述符到GDT中（TSS描述符）

![config](images/19.png)

和LDT一样，**必须在全局描述符表（GDT）中创建每一个TSS的描述符（还是在GDT中！！！）**。一方面为了对TSS进行段和特权级的检查；另一方面，也是执行任务切换的需要。**当call far和jmp far指令的操作数是TSS描述符选择子时，处理器执行任务切换操作**。

TSS描述符格式和LDT描述符差不多（也是系统段），除了TYPE位。

B位是“忙”位（Busy）。在任务刚刚创建的时候，它应该为0，表明任务不忙。当任务开始执行时，或者处于挂起状态（临时被中断执行）时，由处理器固件把B位置1.

任务是不可重入的。就是说在多任务环境中，如果一个任务是当前任务，那么它可以切换到其他任务，但是不能从自己切换到自己。在TSS描述符中设置B位，并由处理器固件进行管理，可以防止这种情况的发生。