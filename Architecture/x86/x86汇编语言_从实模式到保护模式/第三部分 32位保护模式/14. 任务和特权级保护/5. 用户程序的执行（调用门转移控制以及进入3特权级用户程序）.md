## 1. 通过调用门转移控制的完整过程

先看完整的调用门控制转移和返回过程。

### 转移的过程

首先，通过调用门实施控制转移，可以使用jmp far和call far指令。指令执行时，**描述符选择子必须指向调用门（调用门描述符安装在LDT或GDT中**），32位偏移量被忽略。使用下表的特权检查机制。注意，表比较关系是数值上的。

![config](images/11.png)

当使用jmp far指令通过调用门控制转移时，要求当前特权级和目标代码段的特权级相同。原因是用**jmp far指令通过调用门控制转移时，不改变CPL**。

相反，使用**call far指令通过调用门控制转移**时，如果**改变了当前特权级，则必须切换栈（任务内的控制转移，必须切换栈）**。即，从当前任务的固有栈切换到与目标代码段特权级相同的栈上。栈的切换由处理器自动进行。

当前栈是由SS和ESP的当前内容所指示的。要切换到的新栈的相关信息位于当前任务的TSS中，处理器知道如何找到它。**栈切换**过程如下：

1. 根据**目标代码段的DPL**（也就是新的CPL）到**当前任务的TSS**中读取**新栈的选择子和栈指针**。在读取栈选择子、栈指针或者栈段描述符的过程中，任何违反段界限的错误都将导致产生一个无效TSS异常。 
2. 检查栈段描述符的特权级和类型是否有效，若无效同样产生一个无效TSS异常。 
3. 临时保存SS和ESP的**当前值**，把新栈的选择子和栈指针加载到SS和ESP中。然后把临时保存的SS和ESP的内容压入新栈中。
4. 根据调用门描述符中“**参数个数”字段**，把**旧栈中的所有参数**复制到**新栈**中。如果参数个数为0，则不复制参数。 

![config](images/23.png)
 
5. 将**当前CS和EIP**的内容压入**新栈**。通过调用门实施的控制转移一定是远转移，所以要压入CS和EIP。 
6. 从**调用门描述符**中把**目标代码段的选择子和段内偏移值**传送到**CS和EIP**中，开始执行被调用过程。

相反，如果没有改变特权级别，则不切换栈，继续使用调用者**当前的栈**，只是在原来的基础上压入当前**CS和EIP**的内容。

![config](images/22.png)

另外，如果通过调用门的控制转移是jmp far指令发起的，**不会返回原来的调用者，且没有特权级变化，也不需要切换栈**。相反，如果是call far指令发起的，则**可以使用远返回指令retf把控制返回到调用者**。

### 返回的过程

对于相同特权级的返回，CPU从堆栈中弹出EIP和CS；**会发生特权级改变的远返回仅允许返回到低特权级程序中**，即返回到的代码段的DPL在数值上要大于CPL。返回的全部过程如下：

1. 检测被调用者栈中CS寄存器的RPL字段值，以确定在返回时特权级是否发生改变。
2. 弹出并使用被调用过程栈上的值加载EIP和CS寄存器。在此过程中会对代码段描述符和代码段选择子的RPL进行特权级与类型检查。
3. 如果远返回指令是带参数的，则将参数和ESP寄存器的当前值相加，以跳过被调用者栈中的参数部分，最后的结果是ESP寄存器指向调用者SS和ESP的压栈值。注意，retf指令的参数必须等于调用门中所有参数的总字节数之和。
4. 如果返回时需要改变特权级，则从栈中将ESP和SS弹出，并把值代入寄存器ESP和SS，切换到调用者的栈。
5. 如果远返回指令是带参数的，则将参数和ESP寄存器的当前值相加，以跳过调用者栈中的参数部分，最后的结果是调用者的栈恢复平衡。
6. 如果返回时需要改变特权级，则检查DS,ES,FS和GS的内容，如果段选择子指向数据段或者非一致代码段且段描述符的DPL在数值上小于返回后的新CPL，那么就把数值0传送到该段寄存器。

## 2. 如何转到用户程序（特权级3）的执行

任务寄存器TR总是指向当前任务的TSS，而LDTR寄存器也总是指向当前任务的LDT。TSS是任务的主要标志，因此要使TR寄存器指向当前任务；而使用LDTR的原因是可以在任务执行期间加速对段的访问。

在多任务环境中，从旧任务切换的新任务的时候，TR和LDTR寄存器的值都会更新，以指向新任务。但是，**目前我们只有一个任务，而且是特权级为3的任务，不能用任务切换的方法使它运行**。我们遇到的问题可以表述为：如何从任务的全局空间（处于特权级0）转移到它自己的局部空间（处于特权级3）？

答案是分为两步： 
1. 确立身份，使TR和LDTR寄存器指向这个任务； 
2. 假装从调用门返回；

#### TR和LDTR寄存器

TR和LDTR寄存器都包括16位的选择器部分和描述符高速缓存器部分（如下图所示）。选择器部分的内容是TSS和LDT描述符的选择子；描述符高速缓存器部分的内容则指向当前任务的TSS和LDT，以加速这两个段（表）的访问。

![config](images/24.png)

#### ltr和lldt指令

加载任务寄存器TR的指令是ltr，其格式为

```
ltr r/m16
```

1. 这条指令的操作数是通用寄存器或者16位的内存单元，里面的内容是16位的TSS选择子。
2. 执行这条指令后，**处理器用选择子访问GDT，找到TSS描述符，将基地址、段界限、段属性加载到描述符高速缓存器中，同时将该描述符中的B位置1，但并不执行任务切换**。
3. 该指令属于特权指令，只能在0特权级下执行。
4. 该指令不影响EFLAGS的任何标志位。

加载局部描述符表寄存器LDTR的指令是lldt，其格式为

```
lldt r/m16
```

ltr和lldt指令执行时，**处理器首先要检查描述符的有效性，包括审查它是不是TSS或LDT描述符。在将LDT选择子加载到LDTR后，处理器用该选择子访问GDT中对应的LDT描述符，将段界限和段基地址加载到LDTR的描述符高速缓存器部分**。CS、SS、DS、ES、FS和GS寄存器当前内容不受该指令影响，包括TSS中的LDT选择子字段。

如图，任务全景图。

![config](images/25.png)

注意，现在，局部描述符表（LDT）已经生效，可以通过它访问用户程序的私有内存段了。

#### 假装从调用门返回

从用户程序头部取出栈选择子和栈指针，以及代码选择子和入口点，并将它们顺序压入当前的0特权级栈中。

```
 ;以下假装是从调用门返回。摹仿处理器压入返回参数 
push dword [0x08]                  ;调用前的堆栈段选择子
push dword 0                       ;调用前的esp

push dword [0x14]                  ;调用前的代码段选择子 
push dword [0x10]                  ;调用前的eip

retf
```

这段代码要结合用户程序头部的格式和调用门的返回过程来分析。

用户程序头部的格式如下图

![config](images/26.png)

参照上面从调用门的返回过程是：

1. 检测被调用者栈中CS寄存器的RPL字段值，以确定在返回时特权级是否发生改变。
2. 弹出并使用被调用过程栈上的值加载EIP和CS寄存器。在此过程中会对代码段描述符和代码段选择子的RPL进行特权级与类型检查。
3. 如果远返回指令是带参数的，则将参数和ESP寄存器的当前值相加，以跳过被调用者栈中的参数部分，最后的结果是ESP寄存器指向调用者SS和ESP的压栈值。注意，retf指令的参数必须等于调用门中所有参数的总字节数之和。
4. 如果返回时需要改变特权级，则从栈中将ESP和SS弹出，并把值代入寄存器ESP和SS，切换到调用者的栈。
5. 如果远返回指令是带参数的，则将参数和ESP寄存器的当前值相加，以跳过调用者栈中的参数部分，最后的结果是调用者的栈恢复平衡。
6. 如果返回时需要改变特权级，则检查DS,ES,FS和GS的内容，如果段选择子指向数据段或者非一致代码段且段描述符的DPL在数值上小于返回后的新CPL，那么就把数值0传送到该段寄存器。

上面代码执行完后，栈的布局如下（这其实是内核的栈，并不是用户的0特权级栈）：

![config](images/27.png)

我们对着上面的返回步骤，一步一步来看。 
1. 因为用户程序的CS寄存器中的RPL=3，所以在返回的时候特权级要发生改变。 
2. 弹出用户程序的EIP和CS（绿色部分）加载EIP和CS寄存器。 
3. 第864行的retf指令不带参数，所以这步跳过。 
4. 从栈中将用户程序的ESP和SS（蓝色部分）弹出，并把值代入寄存器ESP和SS，切换到调用者的栈（实际是用户程序的3特权级栈）。 
5. 第864行的retf指令不带参数，所以这步跳过。 
6. 因为DS中的内容是用户程序头部段的选择子，其DPL=3，所以不会把数值0传到DS；至于ES、FS和GS，它们一般会指向内核数据段，其DPL=0，所以这些寄存器很可能被数值0加载，所以用户程序中应该对它们先初始化再引用。

执行远返回指令retf，假装从调用门返回。