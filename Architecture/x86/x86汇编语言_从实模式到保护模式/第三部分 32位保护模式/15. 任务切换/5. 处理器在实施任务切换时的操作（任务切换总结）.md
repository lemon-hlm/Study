处理器可以通过以下**四种方法实施任务切换**： 

1. call指令或者jmp指令的操作数是GDT内的某个**TSS描述符**； 
2. call指令或者jmp指令的操作数是GDT或者LDT内某个**任务门描述符**； 
3. 一个**异常或者中断**发生时，中断号指向IDT内的某个任务门； 
4. 在EFLAGS寄存器的NT位置位的情况下，当前任务执行了一个iret指令。

对于这四种方法，首先都可以得到一个TSS描述符的选择子： 
- 对于1，指令的操作数直接就是TSS选择子； 
- 对于2和3，任务门里包含了TSS选择子； 
- 对于4，当前任务的TSS的任务链接域内就是TSS选择子。 

这个TSS选择子就决定了要切换到哪个任务。

在任务切换时，处理器执行以下操作： 
1. 取得新任务的TSS描述符的选择子（如上文所述）。 
2. 检查是否允许从当前任务切换到新任务。 

（1）数据访问的特权级检查规则适用于**JMP和CALL指令**，当前（旧）任务的CPL和新任务段选择子（TSS描述符的选择子或者任务门的选择子）的RPL必须在数值上<=目标TSS描述符或者任务门的DPL； 

（2）**异常、中断（int n指令发起的中断除外）和IRET指令**引起的任务切换**忽略**目标任务门或者TSS描述符的DPL； 

（3）对于int n指令发起的中断，要检查DPL，要求在数值上，CPL<=任务门描述符的DPL； 

3. 检查新任务的TSS描述符是否已经标记为有效（P=1），并且界限也有效（>=103）； 
4. 检查新任务是否可用。对于以CALL,JMP,异常或者中断发起的任务切换，要求B=0；对于IRET发起的任务切换，要求B=1； 
5. 检查当前任务和新任务的TSS，以及所有在任务切换时用到的段描述符已经安排到系统内存中； 
6. 如果任务切换是由JMP或者IRET发起的，处理器清除当前任务的B标志；如果是由CALL指令、异常或者中断发起的，当前任务的B位保持原来的状态（=1）； 
7. 处理器建立EFLAGS寄存器的一个临时副本。如果任务切换由IRET指令发起，则清除副本中的NT标志；如果是由CALL、JMP、异常或者中断发起的，则保持副本中NT标志不变。 
8. 保存当前任务的状态到它的TSS中：所有通用寄存器、段寄存器中的段选择子、刚才那个EFLAGS的副本，以及EIP； 
9. 加载新任务的EFLAGS寄存器。如果任务切换是由CALL、异常或者中断发起的，处理器把EFLAGS的NT标志置位；如果是由IRET或JMP发起的，NT位不变。 
10. 如果任务切换是由CALL、JMP、异常或者中断发起的，处理器将新任务TSS描述符中的B标志置位；如果由IRET发起，B保持原来的状态（=1）； 
11. 用新任务的TSS选择子和TSS描述符加载TR； 
12. 新任务的TSS状态数据被加载到处理器：包括LDTR寄存器、CR3、EFLAGS、EIP、通用寄存器、段选择子； 
13. 与段选择子相对应的描述符在验证后也被加载； 
14. 开始执行新任务。

任务切换时，新任务的特权级别并不是从那个被挂起的任务继承来的。新任务的特权级别是由其段寄存器CS的低2位决定的，而该寄存器的内容取自新任务的TSS。因为每个任务都有自己独立的地址空间和任务状态段TSS，所以任务之间是彼此隔离的，只需要用特权级规则控制对TSS的访问就行，软件不需要在任务切换时进行显式的特权级检查。

下图是不同任务切换方法对B、NT和任务链接域的影响

![config](images/8.png)