```
7.5 累加和各个数位的分解与显示 
　　7.5.1 栈和栈段的初始化 
　　7.5.2 分解各个数位并压栈 
　　7.5.3 出栈并显示各个数位 
　　7.5.4 进一步认识堆栈 
```

## 1. 栈和栈段的初始化

得到累加和之后，后面就是将它各个数位分解出来，并准备显示在屏幕上。

将分解出来的各个数位并不保存在数据段中，而保存在栈中。

数据还是在内存中，栈（Stack）不过是一种特殊的读写方式。

和代码段、数据段和附加段一样，堆栈也被定义成一个内存段，叫堆栈段（Stack Segment），由段寄存器 SS 指向。

堆栈的操作有两种，分别是将数据推进堆栈（push）和从堆栈中弹出数据（pop）。堆栈指针寄存器 SP（Stack Pointer）表示栈顶。

定义堆栈只需要初始化段寄存器SS和堆栈指针SP的内容。

源码40 ~ 42将堆栈段的段地址设置为0x0000，堆栈指针设为0x0000。

我们定义了3个段了，图7-2是当前内存布局。总的内存容量是 1MB，物理地址的范围是 0x00000～0xFFFFF，其中，假定数据段的长度是64KB（实际上它的长度无关紧要），占据了物理地址 0x07C00～0x17BFF，对应的逻辑地址范围是0x07C0:0x0000～0x07C0:0xFFFF；代码段和堆栈段是同一个段，占据着物理地址0x00000～0x0FFFF，对应的逻辑地址范围是0x0000:0x0000～0x0000:0xFFFF。

![config](images/1.png)

## 2. 分解各个数位并压栈

数位分解还是做除法。每次除法结束后，做一次判断，如果商为0，分解结束。

将每次得到的数入栈，将来还要出栈，所以使用CX寄存器计算数位个数。

源码48、49行，将DX清零，并和 AX 一起形成 32 位的被除数。

32位除以16位，商在AX中，余数在DX中。

与xor一样，or也是逻辑运算指令。

16位处理器上，**push指令**的操作数可以是**16位寄存器或内存单元**。对于内存单元：

```
push word [label_a]
```

**push指令只接受16位的操作数**，为什么要对内存操作数使用关键字“word”。事实上，8086处理器只能压入一个字；但其后的处理器允许压入字、双字或者四字，因此，关键字是必不可少的。

就8086处理器来说，因为压入堆栈的内容必须是字，所以，下面的指令都是非法的：

```
push al
push byte [label_a]
```

处理器在执行**push指令**时：

- **首先**将堆栈指针寄存器SP的内容**减去操作数的字长**（以字节为单位的长度，**在16位处理器上是2**），

- 然后，把**要压入堆栈的数据**存放到**逻辑地址SS:SP所指向的内存位置**（和其他段的读写一样，把堆栈段寄存器 SS 的内容左移 4 位，加上堆栈指针寄存器 SP 提供的偏移地址）。

如图7-3，代码段和堆栈段是同一个段，CS和SS都是 0x0000。源码第 42 行SP被置为 0。所以，当 push 指令第一次执行时，SP的内容减2，即0x0000－0x0002＝0xFFFE，借位被忽略。被压入堆栈的数据，在内存中的位置实际上是 0x0000:0xFFFE。push 指令的操作数是字，而且Intel处理器是使用低端字节序的，故低字节在低地址部分，高字节在高地址部分，正好占据了堆栈段的最高两个字节位置（dx的dh在高字节，dl在低字节）。

![config](images/2.png)

不同于代码段，代码段在处理器上执行时，是由低地址端向高地址端推进的，而压栈操作则正好相反，是从高地址
端向低地址端推进的。（这是一种存储器堆栈的一种方式，堆栈向下增长，这和处理器有关系）

push 指令不影响任何标志位。

## 3. 出栈并显示各个数位

压栈次数（数位的个数）存在寄存器CX中。数位是按“个位”、“十位”、“百位”、“千位”、“万位”的顺序依次压栈（实际情况取决于数的大小），出栈正好相反。**所以可以顺序将它们弹出堆栈并显示在屏幕上**。

源码57行，pop dx指令功能是将逻辑地址SS:SP处的一个字弹出到寄存器DX中，并**将SP内容加上操作数的字长**（2）。

pop指令执行时，处理器将堆栈段寄存器SS的内容左移4位，再加上堆栈指针寄存器SP的内容，形成20位的物理地址访问内存，取得所需的数据。然后，将SP的内容加操作数的字长，以指向下一个堆栈位置。

pop 指令不影响任何标志位。

第 62 行，每次执行 loop 指令时，处理器都是先将寄存器CX减一。当所有的数位都弹出和显示以后，CX必定为零，这将导致退出循环。

当处理器最后一次执行出栈操作后，堆栈指针寄存器 SP 的内容将恢复到最开始设置时的状态，即它的内容重新为 0。

## 4. 进一步认识堆栈

关于堆栈，有几点说明。

第一，push 指令的操作数可以是**16位寄存器**或者**指向16位实际操作数的内存单元地址**，push指令执行后，压入堆栈中的仅仅是该寄存器或者内存单元里的数值，与该寄存器或内存单元不再相干。所以，下面的指令是合法而且正确的：

```
push cs
pop ds
```

这两条指令的意思是，将代码段寄存器的内容压栈，并弹出到数据段寄存器DS。这样，代码段和数据段将属于同一个内存段。实际上，这两条指令的执行结果和下面指令执行结果相同：

```
mov ax,cx
mov ds,ax
```

第二，堆栈在本质上也是普通的内存区域，堆栈、push和pop指令只是方便程序开发。

第三，要注意保持堆栈平衡，防止数据访问越界，防止破坏有用的数据。特别当堆栈段和其他段在同一个段时。如图7-3，堆栈段和代码段属于同一个内存段，段地址都是0x0000，段的长度都是64KB。主引导程序的长度是512（0x200）字节，从偏移地址0x7c00 延伸到0x7e00。堆栈是向下增长的，它们之间有0xffff－0x7e00＋1＝0x8200字节的空档。通常来说，我们的程序是安全的，因为不可能压入这么多的数据。