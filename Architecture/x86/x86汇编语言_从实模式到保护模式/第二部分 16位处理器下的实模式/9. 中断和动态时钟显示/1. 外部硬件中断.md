中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。

外部硬件中断，就是从**处理器外面来的中断信号**。当外部设备发生错误，或者有数据要传送（比如，从**网络**中接收到一个针对当前主机的**数据包**），或者处理器交给它的事情处理完了（比如，**打印已经完成**），它们都会拍一下处理器的肩膀，告诉它应当先把手头上的事情放一放，来临时处理一下。

外部硬件中断是通过两个信号线引入处理器内部的。从8086处理器的时代起，这两根线的名字就叫 NMI 和 INTR。

![config](images/1.png)

## 1. 非屏蔽中断

首先，所有的严重事件都**必须无条件地加以处理**，这种类型的中断是不会被阻断和屏蔽的，称为非屏蔽中断（Non Maskable Interrupt，NMI）。

中断信号的来源，或者说，产生中断的设备，称为中断源。如图9-1所示，在传统的兼容模式下，NMI 的中断源通过一个与非门连接到处理器。**处理器的NMI引脚（该引脚不和中断控制器连接！！！）**是高电平有效的，而中断信号是低电平有效的。当不存在中断的时候，与非门的所有输入都为高，因此处理器的NMI引脚为低电平，这意味着没有中断发生。

当有任何一个非屏蔽的中断产生时，与非门的输出为高。Intel处理器规定，**NMI中断信号由0跳变到1后，至少要维持4个以上的时钟周期才算是有效的**，才能被识别。

这是一个简化的示意图，不是真正的设备连接图。

当一个中断发生时，**处理器将会通过中断引脚NMI和INTR得到通知（这两个引脚只是告诉CPU有中断）**。除此之外，它还应当知道发生了什么事，以便采取适当的处理措施。**每种类型的中断都被统一编号**，这称为中断类型号、中断向量或者中断号。但是，由于不可屏蔽中断的特殊性——几乎所有触发NMI的事件对处理器来说都是致命的，甚至是不可纠正的。在这种情况下，努力去搞清楚发生了什么，通常没有太大的意义。

所以，**在实模式下**，**NMI被赋予了统一的中断号2**，不再进行细分。一旦发生2号中断，处理器和软件系统通常会放弃继续正常工作的“念头”，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。

## 2. 可屏蔽中断

更多的时候，发往处理器的中断信号通常不会意味着灾难。有时候会比较着急处理。

这类中断有两个特点，第一是数量很多，毕竟有很多外部设备；第二是它们可以被屏蔽，这样处理器可以不处理。所以，这类硬件中断称为可屏蔽中断。

可屏蔽中断是通过**INTR引脚（CPU上的引脚，中断控制器的INT与该引脚相连！！！）**进入处理器内部的，像NMI一样，不可能为每一个中断源都提供一个引脚。而且，**处理器每次只能处理一个中断**。在这种情况下，需要一个代理，来接受外部设备发出的中断信号。还有，多个设备同时发出中断请求的机率也是很高的，所以该代理的任务还包括对它们进行**仲裁**，以决定让它们中的哪一个优先向处理器提出服务请求。

如图 9-2 所示，在个人计算机中，用得最多的中断代理就是**8259芯片**，它就是通常所说的**中断控制器**，从8086处理器开始，它就一直提供着这种服务。即使是现在，在绝大多数单处理器的计算机中，也依然有它的存在。

Intel**处理器允许256个中断**，中断号的范围是0～255，**8259负责提供其中的15个**，但**中断号并不固定**。之所以不固定，是因为当初设计的时候，允许软件根据自己的需要灵活设置中断号，以防止发生冲突。**该中断控制器芯片有自己的端口号**，可以像访问其他外部设备一样用**in和out指令**来改变它的状态，包括**各引脚的中断号**。正是因为这样，它又叫可编程中断控制器（Programmable Interrupt Controller，PIC）。

![config](images/2.png)

反正每片8259只有8个中断输入引脚，而在个人计算机上使用它，需要两块。如图9-2所示，第一块8259芯片的代理输出INT直接送到处理器的 INTR 引脚，这是主片（Master）；第二块 8259 芯片的INT输出送到第一块的引脚2上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。

两块8259芯片可以向处理器提供15个中断信号。当时，接在8259上的15个设备都是相当重要的，如PS/2键盘和鼠标、串行口、并行口、软磁盘驱动器、IDE硬盘等。现在，这些设备很多都已淘汰或者正在淘汰中，根据需要，这些中断引脚可以被其他设备使用。

如图 9-2 所示，8259 的**主片引脚0**（IR0）接的是**系统定时器/计数器芯片**；**从片的引脚0**（IR0）接的是**实时时钟芯片RTC（提供闹钟和周期性的中断功能）**。这两块芯片的固定连接到现在也没变。

在8259芯片内部，有**中断屏蔽寄存器**（Interrupt Mask Register，IMR），这是个**8位寄存器**，对应着该芯片的**8个中断输入引脚**，对应的位是 0 还是 1，决定了从该引脚来的中断信号是否能够通过 8259 送往处理器（0 表示允许，1 表示阻断）。当外部设备通过某个引脚送来一个中断请求信号时，如果它没有被IMR阻断，那么，它可以被送往处理器。注意，8259芯片是可编程的，**主片的端口号是0x20和0x21**，从片的端口号是0xa0和0xa1（下面是命令），可以通过这些端口访问8259芯片，设置它的工作方式，包括IMR的内容。

```
[root@CentOS7 ~]# cat /proc/ioports | grep pic
  0020-0021 : pic1
  00a0-00a1 : pic2
```

中断能否被处理，除了8259芯片外，最终的决定权在处理器手中。图6-2，你会发现，在处理器内部，标志寄存器有一个**标志位IF**，这就是中断标志（Interrupt Flag）。当IF为0时，所有从处理器**INTR引脚**（可屏蔽中断，不是NMI）来的中断信号都被忽略掉；当其为1时，处理器可以接受和响应中断。

IF标志位可以通过两条指令cli和sti来改变。这两条指令都没有操作数，cli （CLear Interrupt flag）用于清除 IF 标志位，sti（SeT Interrupt flag）用于置位 IF 标志。

计算机中，中断发生得非常频繁，当一个中断正在处理时，其他中断也会陆续到来，甚至会有多个中断同时发生的情况，这都无法预料。8259芯片会记住它们，并按一定的策略决定先为谁服务。总体上来说，中断的优先级和引脚是相关的，**主片的IR0引脚优先级最高**，IR7引脚最低，从片也是如此。当然，还要考虑到从片是级联在主片的 IR2 引脚上。

最后，当一个中断事件正在处理时，如果来了一个优先级更高的中断事件时，允许暂时中止当前的中断处理，先为优先级较高的中断事件服务，这称为中断嵌套。

## 2. 实模式下的中断向量表

中断处理，归根结底就是处理器要执行一段与该中断有关的程序（指令）。处理器可以识别256个中断（8259只提供其中的15个），那么理论上就需要256段程序。

**在实模式下**，处理器要求将它们的入口点集中存放到内存中**从物理地址0x00000开始**，到0x003ff 结束，**共1KB（256*4=2\^8*2\^2）的空间**内，这就是所谓的**中断向量表（Interrupt Vector Table，IVT）**。

如图 9-3 所示，**每个中断在中断向量表中占2个字（1KB/2字=256）**，分别是中断处理程序的**偏移地址和段地址**。中断0的入口点位于物理地址0x00000处，也就是逻辑地址0x0000:0x0000；中断1的入口点位于物理地址 0x00004 处，即逻辑地址 0x0000:0x0004；其他中断依次类推，总之是按顺序的。

当中断发生时，如果从外部硬件到处理器之间的道路都是畅通的，那么，处理器在执行完当前的指令后，会立即着手为硬件服务。它**首先**会响应中断(**中断控制器通过INTR引脚告诉CPU有中断，仅仅通知**)，告诉8259芯片准备着手处理该中断。**接着**，它还会**要求8259芯片把中断号送过来（CPU和中断控制器之间有总线<注意看图>，实际上是南桥芯片？？）**。

在8259芯片那里，**每个引脚都赋予了一个中断号**。而且，这些**中断号是可以改变的（引脚号和中断号没有必然联系）**，可以对8259编程来灵活设置，但不能单独进行，只能**以芯片为单位进行**。比如，可以指定主片的中断号从0x08开始，那么它每个引脚IR0～IR7所对应的中断号分别是0x08～0x0e。

中断信号来自哪个引脚，8259芯片是最清楚的，所以**它会把对应的中断号告诉处理器，处理器拿着这个中断号（下面是处理器行为）**，要顺序做以下几件事。

① 保护断点的现场。首先要**将标志寄存器FLAGS压栈（没有那些通用寄存器和es，所以需要手动处理！）**，然后清除它的IF位和TF位。TF是陷阱标志，这个以后再讲。接着，再将当前的代码段寄存器 CS 和指令指针寄存器 IP 压栈。

② 执行中断处理程序。由于处理器已经拿到了中断号，**它将该号码乘以4**（毕竟每个中断在中断向量表中占4字节），就得到了该中断入口点在中断向量表中的**偏移地址**。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到IP和CS，自然地，处理器就开始执行中断处理程序了。

![config](images/3.png)

注意，由于 IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用 sti 指令开放中断。

③ 返回到断点接着执行。所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从堆栈中弹出（恢复）IP、CS 和 FLAGS 的原始内容，于是转到主程序接着执行。

**iret同样没有操作数，执行这条指令时，处理器依次从堆栈中弹出数值到IP、CS和标志寄存器。**

由于中断处理过程返回时，已经恢复了FLAGS的原始内容，所以IF标志位也自动恢复。也就是说，可以接受新的中断。

和可屏蔽中断不同，NMI发生时，处理器**不会从外部获得中断号**，它自动生成**中断号码2**，其他处理过程和可屏蔽中断相同。

中断随时可能发生，中断向量表的建立和初始化工作是由BIOS在计算机启动时负责完成的。BIOS 为每个中断号填写入口地址，因为它不知道多数中断处理程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：iret。也就是说，当这些中断发生时，只做一件事，那就是立即返回。当计算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。

## 4. 实时时钟、CMOS RAM 和 BCD 编码

为什么计算机能够准确地显示日期和时间？原因很简单，如图9-2所示，在外围设备控制器芯片 ICH 内部，集成了**实时时钟电路**（Real Time Clock，RTC）和两小块由互补金属氧化物（CMOS）材料组成的**静态存储器**（CMOS RAM）。**实时时钟电路负责计时**，而日期和时间的数值则存储在这块存储器中。

实时时钟是全天候跳动的，即使是在你关闭了计算机的电源之后，原因在于它由主板上的一个小电池提供能量。它为整台计算机提供一个基准时间，为所有需要时间的软件和硬件服务。

除了日期和时间的保存功能外，**RTC芯片也可以提供闹钟和周期性的中断功能**。

日期和时间信息是保存在CMOS RAM中的，通常有128字节，而日期和时间信息只占了一小部分容量，其他空间则用于保存整机的配置信息，比如各种硬件的类型和工作参数、开机密码和辅助存储设备的启动顺序等。**这些参数的修改通常在BIOS SETUP开机程序中进行**。要进入该程序，一般需要在开机时按DEL、ESC、F1、F2 或者 F10 键。具体按哪个键，视计算机的厂家和品牌而定。

RTC芯片由一个振荡频率为32.768kHz的石英晶体振荡器（晶振）驱动，经分频后，用于对CMOS RAM 进行**每秒一次**的时间刷新。

如表 9-1 所示，常规的日期和时间信息占据了CMOS RAM开始部分的10字节，有年、月、日和时、分、秒，报警的时、分、秒用于产生到时间报警中断，如果它们的内容为0xC0～0xFF，则表示不使用报警功能。

![config](images/4.png)

CMOS RAM 的访问，需要通过两个端口来进行。**0x70 或者 0x74 是索引端口**，用来指定CMOS
RAM内的单元；**0x71或者0x75是数据端口**，用来读写相应单元里的内容。举个例子，以下代码用于读取今天是星期几：

```
mov al,0x06
out 0x70,al
in al,0x71
```

```
[root@CentOS7 ~]# cat /proc/ioports | grep rtc
  0070-0071 : rtc0
```

从很早的时候开始，端口0x70的最高位（bit 7）是**控制NMI中断的开关（！！！NMI，不可屏蔽中断有关闭的位置）**。当它为0时，允许NMI中断到达处理器，为1时，则阻断所有的NMI信号，其他7个比特，**即0～6位，则实际上用于指定CMOS RAM单元的索引号**，这种规定直到现在也没有改变。

如图 9-4 所示，尽管端口0x70的位7不是中断信号，但它能控制与非门的输出，决定真正的NMI 中断信号是否能到达处理器。

![config](images/5.png)

通常来说，在往端口0x70写入索引时，应当先读取0x70原先的内容，然后将它用于随后的写索引操作中。但是，该端口是只写的，不能用于读出。早期为了最大使用资源做出的规定。

为了解决这个问题，也为了兼容，ICH芯片允许通过切换访问模式来临时取得那些只写寄存器的内容，但这涉及更高层次的知识，已经超出了当前的话题范畴。现在，我们只想把问题搞得简单些，这么说吧，**NMI中断应当始终是允许的，在访问RTC时，我们直接关闭NMI，访问结束后，再打开NMI**，而不管它以前到底是什么样子。

在早期，CMOS RAM 只有 64 字节，而最新的 ICH 芯片内则可能集成了 256 字节，新增的128 字节称为扩展的 CMOS RAM。当然，在此之前，要先确保 ICH 内确实存在扩展的CMOS RAM。

CMOS RAM 中保存的日期和时间，通常是以二进制编码的十进制数（Binary Coded Decimal，BCD），这是默认状态，如果需要，也可以设置成按正常的二进制数来表示。

比如十进制数 25，其二进制形式是00011001。但是，如果采用BCD编码的话，则一个字节的高4位和低4位分别独立地表示一个0到9之间的数字。因此，十进制数25对应的BCD编码是00100101。

单元 0x0A～0x0D 不是普通的存储单元，而被定义成4个寄存器的索引号，也是通过0x70和0x71 这两个端口访问的。这 4 个寄存器用于设置实时时钟电路的参数和工作状态。

寄存器A和B用于对RTC的功能进行整体性的设置，它们都是8位的寄存器，可读可写，其各位的用途如表 9-2 和表 9-3 所示。

![config](images/6.png)

寄存器 C 和 D 是标志寄存器，这些标志反映了 RTC 的工作状态，寄存器C是只读的，寄存器D 则可读可写，它们也都是 8 位寄存器，其各位的含义如表 9-4 和表 9-5 所示。特别是寄存器 C，因为 RTC 可以产生中断，当中断产生时，可以通过该寄存器来识别中断的原因，比如，是**周期性的中断，还是闹钟中断**。

现在，我们想让 RTC 芯片定期发出一个中断，当这个中断发生的时候，还能执行我们自己编写的代码，来访问 CMOS RAM，在屏幕上显示一个动态走动的时钟。

## 5. 代码清单

源程序文件：c09_1.asm

## 6. 初始化 8259、RTC 和中断向量表

本章代码清单，没有加载器程序。因为可以利用上一章的加载器，只要符合规则。

用户程序的入口点在第119行，到第124行，用于初始化各个段寄存器的内容。下面开始在中断向量表中安装实时时钟中断的入口点。

既然本章的主题是中断，那么就很有必要强调一件事。当处理器执行任何一条改变堆栈段寄存器SS的指令时，它会在下一条指令执行完期间禁止中断。

堆栈无疑是很重要的，不能被破坏。要想改变代码段和数据段，只需要改变段寄存器就可以了。但堆栈段不同，因为它除了有段寄存器，还有堆栈指针。因此，绝大多数时候，对堆栈的改变是分两步进行的：先改变段寄存器SS的内容，接着又修改堆栈指针寄存器SP的内容。

如果刚刚修改了段寄存器SS，在还没来得及修改SP的情况下，就发生了中断，会出现什么后果，而且要知道，中断是需要依靠堆栈来工作的。

因此，处理器在设计的时候就规定，**当遇到修改段寄存器SS的指令时，在这条指令和下一条指令执行完毕期间，禁止中断，以此来保护堆栈（处理器行为，不需要代码保证）**。换句话说，在修改段寄存器SS的指令之后，紧跟着一条修改堆栈指针 SP 的指令。

第 121、122 行执行期间，处理器禁止中断。

RTC芯片的中断信号，通向中断控制器8259从片的第1个中断引脚IR0。在计算机启动期间，BIOS 会初始化中断控制器，将主片的中断号设为从0x08开始，将从片的中断号设为从0x70开始。所以，计算机启动后，RTC 芯片的中断号默认是 0x70。尽管我们可以通过对8259编程来改变它，但是没有必要。

要设置RTC的工作状态，使它能够产生中断信号给8259中断控制器。

RTC到8259 的中断线只有一根，而**RTC可以产生多种中断**。比如闹钟中断、更新结束中断和周期性中断（参见表9-3和表9-4）。RTC的计时（更新周期）是独立的，产生中断信号只是它的一个赠品。所以，如果希望它能产生中断信号，需要额外设置。

以上所说的三种中断，我们只要设置一种就可以了。其实，最简单的就是设置更新周期结束中断。每当RTC更新了CMOS RAM中的日期和时间后，将发出此中断。**更新周期每秒进行一次**，因此该中断也每秒发生一次。

每次当中断实际发生时，可以在程序（中断处理过程）中读寄存器C的内容来检查中断的原因。

RTC芯片设置完毕后，再来打通它到8259的最后一道屏障。正常情况下，**8259是不会允许RTC中断的**，所以，需要修改它内部的中断屏蔽寄存器 IMR。IMR 是一个 8 位寄存器，位 0 对应着中断输入引脚 IR0，位 7 对应着引脚 IR7，相应的位是 0 时，允许中断，为 1 时，关掉中断。

8259芯片是芯片中访问起来很麻烦的一个。

## 7. 使处理器进入低功耗状态

## 8. 实时时钟中断的处理过程

从27行开始。

28~32行，保护现场（**见上面，处理器只会处理FLAGS寄存器，通用寄存器和es需要手动处理**！！），有一点很重要，中断处理过程必须无痕执行，不知道中断什么时候发生，也不知道中断发生时，哪个程序正在执行，所以，必须保证中断返回时，还能还原中断前的状态。

在8259芯片内部，有一个中断服务寄存器（Interrupt Service Register，ISR），这是一个8位寄存器，**每一位都对应着一个中断输入引脚**。当中断处理过程开始时，8259芯片会将相应的位置1，表明正在服务从该引脚来的中断。

一旦响应了中断，8259 中断控制器无法知道该中断什么时候才能处理结束。同时，如果不清除相应的位，下次从同一个引脚出现的中断将得不到处理。在这种情况下，需要程序在中断处理过程的结尾，显式地对8259芯片编程来清除该标志，方法是向8259芯片发送中断结束命令（End Of Interrupt，EOI）。

中断结束命令的代码是 0x20。代码清单 9-1 第 92～94 行就用来做这件事。需要注意的是，如果外部中断是8259主片处理的，那么，EOI 命令仅发送给主片即可，端口号是0x20；如果外部中断是由从片处理的，就像本章的例子，那么，EOI命令既要发往从片（端口号0xa0），也要发往主片。

最后，第96～102行，从堆栈中恢复被中断程序的现场，并用中断返回指令iret回到中断之前的地方继续执行。**iret的意思是Interrupt Return**。