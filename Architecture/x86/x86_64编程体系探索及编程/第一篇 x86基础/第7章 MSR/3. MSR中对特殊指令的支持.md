- 0 概述
- 1 支持sysenter/sysexit指令的MSR
- 2 支持syscall/sysret指令的MSR
- 3 支持swapgs指令的MSR
- 4 支持monitor/mwait指令的MSR

# 0 概述

现在再来看看MSR提供了哪些特殊指令的支持服务，这类特殊指令有：

① sysenter/sysexit指令

② syscall/sysret指令

③ swapgs指令

④ monitor/mwait指令

⑤ 全部的virtual machine类指令

还有rep movs（串指令），以及debug extensions相关的指令也受到MSR的控制。实际上可能会远不止这些，最好参考MSR列表说明。

# 1 支持sysenter/sysexit指令的MSR

有3个MSR对它们提供支持：IA32\_SYSENTER\_CS，IA32\_SYSENTER\_ESP，以及IA32\_SYSENTER\_EIP寄存器，它们的地址分别在：174H，175H，以及176H。参见下图。

![config](./images/14.png)

sysenter/sysexit在实模式下是无效的。在Intel的机器上sysenter/sysexit指令可以在long mode下使用。而在AMD上sysenter/sysexit指令在long mode是无效的，需要注意这些区别。这里的描述以Intel的平台为主。

在32位下，IA32\_SYSENTER\_EIP和IA32\_SYSENTER\_ESP的低32位放入0级权限的目标代码入口点和stack指针，在long mode下可以放入64位的值。然而返回时需要在EDX和ECX寄存器放入返回点的入口和stack指针。

注意IA32\_SYSENTER\_CS寄存器的使用方法，如上图所标注的，所有需要的selector都从这个寄存器获得。下面这段简单的代码清单作为实验7-3（topic07\ex7-3\目录下）。

实验7-3：测试sysenter/sysexit指令

代码清单7-3（topic07\ex7-3\protected.asm）：

```assembly
;; 配置 sysenter/sysexit 使用环境
      xor edx，edx
      mov eax，KERNEL_CS            ;cs 值
      mov ecx，IA32_SYSENTER_CS     
      wrmsr                         ;写 IA32_SYSENTER_CS
      mov eax，sys_service
      mov ecx，IA32_SYSENTER_EIP
      wrmsr                         ;写 IA32_SYSENTER_EIP
      mov eax，1FFF0h
      mov ecx，IA32_SYSENTER_ESP
      wrmsr                         ;写 IA32_SYSENTER_ESP
;; 设置返回指针
      mov ecx，esp
      mov edx，next
； 执行快速切入
      sysenter
next：
      mov esi，msg10
      call puts
```

上面的代码介绍了sysenter/sysexit的基本使用方法，运行结果如下。

![config](./images/15.png)


# 2 支持syscall/sysret指令的MSR

syscall和sysret是由AMD首先引入的，能使用在long mode环境下，可以在AMD的机器上代替sysenter/sysexit指令。Intel不支持syscall/sysret在32位环境下使用。这里的描述以AMD为主。

![config](./images/16.png)

注意在Intel的MSR里，没有IA32_CSTAR寄存器（因为不支持在非64位环境下使用），如图所示，STAR[63：48]是sysret指令使用的CS和SS，STAR[47：32]是syscall指令使用的CS和SS值，低32位用在32位环环境的入口点。在64位环境下应该使用LSTAR寄存器来装入口点，而在兼容模式下应该使用CSTAR寄存器来存放目标代码的入口点（64位的入口点）。

![config](./images/17.png)

需要注意的是sysret指令所需要的selector有些微妙之处（如上图所标示的），那是由于syscall/sysret可以在32位和64位环境下使用。当一个32位的代码运行在compaitility模式下调用了64位的系统服务代码，那么必须从64位的系统服务例程返回到32位的代码下，所以产生了这样的需求。有关这些问题的详情将在后续的话题中探讨。

SFMASK寄存器被使用在对rflags寄存器可以屏蔽某些标志位，当syscall进入目标代码后，SFMASK寄存器的bit被置位则相对应的rflags寄存器标志位被清0，例如，SFMASK[9]=1，则rflags的IF标志（bit 9）被清0，将关闭中断标志。

另一个涉及的MSR是IA32\_EFER（AMD上为EFER），详情请参考6.5节。syscall/sysret需要在IA32\_EFER中开启，软件可以在CPUID.EAX=80000001H leaf里返回的EDX[11]位查询syscall指令是否得到支持。

# 3 支持swapgs指令的MSR

swapgs指令涉及两个相关的MSR：IA32\_KERNEL\_GS\_BASE与IA32\_GS\_BASE寄存器。

IA32\_GS\_BASE寄存器用来设置GS寄存器的64位base地址，在64位环境下，如果需要对GS寄存器设置64位的base地址，不能通过加载segment descriptor的形式（这样只能加载32位base值），需要通过设置IA32\_GS\_BASE寄存器来达到目的。

IA32\_KERNEL\_GS\_BASE寄存器实际上与IA32\_GS\_BASE寄存器有异曲同工之处，可是IA32\_KERNEL\_GS\_BASE寄存器是为swapgs指令所准备的。

![config](./images/18.png)

swapgs指令的目的是交换GS.Base与IA32\_KERNEL\_GS\_BASE的值，如上图所示，这些值是64位的，因此swapgs只能在64位下使用，并且需要0级的权限。GS.base部分是隐藏的，只能被处理器内部使用。当通过IA32\_GS\_BASE寄存器预先设置好GS.base值，在system service例程里就可以用swapgs指令交换它们的base值。

实际上，对系统服务例程来说GS.base原来的值是什么并不重要，swapgs负责将IA32\_KERNEL\_GS\_BASE值装入到GS.base中。

因为在完成系统服务例程后，必须使用swapgs指令再次交换回原来的值。在服务例程里GS.base原来的值处于被忽略的状况。

```assembly
system_servec：
      swapgs                              ； 将 IA32_KERNEL_GS_BASE 值装入到 GS.base 中
      mov rbx， gs：[system_table+8]   ； 获得系统数据结构中的数据
      ... ...
      swapgs                              ； 将 GS.base 原来的值装回到 GS.base 中
      ret
```

在system服务例程入口里，可以像上面的示例一样使用swapgs指令。有意思的是，syscall指令在进入时并没有提供kernel级别的stack指针，可以通过这种方式来获得kernel的stack指针（将stack指针存放在系统数据结构的表格中）。

# 4 支持monitor/mwait指令的MSR

在4.8节有关于monitor/mwait指令的部分探讨，它们涉及的MSR有：IA32_MISC_ENABLE寄存器将开启monitor/mwait指令的支持位。

程序中检测是否支持monitor/mwait指令通过CPUID.01H leaf里的ECX[3]查询，可是这个ECX[3]位是由IA32\_MISC\_ENABLE[18]位的monitor enable决定的。它反映在CPUID.01H：ECX[3].MONITOR标志位上。

因此，可以通过IA32\_MISC\_ENABLE[18]位关闭monitor/mwait指令，当IA32\_MISC\_ENABLE[18]=0时，由CPUID.01H leaf查询返回的ECX[3]被清0（MONITOR/MWAIT不可用）。

另一个相关的寄存器是IA32\_MONITOR\_FILTER\_LINE\_SIZE，用来设置监视地址范围，默认的情况下LINE\_SIZE是64字节。IA32\_MONITOR\_FILTER\_FILE\_SIZE寄存器的用法是写入两次值，写入较小的值被作为最小的line size，写入较大的值被作为最大的line size。

>实验7-4：对MONITOR/MWAIT指令进行disable看看结果如何？接下来尝试修改监视的line size，查看结果如何

注意：这个实验必须在真机环境上测试，如果在VMware虚拟机上测试结果是不对的（VMware进行了一些屏蔽）。

代码清单7-4（topic07\ex7-4\protected.asm）：

```assembly
；； 打印原来的值
      call dump_CPUID_leaf_01_ecx
      call println
      call dump_CPUID_leaf_05
      call println
      mov esi，msg11
      call puts
；；现在更改 monitor/mwait enable位，以及更改 monitor line size
；        mov ecx，IA32_MISC_ENABLE
；        rdmsr
；        btc eax，18                                          ； 将 monitor/mwait 指令disable
；        wrmsr
；； 注意当 MONITOR/MWAIT 指令被 disable 时，IA32_MONITOR_FILTER_LINE_SIZE 寄存器是不可用的
      mov ecx，IA32_MONITOR_FILTER_LINE_SIZE
      xor edx，edx
      mov eax，2000H                                        ； 设置最大监视 line size 为 2000H
      wrmsr
      mov eax，1000H                                        ； 设置最小监视 line size 为 1000H
      wrmsr
；； 打印新的值
      call dump_CPUID_leaf_01_ecx
      call println
      call dump_CPUID_leaf_05
      call println
```

注意：不能在将monitor/mwait指令disable掉的同时，修改监视line size值，当关闭monitor/mwait指令时，IA32\_FILTER\_LINE\_SIZE寄存器是不可用的，修改不了line size值。