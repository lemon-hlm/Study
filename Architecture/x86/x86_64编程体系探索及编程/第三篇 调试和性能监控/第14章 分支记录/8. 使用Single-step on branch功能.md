**IA32\_DEBUGCTL寄存器**的**BTF位**，可以帮助我们**快速地跳过不必要的指令级single\-step**，而基于在**每个branch间的single\-step**。当**BTF=1并且TF=1**时，将启用single\-step on branch功能。

即设置后, **只有发生branch(！！！**)才会**进入\#DB handler(！！！**).

在**进入\#DB handler**时，处理器会：

① **清TF标志位**，在**退出\#DB handler后**，处理器会**从stack中的eflags寄存器映像恢复eflags寄存器值(自动恢复IF标志！！！**)。

② **清IA32\_DEBUG寄存器的BTF位**，退出\#DB handler后，处理器**不会恢复BTF位(！！！**)。如果需要，**软件必须重新置BTF位**来重启single\-step on branch功能。

>实验14\-8：测试single\-step on branch

我们通过实验来认识single\-step on branch功能，在代码中我们需要：

① **开启IA32\_DEBUGCTL**寄存器的**BTF位**。

② **开启Eflags**寄存器的**TF**位。

③ \#DB handler里，在**退出\#DB handler之前**重新**开启BTF位**，继续监控下一个branch

实验的代码在topic14\ex14-8\protected.asm文件里。

代码清单14\-13（topic14\ex14-8\protected.asm）：

```assembly
； ① 设置 debug control
      mov ecx，IA32_DEBUGCTL
      mov edx，0
      mov eax，2                ; BTF=1
      wrmsr
； ② 开启 single-step
      pushf
      bts DWORD [esp]，8        ; eflags.TF=1
      popf
； ③ 测试 single-step
      mov ecx，0
      mov ecx，1
      mov ecx，2
      jmp next1                 ; branch 1
      mov ecx，3
      mov ecx，4
      mov ecx，5
next1：
      mov ecx，6
      mov ecx，7
      jmp next2                 ; branch 2
      mov ecx，8
      mov ecx，9
      mov ecx，10
next2：
      pushf
      btr DWORD [esp]，8        ; eflags.TF=0
      popf
； 清 BTF
      mov ecx，IA32_DEBUGCTL
      mov edx，0
      mov eax，0
      wrmsr
```

在代码中测试了**两个由jmp指令产生的branch**，下面是测试的结果。

![config](./images/34.jpg)

这个结果中产生了**两次\#DB异常(只有发生branch时候才会\#DB异常！！！**)，分别发生在0x90C1和0x90DC，下面是简要的分析。

![config](./images/35.jpg)

从上面的示意图中，我们可以了解到single\-step on branch的功能，**branch产生后(！！！**)的**第1条指令执行前(！！！**)发生\#**DB异常**。也就是在**执行完分支后发生\#DB异常**。