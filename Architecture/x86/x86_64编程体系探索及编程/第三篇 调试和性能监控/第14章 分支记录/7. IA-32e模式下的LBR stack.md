[TOC]

从上面14.4.1节的描述里，我们知道在**IA\-32e模式**下，**LBR stack**的**from/to地址使用64位的格式**，包括：

① **64位的linear address**。

② **64位的rip值**。

③ **64位的rip值及flags**。

在compatibility模式下，使用64位地址的低32位。下面我们将对IA\-32e模式的LBR stack进行测试，包括**在0级**和**3级**权限下进行测试。

我们使用了LBR的过滤机制，在0级权限下过滤条件设置为

① JCC=1：过滤所有Jcc指令分支记录。

② NEAR\_IND\_JMP=1：过滤所有的near indirect jmp指令和near indirect call指令分支记录（对Westmere微架构来说）。

③ NEAR\_REL\_JMP=1：过滤所有的near relative jmp指令和near relative call指令分支记录（对Westmere微架构来说）。

因此，在这个实验里只保留了far branch的分支记录。

实验14-6：测试64位模式下的LBR stack

在64位模式下测试，笔者将dump\_lbr\_stack（）函数进行了相应的修改，实现在lib\debug64.asm文件里，是为64位代码而准备的。

我们的主体代码在long.asm模块里，如下。

代码清单14-10（topic14\ex14-6\long.asm）：

```assembly
； ① 开启 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      bts eax，0                            ； LBR=1
      wrmsr
； ② 设置过滤条件
      mov ecx，MSR_LBR_SELECT
      mov edx，0
      mov eax，0xc4                        ； JCC=NEAR_IND_JMP=NEAR_REL_JMP=1
      wrmsr
； ③ 产生 branch
      mov esi，msg
      LIB32_PUTS_CALL                      ； 调用 lib32 库的 puts（） 函数
； ④ 关闭 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      btr eax，0                             ； LBR=0
      wrmsr
； ⑤ 输出 LBR stack 信息
      call dump_lbr_stack
```

这里的过滤条件是JCC=1，NEAR\_IND\_JMP=1，以及NEAR\_REL\_JMP=1，如前面所述，这个条件在Nehalem和Westmere微架构下将过滤所有的near call和jmp指令分支，除了far branch（在Sandy Bridge微架构下得到改正）。

这个实验的branch的产生是

```assembly
mov esi，msg
LIB32_PUTS_CALL                      ； 调用 lib32 库的 puts（） 函数
```

LIB32\_PUTS\_CALL是一个宏，定义在lib.inc文件里，定义为

```assembly
mov eax，LIB32_PUTS            ； lib32库函数编号
call lib32_service             ； 将切入到 32 位 compatibility 模式调用 lib32 库函数
```
这个lib32\_service()的用途是在64位模式下切入到compatibility模式，然后调用32位的lib32库函数，好处是重复使用lib32库的所有函数，因此在lib64库里只实现了很少的函数，大部分的函数都在lib32库里实现，这样可以在64位模式和32位legacy模式下共同使用。（关于这一点，详见12.6.3节所述。）

在使用lib32_service（）之前，需要在eax寄存器里提供lib32库函数的编号，所有的lib32库函数的编号都在inc\lib.inc头文件里定义。

我们设置的过滤条件除了far branch外所有分支记录都过滤。这样做的目的是：我们很容易观察lib32_service（）函数到底是如何在64位模式和compatibility模式之间进行切换的（因为它们间的切换必须使用far pointer形式）。

下面是运行的结果。

![config](./images/25.jpg)

最上面输出的信息就是由lib32\_service()函数调用打印出来的。在修改后的dump\_lbr\_stack()函数里显示了From/To地址的格式，在这个结果输出里，我们看到地址格式属于000011B格式，使用64位EIP值加上Flags。

前面已经提过，这个值是从IA32\_PERF\_CAPABILITIES寄存器里读取出来的

```assembly
mov ecx，IA32_PERF_CAPABILITIES
rdmsr
and eax，0x3f                    ； 得到 format值
```

在这个结果中，一共只捕捉了4条branch记录，如下表所示。

![config](./images/26.jpg)

下面我们看看这些记录是在哪个环节被捕捉的。

① 第1条被捕捉的记录出现在lib32\_service（）函数内。

![config](./images/27.jpg)

这是在lib32\_service（）函数里，通过使用far pointer调用call\-gate进入0级的系统服务stub入口。

② 第2条被捕捉的记录，出现在代码接着来到的\_\_lib\_service（）函数里。

![config](./images/28.jpg)

第2条被捕捉的branch记录是由jmp指令产生的，它使用far pointer负责切入到compatibility模式，这将表示接下来运行在compatibility模式下。

③ 第3条被捕捉的记录，在执行完lib32库的函数后。

![config](./images/29.jpg)

在\_\_lib32\_service（）代码里，第3条被捕捉的jmp指令产生branch记录，当执行完最终的lib32库函数后，由这条jmp指令负责切回64位模式。

④ 第4条被捕捉的记录在\_\_lib32\_service（）函数执行完毕后，返回到lib32\_service（）函数里。

![config](./images/30.jpg)

最后一条被捕捉的branch记录由一条远程返回指令RETF产生，它将返回到lib32_service（）函数中，最终返回到我们的主体函数中。

事实上，我们可以利用Bochs提供的调试功能很方便地检查一下这4条分支记录产生的地方，对照上面的论述。

实验14\-7：测试64位下过滤CPL=0的记录

接下来的实验，我们的代码将进入3级用户代码中，在3级权限代码下观察LBR stack，在这个实验里，过滤条件只有一个。

CPL\_EQ\_0=1：这将过滤所有CPL=0下的分支记录。

下面是主体代码的设置。

代码清单14-11（topic14\ex14-7\long.asm）：

```assembly
； ① 开启 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      bts eax，0                            ； LBR=1
      wrmsr
； ② 设置过滤条件
      mov ecx，MSR_LBR_SELECT
      mov edx，0
      mov eax，1                           ； CPL_EQ_0=1（过滤所有CPL=0下的分支记录）
      wrmsr
； ③ 开启 DR7.L0位
      mov rax，dr7
      bts rax，0                           ； L0=1
      mov dr7，rax
； ④ 设置断点
      mov rax，breakpoint    ； 设置在 user 代码下的执行断点
      mov dr0，rax      ； 目的是：在 user 代码下进入 #DB handler打印
；； 切换到用户代码
      push USER_SS | 3
      mov rax，USER_RSP
      push rax
      push USER_CS | 3
      push user_entry
      retf64
```

代码流程最后进入3级权限里，需要注意的是，由于对LBR stack MSR寄存器的读取需要0级权限，因此必须在0级权限下执行dump\_lbr\_stack（）函数。

因此，我们可以设置一个调试断点产生\#DB异常，在\#DB handler里打印LBR stack的信息。

使用\#DB debug异常的另一个好处是，它可以自动清IA32\_DEBUGCTL的LBR位，这样无须在3级代码里想办法清LBR位（避免继续监控）。

代码清单14-12（topic14\ex14-7\long.asm）：

```assembly
user_entry：
； 使用 Call-gate 调用
      mov esi，msg1
      mov eax，LIB32_PUTS
      call lib32_service
； 使用 sysenter 调用
      mov esi，msg2
      mov eax，LIB32_PUTS
      call sys_service_enter
； 使用 syscall 调用
      mov esi，msg3
      mov eax，LIB32_PUTS
      call sys_service_call
breakpoint：
      mov rax，rbx                        ； 在此设置断点，进入#DB handler 打印LBR stack
```

上面是在3级用户代码下，测试了三种输出方法。

① 使用call-gate调用，也就是使用lib32\_service（）方式来调用lib32库的puts（）函数。

② 使用sysenter/sysexit指令方式，这是一种快速切入系统服务例程的方式，最终还是切入到\_\_lib32\_service（）函数。

③ 使用syscall/sysret指令方式，这是另一种快速切入方式，最终还是切入到\_\_lib32\_service（）函数。

下面是运行的结果。

![config](./images/31.jpg)

这次捕捉了13条branch记录，我们简略地看看由sys\_service\_enter（）调用产生的branch记录：

![config](./images/32.jpg)

如图所示，我们看到在sys\_serevice\_enter（）调用环节中，共捕捉了4条branch记录，对照一下运行结果的输出。

![config](./images/33.jpg)

值得注意的是，当在0级代码里使用sysexit指令从0级代码返回到3级代码里时，这个sysexit指令产生的branch记录也被捕捉了。

我们看到，由sysenter指令切入到0级的代码中，所有的branch记录都被过滤掉了，这就是我们所设置的过滤条件（CPL\_EQ\_0=1）所产生的结果。