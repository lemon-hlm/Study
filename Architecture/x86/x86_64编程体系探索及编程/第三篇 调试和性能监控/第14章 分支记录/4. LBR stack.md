[TOC]

# 0 概述

当IA32\_DEBUGCTL寄存器的**LBR位置位**时，使用**LBR stack**记录**branch trace**，LBR stack是使用**数对from/to MSR寄存器来构造的**。from/to寄存器的数量由处理器的微架构来决定。使用14.1节所说的方法检测处理器的DisplayFamily\_DisplayModel后，在**相应的MSR表**里查出处理器**相应的from/to寄存器对数量**。

![config](./images/6.jpg)

如上所示，**LBR stack**由**MSR\_LASTBANCH\_n\_FROM\_IP**和**MSR\_LASTBANCH\_n\_TO\_IP**组成，其结构**与内存的stack结构相似**，也有相应的**Top指针**来确定**LBR stack栈顶(！！！**)位置。

# 1 FROM\_IP与TO\_IP寄存器

MSR\_LASTBRANCH\_n\_FROM\_IP和MSR\_LASTBRANCH\_n\_TO\_IP是**MSR寄存器**，它们的地址和数量因处理器微架构的不同而不同，在Nehalem微架构下的结构如下所示。

![config](./images/7.jpg)

其中IA32\_LASTBRANCH\_x\_FROM/TO\_IP中的**x是指寄存器的编号**，在Nehalem微架构及后续的Westmere和SandyBridge上共有**16对FROM/TO寄存器**，分别如下。

① IA32\_LASTBRANCH\_0\_FROM\_IP到IA32\_LASTBRANCH\_15\_FROM_IP。

② IA32\_LASTBRANCH\_0\_TO\_IP到IA32\_LASTBRANCH\_15\_TO\_IP。

它们的地址分别如下（Nehalem微架构下）。

① x\_FROM\_IP寄存器地址：**从680H到68FH**。

② x\_TO\_IP寄存地址：**从6C0H到6CFH**。

每个微架构下的处理器**MSR地址可能会不同**（**这些寄存器**可以说是**nonarchitectural**）。

从Nehalem微架构开始**IA32\_LASTBRANCH\_x\_FROM\_IP寄存器**的**Bit 63位是MISPRED位**，在Intel64手册里，这个位名叫**MISPRED位**。可是当Bit 63置位时，指示branch是mis\-predicted（非预测的），清位时是predicted（预测的）。

值得注意的是，这些**MSR寄存器**是**Read\-Only（只读的**），不能对它进行写。

在IA\-32e模式下可以使用64位的地址，可是这个64位地址有几种格式依赖于IA32\_PERF\_CAPBILITIES寄存器。

## 1.1 From/To寄存器中address的格式

在**Intel64**处理器下From/To寄存器中存放的**address可以有不同的格式**，依赖于**IA32\_PERF\_CAPABILITIES寄存器的\[5\:0\]域**的值，分别如下。

① 000000B时：存放**32位**的格式。

② 000001B时：存放**64位的linear address**格式。

③ 000010B时：存放**64位的EIP值**（注意：与上面的000001B格式是不同的）。

④ 000011B时：存放64位的EIP值，并且存放额外的Flag值（即MISPRED位）。

下面是IA32\_PERF\_CAPABILITIES寄存器的结构。

![config](./images/8.jpg)

注意，这个MSR寄存器是只读的，因为只能从它读出值，在它的[5：0]就是LBR format域，它的值就是上面所述的4个值（在图中只注明了3个值，不包括3值）

因此，要确定From/To寄存器里存放的地址是什么格式，需要从IA32_PERF_CAPABILITIES寄存器读出LBR format域来判断。

我们关注到在64位下有3种不同的64位地址格式。

① 64位linear address格式：那么From/To寄存器将存放经过segmentation（段式管理）转换过来的linear address值。

② 64位的RIP值：那么From/To寄存器将存放RIP寄存器的值，这个值是未经过转换的effective address值（即逻辑地址），也就是在程序代码中所直接看到的RIP值。

③ 64位的RIP值加上额外的MISPRED标志位。在From寄存器的bit 63位就是MISPRED标志位。

在Intel64和AMD64体系的64位模式下都使用平坦的内存模式，CS段的base都强制为0值。因此，实际上在64位模式下，64位的RIP值与64位的linear address的存放格式是一样的。

可是，当处理器运行在IA-32e模式的compatibility模式下，这个64位的RIP与64位的linear address格式就可能不同了（在大多数OS下使用平坦的内存模式，各个段的base值使用0值，因此大多数情况下还是相同的）。

在compatibility模式下，64位的地址值只有低32位是有效的。高32位值将被清0。

在IA32处理器下的MSR_LASTBRANCH寄存器

在32位体系（不支持Intel64体系）的处理器下，LBR stack使用共4个MSR\_LASTBRANCH\_x寄存器来组成，从MSR\_LASTBRANCH\_0到MSR\_LASTBRANCH\_3，其结构如下。

![config](./images/9.jpg)

在32位处理器下将64位的MSR寄存器分为两个32位的from/to寄存器使用，低32位是FROM\_IP寄存器，高32位是TO\_IP寄存器。这些地址是32位的linear address形式。

在早期的NetBurst微架构的Pentium4处理器是属于32位的处理器，不支持Intel64体系（即不支持IA-32e模式）。

# 2 IA32\_LASTBRANCH\_TOS寄存器

LBR stack中的Top指针由IA32\_LASTBRANCH\_TOS寄存器来担任，如下所示。

![config](./images/10.jpg)

IA32\_LASTBRANCH\_TOS寄存器的低4位[3：0]是LBR stack的top指针值，它指向共16个LBR stack entry值，TOP指针指向最后一条捕获的分支记录。

IA32\_LASTBRANCH\_TOS将同时指出From\_IP和To\_IP寄存器的位置，因此当前的From\_IP和To\_IP寄存器位置是相同的。IA32\_LASTBRANCH\_TOS寄存器的地址在1C9H，属于architectural化的寄存器，在各个微架构中地址都是统一的。

# 3 LBR stack的使用

LBR stack的使用几乎与内存stack是一样的，最大的不同如下。

① LBR stack的top指针是加1指向下一个stack元素（似乎可以说是向上增长）。

② 内存stack的ESP/RSP指针是减4/8，指向下一个stack元素，它是向下增长的。

Top指针的回绕

在LBR stack中，目前实现仅仅只有16个stack entry。因此，这个LBR stack很快就会写满了。当LBR stack写满时IA32\_LASTBRANCH\_TOS的值会重新回到0值，重新指向开头的IA32\_LASTBRANCH\_0\_FROM\_IP和IA32\_LASTBRANCH\_0\_TO\_IP寄存器。

在后面我们将会看到，BTS buffer写满时可以产生一个DS Interrupt来做相应的处理。

