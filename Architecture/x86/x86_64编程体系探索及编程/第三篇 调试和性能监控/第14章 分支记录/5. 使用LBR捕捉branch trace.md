[TOC]

# 1 基本原理

现在，我们可以使用**LBR stack**来监控**所有最近的branch、interrupt，以及exception**，除了前面所述的几种情形。

① 发生\#**DB异常**时**不能被捕捉到branch trace**，LBR将**被冻结**。

② 当FREEZE\_LBRS\_ON\_PMI被置位，发生的**PMI中断**时，LBR将**被冻结**。

③ 当FREEZE\_WHILE\_SMM\_EN被置位，进入**SMM模式**，LBR**将被冻结**。

除了退出SMM模式处理器会自动恢复LBR外，其他情形需要软件重新开启LBR位。

>实验14-1：使用LBR捕捉branch trace记录

下面我们将通过一个练习实验来使用LBR，实验的代码在topic14\ex14-1\目录下。

代码清单14-1（topic14\ex14-1\protected.asm）：

```assembly
； ① 开启 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      bts eax，LBR_BIT                        ； LBR=1
      wrmsr
； ② 调用一个函数，产生 branch trace record
      call func
； ③ 清 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      btr eax，LBR_BIT                        ； LBR=0
      wrmsr
； ④ 打印 LBR stack 信息
      call dump_lbr_stack
      call println
```

上面代码中，① 中开启**IA32\_DEBUGCTL寄存器**的**LBR位**。

② 里调用一个**测试函数**来**产生branch trace记录**。

③ 里我们需要**关闭LBR位**，目的是执行下面的打印函数，否则处理器会继续产生branch trace记录。

在④ 里调用dump\_lbr\_stack（）函数来**打印LBR stack的信息**。

代码清单14-2（topic14\ex14-1\protected.asm）：

```assembly
；； 测试函数
func：
      mov edx，puts
      mov ebx，dump_pae_page
      mov esi，msg2
      call edx
      mov esi，0x400000                ； dump virtual address 0x400000
      call ebx
      ret
func_end：
```

上面代码是调用测试函数func()，用来打印出**0x400000地址**的**各级table entry**信息。

这个**dump\_lbr\_stack**()实现在lib\debug.asm模块里，函数较长，这里不再列出。使用的**原理如下**。

① **枚举16个from/to寄存器**。

② 读取**IA32\_LASTBRANCH\_TOS寄存器**，确定**当前的top指针**。

③ 输出**from/to寄存器值**和**top信息**。

这个实验只能在真实的机器上运行，因为**Bochs和VMware将不支持(！！！**)。

![config](./images/11.jpg)

这是在Westmere微架构的Core i5处理器上的运行结果。上面的dump 0x400000地址信息是调用测试函数func()的输出结果。

我们可以看到：

① 结果分别列出了**16个from\_ip**和**to\_ip寄存器**的**地址值**。

② **LBR stack已经装满**了，top指针正指向**第9号FROM\_IP/TO\_IP寄存器**，这是**最后一条捕获的branch record**。

③ 最后一条分记录的**from\_ip地址是0x000090CD**，to\_ip地址是**0x00009083**。

由于**LBR stack实在太小**了，一个函数里又调用了其他的函数，因此已经让它满了十数次（或许数十次甚至更多）。

我们来看看**当前的from\_ip**和**to\_ip地址**是什么指令（借助于Bochs的调试功能）。

```
（0） Breakpoint 1，0x00000000000090cd in ？？ （）
Next at t=156762556
（0） [0x00000000000090cd] 0018：00000000000090cd （unk. ctxt）：ret                 ； c3
<Bochs：3> s
Next at t=156762557
（0） [0x0000000000009083] 0018：0000000000009083 （unk. ctxt）：mov ecx，
0x000001d9       ； b9d9010000
<Bochs：4>
```

我们将执行**断在0x000090CD地址**上，这个地址是一条**ret指令(！！！**)，它**返回到0x00009083地址**上，正好是我们上面实验结果输出的**当前top指向**。

很显然，这是func()执行完毕后**返回到调用者**，这是**最后一次的branch trace记录**，0x00009083处的指令将用来**清LBR位（IA32\_DEBUGCTL寄存器地址是1d9H**），我们可以对比一下上面的代码清单14\-1和14\-2结果看看是否符合。

实验14-2：观察LBR stack

如果说上面的实验还**不够直观显示LBR stack动态效果（因为满了**），下面我们做一个更直观些的实验，产生**数条branch trace记录**但**不让LBR stack装满**。

代码清单14-3（topic14\ex14-2\protected.asm）：

```assembly
； 实验 14-2：观察 LBR stack
      mov esi，msg2
      call puts
； ① 开启 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      bts eax，LBR_BIT   ； 置 LBR 位
      wrmsr
； ② 测试分支
jmp l1
l1：  jmp l2
l2：  jmp l3
l3：  jmp l4
l4：  jmp l5
l5：  jmp l6
l6：  jmp l7
l7：  jmp l8
l8：  jmp l9
l9：  jmp l10
l10：
； ③ 清 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      btr eax，LBR_BIT   ； 清 LBR 位
      wrmsr
； ④ 输出 LBR stack 信息
      call dump_lbr_stack
      call println
```

这一次实验的②里直接使用**10条jmp指令**产生**10条分支记录**，这样可以不让LBR stack装满，我们可以直观地查看LBR stack的情况。
下面是在Westmere架构的Core i5处理器上的运行结果。

![config](./images/12.jpg)

由于使用连续的jmp指令产生分支，我们看到在这些分支记录中，**前一条记录的to\_ip值**是**后一条记录的from\_ip**值。**当前TOP指针**指向**第10号的FROM\_IP/TO\_IP寄存器**。

## 1.1 LBR stack中的TOP指针工作方式

我们看到**当前的top指针值是10**，而**0是空**的，这个结果就很能说明问题：**LBR stack**和**内存栈**的**工作原理一样**（先push指向下一条记录位置，再记录），所**不同的是生长方向**。在**内存stack**中，当**push**时，先将**esp减4再压入值**。而LBR stack在记录时，先将**top加1**再**写入From\_IP和To_IP寄存器(！！！**)。

# 2 LBR的过滤功能

**CPL\-qualified BTS功能**只能用于**BTS**上，于是从Nehalem微架构开始（及后续的Westmere和SandyBirdge）**增强了LBR**功能，允许处理器**对LBR进行过滤**，屏蔽一些branch trace不进行记录，包括**CPL限制功能**。

## 2.1 MSR\_LBR\_SELECT寄存器

在**增强的LBR功能**里，处理器可以通过设置一些**过滤条件**来对**某些branch trace进行屏蔽**，这些过滤条件由一个**MSR\_LBR\_SELECT寄存器**来实现，这个寄存器的地址在**1C8H**。

它的结构如下所示。

![config](./images/13.jpg)

MSR\_LBR\_SELECT是一个**mask寄存器**，也就是说当**相应的位置位**时，**对应的分支情况将被过滤**。因此，有**两种极端**的情形。

① 当**所有位清0**时将捕捉**所有的branch**情况。

② 当**所有位置位**时将过滤**寄存器列举**的所有branch情况。

处理器在**power\-up**或**reset**时会**清MSR\_LBR\_SELECT所有位**，将允许捕捉**所有的branch**。

MSR\_LBR\_SELECT允许**对9种branch**进行过滤。

## 2.2 过滤CPL=0时的branch

当CPL\_EQ\_0=1时，处理器运行在CPL=0级别时将过滤所有branch。

## 2.3 过滤CPL！=0时的branch

当CPL\_NEQ\_0=1时，处理器运行在CPL！=0时（即1、2及3级）将过滤所有branch。

## 2.4 过滤JCC的branch

当JCC=1时，处理器将**过滤所有Jcc指令的branch**，Jcc指令中的**cc是条件码**，关于cc条件码请参考2.5.2.4节的描述。

## 2.5 过滤near relative call（相对调用）的branch

当NEAR\_REL\_CALL=1时，处理器将**过滤所有near（段内）的相对call指令的branch**，这个relative call是指基于IP/EIP/RIP指令指针偏移的call指令。而near是指段内的call/jmp。

哪一类call指令属于near relative call呢？下面的代码属于relative call。

```assembly
      call next                ； E8 01 00 00 00   （ relative call）
      nop                        ； 90
next：nop                        ； 90
```

上面这条call指令属于relative call，它被编译出来的opcode是E8，实质上所有的relative call都是near类型的（不可能属于far类型）。

## 2.6 过滤near indirect call（间接调用）的branch

当NEAR\_IND\_CALL=1时，处理器将过滤所有的间接near call指令的branch，这个indirect call（间接调用）中的indirect是指EIP值是间接从操作数里得到，这个操作数或者是寄存器，或者是内存操作数。

哪类call属于near indirect call呢？依据call指令的操作数有两类情形。

① call reg16/32/64：使用寄存器操作数。

② call [mem]：使用memory操作数。

如下代码展示了两种near indirect call形式。

```assembly
      mov eax，func
      mov [func_pointer]，eax
      call eax                        ； near indirect call 形式 1
      call [func_pointer]          ； near indirect call 形式 2
      ... ...
func：ret
```

当call指令操作数是寄存器时这个call必然是near类型。当操作数是内存时可能属于far类型，参见后面的far branch描述。

## 2.7 过滤near ret（near返回）的branch

当NEAR_RET=1时，处理器将过滤所有near ret指令的branch。near ret是与near call配套的指令。在指令助记符方面，near ret和far ret是有区别的。

① near ret指令的助记符是RET，它的opcode是C3H或C2H。

② far ret指令的助记符是RETF，它的opcode是CBH或CAH。

## 2.8 过滤near indirect jmp（间接跳转）的branch

当NEAR\_IND\_JMP=1时，处理器将过滤所有的near indirect jmp指令的branch，和near indirect call的情形一样，下面两类属于near indirect jmp指令。

① jmp reg16/32/64：使用寄存器操作数。

② jmp \[mem\]：使用memory操作数。

```assembly
      mov eax，target
      mov [func_pointer]，eax
      jmp eax                        ； near indirect jmp 形式 1
      jmp [func_pointer]          ； near indirect jmp 形式 2
      ... ...
target：
      ... ...
```

上面展示了这两种near indirect jmp指令形式。可是还有下面的特别情况。

注意：在Nehalem和Westmere微架构的处理器上，NEAR\_IND\_JMP=1时，同时也会对near indirect call指令的分支记录进行过滤！

这真是让人费煞思量，NEAR\_IND\_JMP=1时，间接等于同时也将NEAR\_IND\_CALL置位。

## 2.9 过滤near relative jmp（相对跳转）的branch

当NEAR\_REL\_JMP=1时，处理器将过滤relative jmp指令的branch，relative jmp也是基于IP/EIP/RIP指令指针的偏移跳转，relative jmp依据操作数的长度产生两个opcode码：EBH和E9H。

注意：在Nehalem和Westmere微架构的处理器上，NEAR\_REL\_JMP=1时，同时也会对near relative call指令的分支记录进行过滤！

因此，当NEAR\_REL\_JMP=1时，它的效果还要附加上将NEAR\_REL\_CALL置位。

## 2.10 过滤far branch

当FAR\_BRANCH=1时，处理器将过滤所有的far branch，包括far call和far jmp情形。far call或jmp指令的操作数将是far pointer形式，这个far pointer包括direct形式和indirect形式。

① direct（直接）形式：如 call 0x0018：0x00400000（使用立即数操作数）。

② indirect（间接）形式：如 call far \[func\_pointer\]（使用memory操作数）。

注意：far branch的情形还包括Int/iret（中断调用和返回），以及retf指令的分支！因此，什么是far？什么是near？far是指跨段调用（也就是需要加上segment selector），near是段内调用（不改变运行权限，不需要加上segment selector）。

因此，当FAR_BRANCH=1时，实际上有下面几种分支记录会被过滤。

① far call（远程调用）与retf（远程返回）。

② far jmp（远跳转）。

③ int与iret（中断调用与返回），sysenter/sysexit指令调用，syscall/sysret指令调用，以及各种异常发生而进入异常服务例程。它们都改变了权限，需要提供目标代码的selector。

上面这9个过滤条件可以同时设置多个组合来达到过滤多个branch trace，这样可以使用LBR有效地监控某一些branch事件。

## 2.11 使用LBR过滤功能

下面我们将设置几组过滤条件来测试LBR的过滤功能。

① 实验14-3里：过滤所有的near relative call和 near relative ret指令产生的branch trace。

② 实验14-4里：将测试由jmp指令产生的branch trace过滤情况。

实验14-3：过滤near relative call/ret分支

笔者是带着下面这个问题来测试call分支的，接下来的测试将为我们解开疑惑。

问题：当设置了过滤call指令时，是过滤call指令，还是整个call分支都过滤掉？

测试实验的代码在topic14\ex14-3\目录下，下面是主体代码。

代码清单14-4（topic14\ex14-3\protected.asm）：

```assembly
； ① 复制测试函数 func（） 到 0x400000 地址上
      mov esi，func
      mov edi，0x400000
      mov ecx，func_end - func
      rep movsb
； ② 开启 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      bts eax，LBR_BIT                       ； 置 LBR 位
      wrmsr
； ③ 设置过滤条件
      mov ecx，MSR_LBR_SELECT
      xor edx，edx
      mov eax，0x28                           ； 过滤所有 near relative call/ret 指令
      wrmsr
； ④ 测试函数
      mov eax，0x400000
      call eax                                  ； 使用 near indirect call
； ⑤ 清 LBR
      mov ecx，IA32_DEBUGCTL
      rdmsr
      btr eax，LBR_BIT                        ； 清 LBR 位
      wrmsr
； ⑥ 输出 LBR stack 信息
      call dump_lbr_stack
      call println
```

在①里将测试函数func()复制到0x400000位置进行调试测试。在③中设置的过滤条件如下。

① NEAR\_REL\_CALL=1。

② NEAR\_RET=1。

这将过滤所有的near relative call和near ret指令产生的分支。在④里有效使用indirect call来调用测试函数func（）。

代码清单14-5（topic14\ex14-3\protected.asm）：

```assembly
；； 测试函数
func：
      mov eax，func_next
      jmp eax                              ； near indirect jmp
func_next：
      call get_eip                        ； near relative call
get_eip：
      pop eax
      mov eax，0
      mov esi，msg1                        ； 空字符串
      int 0x40                              ； 使用 int 来调用 system service
      ret
func_end：
msg1        db 10，0                         ； 空字符串（换行）
```

上面代码是测试函数func（），里面测试了三种分支：indirect jmp（间接跳转），relative call（相对调用）和int 0x40（中断调用）。这个中断调用是用来测试打印一个换行符。下面是运行结果。

![config](./images/14.jpg)

在这个结果里，共捕捉了10条branch记录，这些分支记录如下表所示。

![config](./images/15.jpg)

下面将它分解为几个阶段来仔细分析这个过滤过程。

① 在主体代码里（0x9000区域的运行空间）第1条记录转到func（）函数，如下所示。

![config](./images/16.jpg)

这是在调用测试函数时产生的branch。这个call属于indirect（间接）call指令，我们的过滤条件是relative（相对）call指令，因此这个branch不会被过滤。

② 在测试函数func（）里（运行在0x400000区域里），如下所示。

![config](./images/17.jpg)

在func（）里被捕捉到两个branch，最后由int 0x40中断调用来到一个stub函数，地址在0xD8E0上，最后跳入0xE0A0地址，这是属于lib32模块的运行空间。注意在这个阶段里有一个call指令被过滤掉，这是一个near relative类型的call指令。

③ 接着进入到lib32模块里的\_\_system\_service（）函数。

![config](./images/18.jpg)

在\_\_system\_service（）函数中被捕捉到3条branch，由call eax指令调用最终的函数，而iret指令是最后一条被捕捉的branch，当执行完服务函数后，由iret指令返回到0x400000运行空间里。

④ 由\_\_system\_service（）函数里的call指令调用最终的实现服务例程\_\_puts（），这个服务函数位于lib32.asm模块里。

![config](./images/19.jpg)

在\_\_puts（）函数里，捕捉到2条branch记录，分别是：第8条和第9条branch记录。注意第7条branch记录在call__putc指令继续调用其他函数的后续指令流里产生。
而第9条被捕捉的jz指令虽然在前面，但是只有当最后一次循环（ZF=1）时才产生branch记录，因此当第8条branch记录（jmp指令）产生时，前面的jz指令没有被执行。
⑤ 最后，我们看看第7条被捕捉到的branch是来自哪里，看看下面的示意图。

![config](./images/20.jpg)

第7条branch来自最低一层的\_\_write\_char()函数，它是负责写一个字符到video区的最终函数。它由\_\_putc()来调用，\_\_putc()函数里被过滤了2条branch，而\_\_write\_char()函数被过滤了4条branch，实际情况会很多，因为当打印一条字符串时，便会产生很多条跳转branch，因此多少条branch取决于输出多长的信息。

到此为止，我们跟踪完这个实验所捕捉到的10条branch的产生情况。我们看到，所有的near relative call和relative ret指令产生的branch都被成功地过滤掉了。

现在我们可以回答上面提出的问题。

处理器仅过滤call指令，不会过滤由call指令调用所产生的整个branch记录（后续指令中符合条件的所有branch记录会被过滤）。

同时，我们也看到执行int指令进行中断调用也被成功记录在LBR stack上。

# 3 实验

>实验14\-4：测试jmp分支的过滤条件

在这个实验里我们将进行两个测试。

① 当将所有的jmp指令过滤条件设置时。

② 将所有的jmp指令过滤条件置位，除FAR\_BRANCH条件外。

## 3.1 测试一

在测试一里将过滤所有jmp分支，包括indirect和relative的jmp指令，所有的Jcc（条件跳转），还包括far jmp（远跳转）的情况。我们需要设置：

① JCC=1，过滤所有条件跳转指令分支记录。

② NEAR\_IND\_JMP=1，过滤所有near indirect jmp指令分支记录。

③ NEAR\_REL\_JMP=1，过滤所有relative jmp指令分支记录。

④ FAR\_BRANCH=1，过滤所有far jmp指令（还包括far call的情形）分支记录。

与实验14-3是同样的代码，只是过滤的条件改变了。

代码清单14-6（topic14\ex14-4\protected.asm）：

```assembly
； ③ 设置过滤条件
      mov ecx，MSR_LBR_SELECT
      xor edx，edx
      mov eax，0x1c4                  ； 过滤所有 jmp 指令
      wrmsr
```

这个过滤条件值为0x1C4，表示上述的4个过滤条件都被置位。

下面是测试的结果，或许会让你有些失望。

![config](./images/21.jpg)

这个测试没有捕捉到任何的branch记录，因此我们知道：

① 当NEAR\_IND\_JMP=1时，同时也将所有near indirect call的分支记录过滤了。

② 当NEAR\_REL\_JMP=1时，同时也将所有的relative call分支记录过滤了。

③ 当FAR\_BRANCH=1时，同时也将Int 0x40中断调用产生的分支记录过滤了。

## 3.2 测试二

下面我们再看看测试二，在这里，我们需要改一下测试代码，修改的部分如下。

代码清单14-7（topic14\ex14-4\protected.asm）：

```assembly
； 测试二（对所有的jmp过滤条件置位，除了 FAR_BRANCH）
      mov ecx，MSR_LBR_SELECT
      xor edx，edx
      mov eax，0xc4                          ； 过滤所有 jmp 指令（除了 FAR_BRANCH）
      wrmsr
； ④ 测试函数
； 测试一（使用 near indirect call）
；      mov eax，0x400000
；      call eax                              ； 使用 near indirect call
； 测试二（使用 far call）
      call DWORD KERNEL_CS：0x400000     ； 改用 far call 形式调用
```

修改的代码有两部分。

① 过滤条件值改为0xC4，分别为NEAR\_IND\_JMP=1、NEAR\_REL\_JMP=1，以及JCC=1。

② 测试函数改用far call调用形式，用来测试FAR\_BRANCH。

下面是测试的结果。

![config](./images/22.jpg)

当去掉FAR\_BRANCH过滤条件时，这个测试可以捕捉3条件branch记录。分别如下。

① 从0x90A7到0x400000：这条branch记录是由call KERNEL_CS：0x400000指令产生的（执行far call指令）。

② 从0x400017到0xD8E0：这条branch记录是由int 0x40指令产生的（执行中断调用）。

③ 从0xE883到0x400019：这条branch记录是由iret指令产生的（执行中断返回）。

```
（0） [0x00000000000090a7] 0018：00000000000090a7 （unk. ctxt）：call far
0018：00400000  ;9a000040001800
<Bochs：5> c
（0） Breakpoint 2，0x0000000000400017 in ？？ （）
Next at t=156751382
（0） [0x0000000000400017] 0018：0000000000400017 （unk. ctxt）：int 0x40   ;cd40
<Bochs：6> c
（0） Breakpoint 3，0x000000000000e883 in ？？ （）
Next at t=156751427
（0） [0x000000000000e883] 0018：000000000000e883 （unk. ctxt）：iretd  ;cf
```

利用Bochs的调试功能，我们在这些捕捉到的branch记录下断点，观察到上面的这3条branch记录的from和to地址。

NEAR\_IND\_JMP和NEAR\_REL\_JMP对call指令会产生影响，不知是否可以算是处理器的bug！

直到Sandy Bridge微架构中，才修改这个问题，用Intel的话来说是在Sandy Bridge微架构，LBR过滤机制已经被enhanced（增强）：

“In Intel microarchitecture code name Sandy Bridge，each logical processor has its own MSR\_LBR\_SELECT. The filtering semantics for "Near\_ind\_jmp" and "Near\_rel\_jmp"has been enhanced”

![config](./images/23.jpg)

我们看到，在Sandy Bridge微架构上，已经对这个问题进行改正，上图来自Intel新文档，显示call指令不再受NEAR\_IND\_JMP和NEAR\_REL\_JMP的影响了。