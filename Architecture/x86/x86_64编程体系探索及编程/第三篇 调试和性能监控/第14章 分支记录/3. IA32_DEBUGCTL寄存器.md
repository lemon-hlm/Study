
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 概述](#0-概述)
	* [0.1 LBR（Last Branch Record）位](#01-lbrlast-branch-record位)
	* [0.2 BTF（single\-step on branch）位](#02-btfsingle-step-on-branch位)
	* [0.3 TR（trace record message）位](#03-trtrace-record-message位)
	* [0.4 BTS（branch trace store）位](#04-btsbranch-trace-store位)
	* [0.5 BTINT（branch trace interrupt）位](#05-btintbranch-trace-interrupt位)
* [1 配置Branch trace record的存放](#1-配置branch-trace-record的存放)
* [2 CPL\-qualified branch record（受CPL限制的BTS）](#2-cpl-qualified-branch-record受cpl限制的bts)
	* [2.1 查询是否支持CPL-qualified功能](#21-查询是否支持cpl-qualified功能)
	* [2.2 配置CPL\-qualified功能](#22-配置cpl-qualified功能)
* [3 冻结监控](#3-冻结监控)
	* [3.1 冻结LBR监控](#31-冻结lbr监控)
	* [3.2 冻结Performance monitoring counter监控](#32-冻结performance-monitoring-counter监控)
	* [3.3 在SMM里冻结所有监控](#33-在smm里冻结所有监控)
	* [3.4 测试是否支持FREEZE\_WHILE\_SMM\_EN位](#34-测试是否支持freeze_while_smm_en位)
	* [3.5 Core外的PMI请求](#35-core外的pmi请求)
	* [3.6 PMI中断](#36-pmi中断)

<!-- /code_chunk_output -->

# 0 概述

处理器的**Branch记录功能开启**由一个**总的寄存器IA32\_DEBUGCTL**进行控制。IA32\_DEBUGCTL是**架构化（architectural）的MSR寄存器**，所有支持last branch record功能的微架构的处理器中，IA32\_DEBUGCTL寄存器的**地址都是统一的(！！！**)，在**1D9H地址**上。

![config](./images/2.jpg)

上面这是在Nehalem微架构上的IA32\_DEBUGCTL寄存器，这个寄存器结构也同样适合在Westmere和Sandy Bridge微架构的处理器上。

## 0.1 LBR（Last Branch Record）位

这个位用来**开启LBR stack**的使用。当**LBR=1**时，处理器将在**LBR stack中**记录处理器的**branch/interrupt/exception**的记录（**from和to地址**）。当LBR=0时，处理器将不会在LBR stack中记录。

值得注意的是，当**发生debug异常**（\#**DB异常！！！**）时，处理器会**对LBR位进行清位**。这意味着，**不能捕捉到\#DB异常的trace！！！**，在\#**DB handler退出**时也**不会恢复LBR的值**，需要**软件置位来重新开启LBR记录功能(！！！**)。

## 0.2 BTF（single\-step on branch）位

这个控制位的开启可以使**每个single\-step（单步调试**）基于**每次的branch（分支**），而**不是基于每条指令**。

- 当**BTF=1**并且**Eflags.TF=1**，那么处理器将在**每次branch/interrupt/exception发生时**才**产生single\-step调试**。

- 当**BTF=0**并且**Eflags.TF=1**时，处理器在**每条指令执行后**产生**single\-step调试**。

值得注意的是，处理器**进入\#DB handler时**也会**对BTF进行清位**，这同样意味着**基于branch的单步调试将被关闭**。\#DB handler退出**不会恢复BTF位**的值。

如果**call/jmp指令**引发**task switch（任务切换**），处理器将**不会发生single\-step调试异常（BTF被忽略**）。**debugger软件**应该使用**TSS的T标志**位来**产生task switch时**的\#**DB异常**。

## 0.3 TR（trace record message）位

设置TR位可以**开启BTM（Branch Trace Message）的产生**。当TR=1时，每次发生**branch**、**interrupt**及**exception**时，处理器将**产生BTM记录**送往**system bus**或记录在**BTS区域（依赖于是否开启BTS控制位**），否则将**不会产生BTM记录**。

值得注意的是，当**进入\#DB handler**时，处理器**会维持TR的值**，也就是**BTM的产生依然是有效(！！！**)的。即使**LBR位被清**，**TR=1**时，处理器**依旧会更新LBR stack**（这点产生了疑惑）。

## 0.4 BTS（branch trace store）位

设置**BTS位**可以让处理器使用**BTS buffer存储区域**来**记录分支**，不过还需要**依赖于TR控制位**。

当**BTS=1**并且**TR=1**时，处理器每次检测到发生**branch**、**interrupt**及**exception**时**产生BTM记录**，并将BTM存储在**内存DS（Debug Store）区域**内的**BTS buffer**里。

## 0.5 BTINT（branch trace interrupt）位

当**BTINT=1**时，允许处理器在检测到**BTS buffer满**时产生一个**DS interrupt(！！！**)，这个DS interrupt将使用由**Local APIC的LVT Performance寄存器**中设置的**PMI（Performance Monitoring Interrupt）中断handler(！！！**)处理。

当**BTINT=0**时，BTS buffer将以一个**环形回路**的形式存在。当BTS buffer满时自动**回绕到BTS buffer的base（buffer头部**）继续记录。

# 1 配置Branch trace record的存放

前面提及Branch trace record可以存放在**三个地方**：**LBR stack**，**system bus**，以及**BTS buffer区域**，到底存放在哪里由上面所说的IA32\_DEBUGCTL寄存器的**LBR**、**TR**、**BTS**，以及**BTINT位**来决定，如下表所示。

![config](./images/3.jpg)

我们看到三个地方的配置如下。

① **仅LBR=1**时，branch trace record将在**LBR stack**中记录。

② **仅TR=1**时，BTM将发送到**system bus**上。

③ **TR=1**并且**BTS=1**时，BTM将记录在**内存DS（Debug Store**）区域内的**BTS buffer**里。

在NetBurst、Atom家族，以及Nehalem（包括**后续的**）微架构上支持BTM**同时记录在LBR stack和System bus/BTS buffer上(！！！**)，而Core微架构及Pentium M前的处理器将不支持同时设置TR和LBR位（当同时设置时LBR stack的内容未定义）。

当**TR=0**时，**BTS位和BTINT位**是**被忽略**的。关于LBR stack、DS（Debug Store），以及BTS buffer将在后续的章节进行探讨。

# 2 CPL\-qualified branch record（受CPL限制的BTS）

处理器允许根据**CPL（当前运行的权限级别**）的**不同**来**记录BTM信息**。根据**IA32\_DEBUGCTL寄存器的配置**，当处理器运行在OS kernel级别或User级别时有**选择性地进行记录**。

## 2.1 查询是否支持CPL-qualified功能

CPL\-qualified功能需要处理器的支持，使用**CPUID指令**查询CPUID.01H：ECX[4].DSCPL位置位时，处理器将支持该功能。

## 2.2 配置CPL\-qualified功能

这个功能需要使用**IA32\_DEBUGCTL寄存器**的**BTS\_OFF\_OS**和**BTS\_OFF\_USR位**，如下表所示。

![config](./images/4.jpg)

当BTS\_OFF\_OS=1时，关闭记录kernel（CPL=0）里的BTM记录。当BTS\_OFF\_USR=1时，关闭记录User（CPL>0）里的BTM记录。

当两个位同时置位时，这是一个极端的情况，则会**关闭所有的BTM记录**。虽然**BTM不会在BTS buffer**里记录，但处理器**依然产生BTM**（Branch Trace Message）。

我们看到，CPL\-qualified功能可以减少部分监控branch时系统的开销。

注意，CPL\-qualified功能**仅使用在BTS buffer(！！！**)上。

当TR=1且BTS=1时，可以对BTS buffer的BTM进行配置，如下表所示。

![config](./images/5.jpg)

我们看到，CPL\-qualified**不能**使用在**LBR stack**和送往**System bus**的情形上。

# 3 冻结监控

在IA32\_DEBUGCTL寄存器中有**三个位**可以设置**当发生某些中断时停止监控(！！！**)，这三个位如下。

① FREEZE\_LBRS\_ON\_PMI（bit 11）：在**PMI**里**关闭LBR stack的记录功能**。

② FREEZE\_PERFMON\_ON\_PMI（bit 12）：在**PMI**里**关闭所有counter（计数器**）。

③ FREEZE\_WHILE\_SMM\_EN（bit 14）：在**SMM**里**关闭所有counter**及**分支记录功能**。

这些**监控事项**包括：

① **LBR stack**记录的**branch trace record**。

② **System bus**和**BTS buffer**中的**BTM**。

③ **performance monitoring counter（性能监控事件的计数器**）。

上述的IA32\_DEBUGCTL寄存器的3个控制位可以冻结这些事项中的部分或全部。

## 3.1 冻结LBR监控

对**FREEZE\_LBRS\_ON\_PMI置位**时，当处理器发生**PMI中断（Performance Monitoring Interrupt！！！**）时，将**清IA32\_DEBUGCTL寄存器的LBR位**。因此**进入PMI中断handler时**，处理器将**不能记录LBR stack**，当从PMI handler**退出后**，如果**软件需要重新对LBR进行监控(！！！**)，必须**对LBR位进行置位**重新开启LBR stack的记录。

## 3.2 冻结Performance monitoring counter监控

对FREEZE\_PERFMON\_ON\_PMI置位时，当处理器发生**PMI中断时(！！！**)，将**清**IA32\_PERF\_GLOBAL\_CTRL寄存器的所有enable位，包括：**IA32\_PMC（通用计数器**）的enable位和**IA32\_FIXED\_CTR（固定用途计数器**）的enable位。

IA32\_PMC寄存器与IA32\_FIXED_CTR寄存器的数量依赖于微架构的实现。我们将在第15章里进行探讨。

因此，FREEZE\_PERFMON\_ON\_PMI置位会**对所有的counter（计数器）停止计数**，软件必须重新设置IA32\_PERF\_GLOBAL\_CTRL寄存器的enable位来**重启事件监控**。

## 3.3 在SMM里冻结所有监控

对**FREEZE\_WHILE\_SMM\_EN进行置位**时，当发生**SMI请求**进入**SMM模式**，处理器将清所有的IA32\_PERF\_GLOBAL\_CTRL寄存器enable位，停止所有的performance monitoring事件监控，并且清IA32\_DEBUGCTL寄存器的LBR、BTF、TR及BTS位，停止所有的branch trace监控。

在退出SMM模式后，处理器将恢复IA32\_DEBUGCTL寄存器原有的设置，IA32\_PERF\_GLOBAL\_CTRL寄存器的enable位被置1，重启所有的监控。因此，我们看到，处理器保证在SMI handler执行期间（在将要进入SMI handler和退出SMI handler之前）不会监控所有这些事项。

## 3.4 测试是否支持FREEZE\_WHILE\_SMM\_EN位

在对FREEZE\_WHILE\_SMM\_EN置位前，需要在IA32\_PREF\_CAPABILITIES寄存器里查询bit 12是否为1来确认支持使用FREEZE\_WHILE\_SMM\_EN位。

而IA32\_PREF\_CAPABILITIES寄存器需要查询CPUID.01H：ECX[15].PDCM位来获得支持。下面是一个设置FREEZE\_WHILE\_SMM\_EN位的示例。

```assembly
      mov eax，01
      cpuid
      ; 测试 PDCM 位，是否支持 IA32_PREF_CAPABILITIES 寄存器
      bt ecx，15                    
      ; 不支持
      jnc no_support                  
      ; MSR 寄存器地址 345H
      mov ecx，IA32_PREF_CAPABILITIES 
      ; 读 IA32_PREF_CAPABILITIES
      rdmsr
      ; 测试 FREEZE_WHILE_SMM 位
      bt eax，12
      ; 不支持
      jnc no_support
      ; MSR 寄存器地址 1D9H
      mov ecx，IA32_DEBUGCTL
      rdmsr
      ; FREEZE_WHILE_SMM_EN=1
      bts eax，14
      ; 设置 IA32_DEBUGCTL 寄存器
      wrmsr
      jmp next
no_support：
... ...
```

这段代码只是展现了对FREEZE\_WHILE\_SMM\_EN置位所需的流程，IA32\_PREF\_CAPABILITIES寄存器的支持度查询可能在其他地方已经测试过。

## 3.5 Core外的PMI请求

在Nehalem微架构及后续的微架构上，**IA32\_DEBUGCTL寄存器**加入了一个**UNCORE\_PMI\_EN位**，当UNCORE\_PMI\_EN=1时，允许处理器**接受uncore（core外部**）的**PMI中断**请求。

## 3.6 PMI中断

**PMI（Performance Monitoring Interrrupt）中断**是**监控某个事件**，当**事件的counter（计数器**）产生 **overflow（溢出**）时而**引发的中断**。它需要在**Local APIC的LVT寄存器表**中的**LVT preformance monitor寄存器**里提供**vector、delivery模式等相关设置**。因此，使用PMI中断（或说preformance monitoring机制）**必须开启APIC**的使用。实际上**DS（Debug Store）interrupt**和**PMI中断**使用**同一个vector和ISR（Interrupt Service Routine！！！**），我们将在后续的章节里探讨。