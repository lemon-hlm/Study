[TOC]

https://blog.csdn.net/wlmnzf/article/details/79319509

Spectre以及meltdown漏洞是前段时间，十分热门的两个漏洞，它们之所以广受重视，是因为它们根据的是体系结构的设计漏洞，而非针对某个系统或者某个软件，因此它几乎可以遍及大多数近代的CPU。

这里主要有三个漏洞: 

- Variant 1: bounds check bypass (CVE-2017-5753)【绕过边界检查】 
- Variant 2: branch target injection (CVE-2017-5715)【分支目标注入】 
- Variant 3: rogue data cache load (CVE-2017-5754)【恶意数据缓存载入】 

Spectre 主要利用前两个漏洞进行攻击，而meltdown则主要利用第三个漏洞进行攻击。

# 1 内存映射

Linux和Windows的内存映射方法是不同的，在linux中，虚拟空间地址有4G，0\~3G为用户空间，3\~4G为内核空间 

![config](./images/12.png)

其中**内核空间都相同**，准确的讲是**每个进程共享同一个内核空间** 

![config](./images/13.png)

Linux在启动时会**初始化一个进程**，然后通过**fork()生成子进程**，Linux的fork机制会把**父进程的页表和堆栈等一模一样地复制一份**，然后在**运行**时，**子进程**通过**缺页异常**等操作来**改变用户空间**，如果**内核空间部分也改变**了，则**只修改初始化进程的内核空间(！！！**)，其它**子进程访问该页**时，再通过**缺页中断**将这部分内容**从父进程更新过来**。

一般来讲，当**进程**进行**系统调用**进入**内核态**的时候，它应该能够访问**整个地址空间**的，但是在这里**只能访问自己的1G的地址空间**，于是我们需要通过**地址的映射**，来使他可以**访问整个空间**，内核空间分为：ZONE\_DMA（内存开始的16MB） 、ZONE\_NORMAL（16MB\~896MB）、ZONE\_HIGHMEM（896MB \~ 结束）三个区域，其中0\~896M是直接映射的，其余部分会进行非线性映射。

![config](./images/14.png)

# 2 Tomasulo算法

![config](./images/15.png)

原始的Tomasulo算法是为了**寄存器重命名**以便**消除指令的数据**相关，**数据一到就可以执行指令**。

1. **指令**首先存在于**指令队列(L1 Instruction cache**)之中。

2. 指令一条一条地从**队列中取出来**，进行**译码**，然后放到**对应的操作保留站**中，比如**加法指令**放到**加法保留站**中。**乘法指令**放到**乘除法保留站**中。**Vj**和**Vk**中是用来**存储源操作数**的（已经**就绪的源操作数值**取自于**浮点寄存器**），若**源操作数还没有准备好**，则通过**Qj**和**Qk**指向**操作数的保留站号**，等到**被指向的保留站**中的**操作计算出了结果**，则结果可以通过**结果总线**传回到**保留站中需要的指令**，然后将其**Qj**和**Qk**中的**值改为0（表示已经准备好**）。

3. 当**Qj**和**Qk**都为**0**时，那**一条指令**就可以**送到乘/除器中执行**。

# 3 乱序执行

最早期CPU都是**顺序执行**的，前一条指令未执行完毕，则后一条指令必须等待着，就像我们烧水，必须洗茶壶，烧水，洗茶杯，倒水必须按照顺序来做，但是事实上烧水和洗茶杯可以同时执行，其实有很多指令也是如此，调整它们的顺序可以加快程序执行的速度

可能会造成**乱序执行**的原因： 

1. **编译器**为了**优化**而实现**指令重排（静态调度**） 
2. CPU实现**指令的多发射**，以及**并行执行**，并为了优化实现**指令的重排（动态调度**）

程序的乱序执行并不意味着在所有步骤中，指令的顺序都是混乱的，事实上，**指令**在**发射时**和**提交时**依然是**顺序**的，只是在**执行**的过程中会**打乱顺序**。

为了支持乱序执行

![config](./images/16.png)

我们在Tomasulo 算法中加入了**ROB**来使得**提交结果**的时候能够按照**顺序提交**，执行的**结果暂时存放于ROB**而**不直接写入寄存器堆**，然后再按**顺序提交数据**。从而可以不出问题。

本次的漏洞就是利用了这一特性来实现的

# 4 分支预测

由于在指令中存在许多跳转和分支，为了提前访问分支中的代码以解决时间，我们加入了分支预测功能

## 4.1 静态分支

对于所有的**跳转指令**，我们都预测执行**跳转**或者执行**不跳转**，则称其为**静态跳转**

## 4.2 动态分支

**动态分支**将会通过**历史跳转信息**来**预测下一次分支**应该**选择跳转**还是**选择不跳转**。在intel设计中有一个称为**BTB(Branch Target Buffer**)的部件，当我们**执行分支指令**时，会将**执行结果**和**分支指令地址**记录在其中，当**下次取址**时，查询**其中的记录**，若存在，则根据历史执行记录进行预测是否跳转。

若**不存在此记录**，我们将会使用**静态分支预测器**，我们一般将**向上跳转的分支指令**看作**循环**，对于循环我们**倾向于接受跳转**，而对于**向下跳转**，我们**倾向于不跳转**。

# 5 Meltdown

![config](./images/17.png)

在**第一行**，我们**引发了一个异常**，若程序按照**顺序执行**，第三行的access将不会被执行，但是由于程序是**乱序执行**的，因此在**异常引发之前**，第三行的access将被执行，但是**执行结果存在ROB**中**不会被提交**，当异常触发以后，第三行的执行结果将被撤销掉，从计算机外部看来第三行的access就跟从未被执行过一样，但是事实上它**只是在后期被撤销**了，这会带来一个小问题，就是在执行过程中，**刚才读取的数据**已经被**存储到高速缓存**中。

我们可以通过**侧信道攻击**来确认刚才访问的数据是什么。

![config](./images/18.png)

这段代码揭示了**攻击的关键部分** 

首先我们将**访问内核地址**并**取内容到寄存器**内，若这一举动可以**触发异常**，则**对应的寄存器清零**，若**异常未处理**，则**应用程序将会被终止**，并且**取出的值**将会**存入应用程序核心转储的寄存器**中。我们要做的就是**通过第5行将相应的寄存器清零**，从而可以**判断这是一个错误的值**。然后**再次重试**，直到**遇到一个不为0的值**，然后将**秘密的值作为地址**，去做**读取操作**，以便**cache记录到这个地址**，实现**侧信道攻击**。

# 6 Spectre

![config](./images/19.png)

**Spectre**主要利用了**分支预测**和**乱序执行**的漏洞实现的，如图所示的代码，看起来十分地正常，若x小于array1的长度的时候，循环顺利执行。但是我们假设这里有一个存储密码的变量地址为secret，并且令a=secret-array1，于是我们可以使用array1[a]来表示secret的值。当多次执行循环的时候，我们的x满足循环条件，则我们的分支预测模块会认为下一个循环也满足循环条件而去预执行这个循环，若此时我们将a的值赋值给x，则分支预测模块预测本次循环为执行（其实并不会执行），CPU会预执行这个循环体，然后将我们存储密码的secret值取出来，并将其作为地址去访问array2，但是最终发现循环不应该被执行，于是刚才取出来的值将会被作废。但是我们的这个secret值的地址已经被存入到缓存中去。我们最终可以将array2读取一遍，若读取某个地址的时候，访问的时间特别短，则说明这个地址就是那个被存入缓存的地址（即我们的密码值）。

# 7 参考

https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html

https://lwn.net/Articles/738975/

http://lib.csdn.net/article/linux/29085

https://bugs.chromium.org/p/project-zero/issues/detail?id=1272

http://blog.csdn.net/yiyeguzhou100/article/details/72875122

https://bbs.pediy.com/thread-61327.htm

http://blog.csdn.net/muxiqingyang/article/details/6686738